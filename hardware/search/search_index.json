{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"ch376/","text":"ch376","title":"ch376"},{"location":"ch376/#ch376","text":"","title":"ch376"},{"location":"stratos/","text":"Stratos Specs G\u00e9n\u00e9rales 15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier Fonctionnement atmos compatible La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ? Cas non g\u00e9r\u00e9s WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC Controleur usb, sdcard, clavier, souris Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi) Port ethernet ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ... EEprom kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg Kernel Orix 16bits appels via jsr avec un param\u00e8tre de primitive ?","title":"Stratos"},{"location":"stratos/#stratos","text":"","title":"Stratos"},{"location":"stratos/#specs-generales","text":"15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier","title":"Specs G\u00e9n\u00e9rales"},{"location":"stratos/#fonctionnement-atmos-compatible","text":"La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ?","title":"Fonctionnement atmos compatible"},{"location":"stratos/#cas-non-geres","text":"WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC","title":"Cas non g\u00e9r\u00e9s"},{"location":"stratos/#controleur-usb-sdcard-clavier-souris","text":"Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi)","title":"Controleur usb, sdcard, clavier, souris"},{"location":"stratos/#port-ethernet","text":"ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ...","title":"Port ethernet"},{"location":"stratos/#eeprom","text":"kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg","title":"EEprom"},{"location":"stratos/#kernel-orix-16bits","text":"appels via jsr avec un param\u00e8tre de primitive ?","title":"Kernel Orix 16bits"},{"location":"twilighteboard/","text":"Twilighte board FDC, RTC WIFI controller","title":"Twilighte board"},{"location":"twilighteboard/#twilighte-board","text":"FDC, RTC WIFI controller","title":"Twilighte board"},{"location":"twilighteboard/fdcWifiEsp/","text":"fdcsd I/O : * $315 : command port * $316 : data port ESP32_CHECK_EXIST ESP32_CHECK_EXIST = $06 Return data inverted bit ESP32_GET_IC_VER ESP32_GET_IC_VER = $01 Return version ESP32_SET_MODE CH376_SET_MODE = $15 Set mode ESP32_SET_MODE_CODE_FDC ESP32_LAUNCH_WIFI_SCAN $02 interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#fdcsd","text":"I/O : * $315 : command port * $316 : data port","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#esp32_check_exist","text":"ESP32_CHECK_EXIST = $06 Return data inverted bit","title":"ESP32_CHECK_EXIST"},{"location":"twilighteboard/fdcWifiEsp/#esp32_get_ic_ver","text":"ESP32_GET_IC_VER = $01 Return version","title":"ESP32_GET_IC_VER"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode","text":"CH376_SET_MODE = $15 Set mode","title":"ESP32_SET_MODE"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode_code_fdc","text":"","title":"ESP32_SET_MODE_CODE_FDC"},{"location":"twilighteboard/fdcWifiEsp/#esp32_launch_wifi_scan-02","text":"interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"ESP32_LAUNCH_WIFI_SCAN $02"}]}