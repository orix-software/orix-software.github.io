{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"ch376/","text":"ch376","title":"ch376"},{"location":"ch376/#ch376","text":"","title":"ch376"},{"location":"ch376/vars8/","text":"CH376 extra vars Vars 8 #define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous-classe du p\u00e9riph\u00e9rique de stockage USB SubClass-Code, le bit 6 est 0 pour indiquer que la sous-classe est 6 et le bit 6 est 1 pour indiquer que la sous-classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l'\u00e9tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l'\u00e9tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB, si le bit 5 est 1, la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB, si le bit 5 est 1, il y a un p\u00e9riph\u00e9rique USB dans le port USB, et si le bit 5 est 0, il n'y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l'\u00e9tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB. Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu'il a \u00e9t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0, il ne r\u00e9essayera pas lorsque NAK est re\u00e7u, le bit 7 est 1 et le bit 6 est 0, et r\u00e9essayera \u00e0 l'infini lors de la r\u00e9ception de NAK (vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l'expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0, l'indicateur du syst\u00e8me de fichiers FAT du disque logique, 00-FAT12, 01-FAT16, 10-FAT32, 11-ill\u00e9gal * / / * Bit 2, indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9t\u00e9 modifi\u00e9es, 0-non modifi\u00e9, 1-modifi\u00e9 * / / * Bit 3, la longueur du fichier doit \u00eatre modifi\u00e9e, le fichier actuel est ajout\u00e9 avec les donn\u00e9es, 0-Aucune modification n'est pas ajout\u00e9e, 1-Ajout\u00e9 et doit \u00eatre modifi\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0, version de la carte SD, 0- prend uniquement en charge la premi\u00e8re version SD, 1- prend en charge la deuxi\u00e8me version SD * / / * Bit 1, reconnaissance automatique, carte 0-SD, carte 1-MMC * / / * Bit 2, identification automatique, carte SD de capacit\u00e9 standard 0, carte SD 1 grande capacit\u00e9 (HC-SD) * / / * Bit 4, d\u00e9lai d'expiration de la commande ACMD41 * / / * Bit 5, d\u00e9lai d'expiration de la commande CMD1 * / / * Bit 6, d\u00e9lai d'expiration de la commande CMD58 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0, doit \u00eatre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4, le num\u00e9ro d'unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB, apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB, la valeur par d\u00e9faut est d'acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0, le num\u00e9ro d'unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB, plus 1 est \u00e9gal au nombre d'unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"CH376 extra vars"},{"location":"ch376/vars8/#ch376-extra-vars","text":"","title":"CH376 extra vars"},{"location":"ch376/vars8/#vars-8","text":"#define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous-classe du p\u00e9riph\u00e9rique de stockage USB SubClass-Code, le bit 6 est 0 pour indiquer que la sous-classe est 6 et le bit 6 est 1 pour indiquer que la sous-classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l'\u00e9tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l'\u00e9tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB, si le bit 5 est 1, la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB, si le bit 5 est 1, il y a un p\u00e9riph\u00e9rique USB dans le port USB, et si le bit 5 est 0, il n'y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l'\u00e9tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB. Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu'il a \u00e9t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0, il ne r\u00e9essayera pas lorsque NAK est re\u00e7u, le bit 7 est 1 et le bit 6 est 0, et r\u00e9essayera \u00e0 l'infini lors de la r\u00e9ception de NAK (vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l'expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0, l'indicateur du syst\u00e8me de fichiers FAT du disque logique, 00-FAT12, 01-FAT16, 10-FAT32, 11-ill\u00e9gal * / / * Bit 2, indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9t\u00e9 modifi\u00e9es, 0-non modifi\u00e9, 1-modifi\u00e9 * / / * Bit 3, la longueur du fichier doit \u00eatre modifi\u00e9e, le fichier actuel est ajout\u00e9 avec les donn\u00e9es, 0-Aucune modification n'est pas ajout\u00e9e, 1-Ajout\u00e9 et doit \u00eatre modifi\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0, version de la carte SD, 0- prend uniquement en charge la premi\u00e8re version SD, 1- prend en charge la deuxi\u00e8me version SD * / / * Bit 1, reconnaissance automatique, carte 0-SD, carte 1-MMC * / / * Bit 2, identification automatique, carte SD de capacit\u00e9 standard 0, carte SD 1 grande capacit\u00e9 (HC-SD) * / / * Bit 4, d\u00e9lai d'expiration de la commande ACMD41 * / / * Bit 5, d\u00e9lai d'expiration de la commande CMD1 * / / * Bit 6, d\u00e9lai d'expiration de la commande CMD58 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0, doit \u00eatre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4, le num\u00e9ro d'unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB, apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB, la valeur par d\u00e9faut est d'acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0, le num\u00e9ro d'unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB, plus 1 est \u00e9gal au nombre d'unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"Vars 8"},{"location":"stratos/","text":"Stratos Specs G\u00e9n\u00e9rales 15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier Fonctionnement atmos compatible La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ? Cas non g\u00e9r\u00e9s WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC Controleur usb, sdcard, clavier, souris Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi) Port ethernet ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ... EEprom kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg Kernel Orix 16bits appels via jsr avec un param\u00e8tre de primitive ?","title":"Stratos"},{"location":"stratos/#stratos","text":"","title":"Stratos"},{"location":"stratos/#specs-generales","text":"15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier","title":"Specs G\u00e9n\u00e9rales"},{"location":"stratos/#fonctionnement-atmos-compatible","text":"La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ?","title":"Fonctionnement atmos compatible"},{"location":"stratos/#cas-non-geres","text":"WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC","title":"Cas non g\u00e9r\u00e9s"},{"location":"stratos/#controleur-usb-sdcard-clavier-souris","text":"Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi)","title":"Controleur usb, sdcard, clavier, souris"},{"location":"stratos/#port-ethernet","text":"ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ...","title":"Port ethernet"},{"location":"stratos/#eeprom","text":"kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg","title":"EEprom"},{"location":"stratos/#kernel-orix-16bits","text":"appels via jsr avec un param\u00e8tre de primitive ?","title":"Kernel Orix 16bits"},{"location":"twilighteboard/","text":"Twilighte board FDC, RTC WIFI controller firmware version 1 $342 : twilighte board register b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $343 : Banking register Working board version with this firmware: v0.6 v0.65 firmware version 2 Reserved for twilighte board v0.6 & v0.65 upgrades firmware version 3 $342 b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ... $343 Banking register Notes Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version Twilighte board version 0.6 dirty hack for ca3083 replacement Twilighte board version 0.65 ca3083 removed and are replaced with BC547 Twilighte board version 0.7 Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board"},{"location":"twilighteboard/#twilighte-board","text":"FDC, RTC WIFI controller","title":"Twilighte board"},{"location":"twilighteboard/#firmware-version-1","text":"","title":"firmware version 1"},{"location":"twilighteboard/#342-twilighte-board-register","text":"b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"twilighteboard/#343-banking-register","text":"Working board version with this firmware: v0.6 v0.65","title":"$343 : Banking register"},{"location":"twilighteboard/#firmware-version-2","text":"Reserved for twilighte board v0.6 & v0.65 upgrades","title":"firmware version 2"},{"location":"twilighteboard/#firmware-version-3","text":"","title":"firmware version 3"},{"location":"twilighteboard/#342","text":"b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ...","title":"$342"},{"location":"twilighteboard/#343","text":"Banking register","title":"$343"},{"location":"twilighteboard/#notes","text":"Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version","title":"Notes"},{"location":"twilighteboard/#twilighte-board-version-06","text":"dirty hack for ca3083 replacement","title":"Twilighte board version 0.6"},{"location":"twilighteboard/#twilighte-board-version-065","text":"ca3083 removed and are replaced with BC547","title":"Twilighte board version 0.65"},{"location":"twilighteboard/#twilighte-board-version-07","text":"Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board version 0.7"},{"location":"twilighteboard/fdcWifiEsp/","text":"fdcsd I/O : * $315 : command port * $316 : data port ESP32_CHECK_EXIST ESP32_CHECK_EXIST = $06 Return data inverted bit ESP32_GET_IC_VER ESP32_GET_IC_VER = $01 Return version ESP32_SET_MODE CH376_SET_MODE = $15 Set mode ESP32_SET_MODE_CODE_FDC ESP32_LAUNCH_WIFI_SCAN $02 interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#fdcsd","text":"I/O : * $315 : command port * $316 : data port","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#esp32_check_exist","text":"ESP32_CHECK_EXIST = $06 Return data inverted bit","title":"ESP32_CHECK_EXIST"},{"location":"twilighteboard/fdcWifiEsp/#esp32_get_ic_ver","text":"ESP32_GET_IC_VER = $01 Return version","title":"ESP32_GET_IC_VER"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode","text":"CH376_SET_MODE = $15 Set mode","title":"ESP32_SET_MODE"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode_code_fdc","text":"","title":"ESP32_SET_MODE_CODE_FDC"},{"location":"twilighteboard/fdcWifiEsp/#esp32_launch_wifi_scan-02","text":"interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"ESP32_LAUNCH_WIFI_SCAN $02"}]}