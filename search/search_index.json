{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Definitions Twilighte board The Twilighte board is an extra hardware connected on the the oric (Atmos or Oric-1), it improves default Oric with hardware feature as eeprom (in system update), RAM, joysticks, usb controler. It handles 32 Banks of 16KB of eeprom and 32 Banks of 16KB for RAM. The architecture of hardware registers, joystick management has compatibility with Telestrat in order to have Oric working on Telestrat or Atmos. Feature Availability Sdcard Usbdrive storage Long filename Every usb device control 2 Joysticks Joysticks works at independently 512KB RAM memory 512KB eeprom memory Eeprom in system update Orix Orix is the default (D)OS of the board when it plugged into the oric. Orix is a linux/unix style OS. It's the main OS which can help to start every others systems as oric-1 ROM, atmos ROM etc Orix must have at least 2 banks to boot : Kernel and shell. Kernel is a bank inserted in the 7th slot and it's the first start to boot. Shell is the 5th bank and contains sh binary. When system starts, kernel forks \"sh\" commands at the end of the kernel initialisation. Shell is available and can starts any commands. There are 2 kind of rom : Standalone ROM : it does not need to call kernel primitive, and manage all the main memory (for example : atmos ROM) Orix Roms : in that case, rom does not manage the main memory, and calls kernel to do tasks (for example : Shell roms). In Orix roms, the rom declares commands to an offset in the bank and can be accessed from command line. If any command are typed from prompt, kernel will launch \"XEXEC\" primitive to find in any rom where the command is. Feature Availability Multitasking Long filename management","title":"Home"},{"location":"#definitions","text":"","title":"Definitions"},{"location":"#twilighte-board","text":"The Twilighte board is an extra hardware connected on the the oric (Atmos or Oric-1), it improves default Oric with hardware feature as eeprom (in system update), RAM, joysticks, usb controler. It handles 32 Banks of 16KB of eeprom and 32 Banks of 16KB for RAM. The architecture of hardware registers, joystick management has compatibility with Telestrat in order to have Oric working on Telestrat or Atmos. Feature Availability Sdcard Usbdrive storage Long filename Every usb device control 2 Joysticks Joysticks works at independently 512KB RAM memory 512KB eeprom memory Eeprom in system update","title":"Twilighte board"},{"location":"#orix","text":"Orix is the default (D)OS of the board when it plugged into the oric. Orix is a linux/unix style OS. It's the main OS which can help to start every others systems as oric-1 ROM, atmos ROM etc Orix must have at least 2 banks to boot : Kernel and shell. Kernel is a bank inserted in the 7th slot and it's the first start to boot. Shell is the 5th bank and contains sh binary. When system starts, kernel forks \"sh\" commands at the end of the kernel initialisation. Shell is available and can starts any commands. There are 2 kind of rom : Standalone ROM : it does not need to call kernel primitive, and manage all the main memory (for example : atmos ROM) Orix Roms : in that case, rom does not manage the main memory, and calls kernel to do tasks (for example : Shell roms). In Orix roms, the rom declares commands to an offset in the bank and can be accessed from command line. If any command are typed from prompt, kernel will launch \"XEXEC\" primitive to find in any rom where the command is. Feature Availability Multitasking Long filename management","title":"Orix"},{"location":"menu/","text":"Getting started Users manuals User manuals developpers manual Developpers manuals","title":"Getting started"},{"location":"menu/#getting-started","text":"","title":"Getting started"},{"location":"menu/#users-manuals","text":"User manuals","title":"Users manuals"},{"location":"menu/#developpers-manual","text":"Developpers manuals","title":"developpers manual"},{"location":"network/","text":"Carte r\u00e9seau ethernet pour Oric vraie carte r\u00e9seau ethernet avec gestion de la stack tcp/ip hardware vitesse 40KB/sec du r\u00e9seau \u00e0 la ram, et 23KB du r\u00e9seau \u00e0 la sdcard En cours de dev, mais voici les choses en cours et en partie fonctionnel pour certains: Gestion du dhcp check du cable ifconfig resvctl pour voir le dns server ou le setter netcnf pour une vue de tous les param\u00e8tres curl dig serveur telnetd netstat nc : permet l'envoi de log sur du loghost ip mini browser ping Api r\u00e9seau possible \u00e0 l'avenir pour ses propres programmes.","title":"Carte r\u00e9seau ethernet pour Oric"},{"location":"network/#carte-reseau-ethernet-pour-oric","text":"vraie carte r\u00e9seau ethernet avec gestion de la stack tcp/ip hardware vitesse 40KB/sec du r\u00e9seau \u00e0 la ram, et 23KB du r\u00e9seau \u00e0 la sdcard En cours de dev, mais voici les choses en cours et en partie fonctionnel pour certains: Gestion du dhcp check du cable ifconfig resvctl pour voir le dns server ou le setter netcnf pour une vue de tous les param\u00e8tres curl dig serveur telnetd netstat nc : permet l'envoi de log sur du loghost ip mini browser ping Api r\u00e9seau possible \u00e0 l'avenir pour ses propres programmes.","title":"Carte r\u00e9seau ethernet pour Oric"},{"location":"binaries/generateBinary/","text":"Build a binary from cc65 or assembly located on sdcard cc65 generates a non relocation format for telestrat target. We decided to stop this format in the kernel v2022.4 because it was too complex to manage it in a kernel which use dynamic memory allocation. In order to generate a launchable binary, relocbin must be used : https://github.com/assinie/orix-sdk/blob/master/bin/relocbin.py3 Step one : build your binary from cc65 with the start address $80 cl65 -ttelestrat mysrc.c -o mysrc_800 --start-addr \\$ 800 Step Two : build your binary from cc65 with the start address $900 /# cl65 -ttelestrat mysrc.c -o mysrc_900 --start-addr \\$ 900 Step three (last one) : generate the relocation format: /#python relocbin.py3 -2 -o mybin mysrc_800 mysrc_900 Place mybin in /bin of the sdcard/usb key of the twilighte board, and launch : /#mybin","title":"Generate a binary for sdcard/usb key"},{"location":"binaries/generateBinary/#build-a-binary-from-cc65-or-assembly-located-on-sdcard","text":"cc65 generates a non relocation format for telestrat target. We decided to stop this format in the kernel v2022.4 because it was too complex to manage it in a kernel which use dynamic memory allocation. In order to generate a launchable binary, relocbin must be used : https://github.com/assinie/orix-sdk/blob/master/bin/relocbin.py3","title":"Build a binary from cc65 or assembly located on sdcard"},{"location":"binaries/generateBinary/#step-one-build-your-binary-from-cc65-with-the-start-address-80","text":"cl65 -ttelestrat mysrc.c -o mysrc_800 --start-addr \\$ 800","title":"Step one : build your binary from cc65 with the start address $80"},{"location":"binaries/generateBinary/#step-two-build-your-binary-from-cc65-with-the-start-address-900","text":"/# cl65 -ttelestrat mysrc.c -o mysrc_900 --start-addr \\$ 900","title":"Step Two : build your binary from cc65 with the start address $900"},{"location":"binaries/generateBinary/#step-three-last-one-generate-the-relocation-format","text":"/#python relocbin.py3 -2 -o mybin mysrc_800 mysrc_900 Place mybin in /bin of the sdcard/usb key of the twilighte board, and launch : /#mybin","title":"Step three (last one) : generate the relocation format:"},{"location":"commands/all/","text":"asm2k2 Last version : 2021.1 bank Last version : 2023.1 basic10 Last version : 2023.1 basic11 Last version : 2023.1 barboric Last version : 2022.1 blakes7 Last version : 2022.4 bootfd Last version : 2021.1 born1983 Last version : 2022.1 cat Last version : 2023.1 cd Last version : 2023.1 cksum Last version : 2022.2 clear Last version : 2023.1 cp Last version : 2023.1 df Last version : 2023.1 otimer Last version : 2023.1 dsk-util Last version : 2022.2 echo Last version : 2023.1 env Last version : 2023.1 forth Last version : 2020.1 ftdos Last version : 2022.3 grep Last version : 2022.2 help Last version : 2023.1 hexdump Last version : 2023.1 ioports Last version : 2023.1 list Last version : 2022.2 ls Last version : 2023.1 lscpu Last version : 2023.1 lsmem Last version : 2023.1 loader Last version : 2022.3 man Last version : 2023.1 mkdir Last version : 2023.1 mount Last version : 2023.1 orixcfg Last version : 2023.1 pwd Last version : 2023.1 ps Last version : 2023.1 quintes Last version : 2022.1 raw2dsk Last version : 2023.1 readdsk Last version : 2023.1 reboot Last version : 2023.1 rm Last version : 2023.1 setfont Last version : 2023.1 loader Last version : 2022.3 twilconf Last version : 2022.3 strerr Last version : 2022.4 sh Last version : 2023.1 submit Last version : 2022.2 touch Last version : 2023.1 twil Last version : 2023.1 twiload Last version : 2022.3 uname Last version : 2023.1 untar Last version : 2022.2 vidplay Last version : 2022.3 viewscr Last version : 2022.2 viewhrs Last version : 2023.1 zerofx Last version : 2022.2","title":"All commands"},{"location":"commands/asm2k2/","text":"asm2k2 launch asm2k2 demo /#asm2k2","title":"asm2k2"},{"location":"commands/asm2k2/#asm2k2","text":"launch asm2k2 demo /#asm2k2","title":"asm2k2"},{"location":"commands/bank/","text":"bank Introduction Bank command is command line tool to see which bank are loaded into EEPROM bank and RAM bank. Each bank has a \"signature\". Bank allows to see theses banks. Bank can also starts a ROM with his id. In that case, you don\u2019t need to have a rom \"orix friendly\" and you can start it from command line. In the current bank version, there is restriction to launch a command. SYNOPSYS List all bank (when ROM signature is valid) /#bank Bank 1 to 32 is eeprom bank and bank 33 to 64 are ram bank Displays all signature even when ROM is not valid /#bank List all commands from a bank /#help -b5 Start a specific bank /#bank 1 If you need to load a rom into a bank, you need to have a look to orixcfg binar DESCRIPTION This command displays bank when the command is called without parameter. WIth a parameter, you can switch to a the id of the bank passed to the argument : bank : displays all the bank (if a signature is found) bank 4 : switch to bank 4 bank -a : displauys all bank (empty bank too) SOURCE https://github.com/orix-software/shell/blob/master/src/commands/bank.asm","title":"bank"},{"location":"commands/bank/#bank","text":"","title":"bank"},{"location":"commands/bank/#introduction","text":"Bank command is command line tool to see which bank are loaded into EEPROM bank and RAM bank. Each bank has a \"signature\". Bank allows to see theses banks. Bank can also starts a ROM with his id. In that case, you don\u2019t need to have a rom \"orix friendly\" and you can start it from command line. In the current bank version, there is restriction to launch a command.","title":"Introduction"},{"location":"commands/bank/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/bank/#list-all-bank-when-rom-signature-is-valid","text":"/#bank Bank 1 to 32 is eeprom bank and bank 33 to 64 are ram bank","title":"List all bank (when ROM signature is valid)"},{"location":"commands/bank/#displays-all-signature-even-when-rom-is-not-valid","text":"/#bank","title":"Displays all signature even when ROM is not valid"},{"location":"commands/bank/#list-all-commands-from-a-bank","text":"/#help -b5","title":"List all commands from a bank"},{"location":"commands/bank/#start-a-specific-bank","text":"/#bank 1 If you need to load a rom into a bank, you need to have a look to orixcfg binar","title":"Start a specific bank"},{"location":"commands/bank/#description","text":"This command displays bank when the command is called without parameter. WIth a parameter, you can switch to a the id of the bank passed to the argument : bank : displays all the bank (if a signature is found) bank 4 : switch to bank 4 bank -a : displauys all bank (empty bank too)","title":"DESCRIPTION"},{"location":"commands/bank/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/bank.asm","title":"SOURCE"},{"location":"commands/barboric/","text":"Barboric/Barbitoric demo Launch barbitoric demo from orix (sdcard/usbdrive) /# barboric","title":"barboric"},{"location":"commands/barboric/#barboricbarbitoric-demo","text":"Launch barbitoric demo from orix (sdcard/usbdrive) /# barboric","title":"Barboric/Barbitoric demo"},{"location":"commands/basic10/","text":"basic10 Introduction Start Oric-1 rom SYNOPSYS basic10 basic10 -g basic10 -l basic10 \"MYTAPE DESCRIPTION This command starts the Oric-1 rom. This rom did not test RAM and cload/csave are done on sdcard. It means that it calls file from sdcard. Cload works with .tap file. Multitap files works too. Get a tape file, and place it in the root folder of the sdcard. When there is no parameter, basic10 has /home/basic10 default folder Starts basic10 : /#basic10 or /#basic10 \"DEFENDER CLOAD\"ZORGONS => it will load zorgons.tap Working software all games except the Hobbit (another ROM is available) SOURCE https://github.com/orix-software/shell/blob/master/src/commands/basic10.asm","title":"basic10"},{"location":"commands/basic10/#basic10","text":"","title":"basic10"},{"location":"commands/basic10/#introduction","text":"Start Oric-1 rom","title":"Introduction"},{"location":"commands/basic10/#synopsys","text":"basic10 basic10 -g basic10 -l basic10 \"MYTAPE","title":"SYNOPSYS"},{"location":"commands/basic10/#description","text":"This command starts the Oric-1 rom. This rom did not test RAM and cload/csave are done on sdcard. It means that it calls file from sdcard. Cload works with .tap file. Multitap files works too. Get a tape file, and place it in the root folder of the sdcard. When there is no parameter, basic10 has /home/basic10 default folder Starts basic10 : /#basic10 or /#basic10 \"DEFENDER CLOAD\"ZORGONS => it will load zorgons.tap","title":"DESCRIPTION"},{"location":"commands/basic10/#working-software","text":"all games except the Hobbit (another ROM is available)","title":"Working software"},{"location":"commands/basic10/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/basic10.asm","title":"SOURCE"},{"location":"commands/basic11/","text":"basic11 Introduction Start Atmos rom. You can type basic11 or press FUNCT+B to start. Load a personal .tap file When you starts basic11 commands, the default path is \u00ab /home/basic11/ \u00bb. Each action on the basic11 mode will be done in this folder (cload/csave). If you cload a tape file, it must be in \u00ab /home/basic11 \u00bb folder. You have downloaded a .tap file, and want to use it. Then, you can create a folder /home/basic11/ Under Orix /#mkdir home /#cd home /home#mkdir basic11 /home#cd basic11 Put you file in this folder from your PC, and start basic11 (you don\u2019t need to be in the \u00ab/home/basic11 \u00bb folder to start basic11 with no parameter. By default, basic11 starts in \u00ab /home/basic11/ \u00bb Oric.org tape file When you downloaded sdcard.tgz and unzip it into sdcard or usbkey device, there is many tape file included in this archive. You don\u2019t need to move these type file, if you know the key, you can starts it from commands line. In this case, it will load the correct basic1.1 rom to start the tape file (see below), and the correct joystick configuration if it\u2019s correct. Oric.org tape file update Each week a new software.tgz is generated. You can download it from \u00ab repo \u00bb and unzip it on the device. It will generate last tape file and last joysticks configuration. Search a tape file from command line Basic11 has also many.tap files inserted in sdcard.tgz 8 Try to find the software with option -l /# basic11 -l If you find your software, you can do perform ctrl+c. You can type space to do a pause. On that case, you can launch the tape file like : /# basic11 \u00abKEYDISPLAYED When KEYDISPLAYED is the key displayed in key column. Please note that the key must be in UPPERCASE Load a tap file from command line Note that MYFILE must be in UPPERCASE /# basic11 \u00abMYFILE If MYFILE is in the oric.org database, it will launch the software with the filename MYFILE. If basic11 command does not find MYFILE in the oric.org database, it will try to load it from /home/basic11/ folder. Save your program If you start \u00ab basic11 \u00bb with no options, basic rom will starts and each csave (or cload) actions will store files in \u00ab /home/basic11 \u00bb folder Start basic11 menu If you type \u00ab basic11 -g \u00bb on command line or FUNCT+G, you will have a menu with all software which have a download link on oric.org (only atmos version and when a tape file is available). /#basic11 -g You can use left and right letters to change to a new letter. If the letter is empty, it means that there is no available tap file for this letter. You can use up and down link to navigate into software. If you press enter, the software will starts. Note that not all games are working yet. Some times, chars are corrupted. If the joysticks does not works, there is two case : \u2022 the game does not call rom routine to manage keyboard \u2022 keyboard mapping is not done yet You can use arrows to navigate into the menu : \u2022 up and down to select the software \u2022 right and left to switch to the menu letters Some letters are empty. It means that there is no software with tape file available on oric.org for this letter Quit basic11 If you want to quit basic11 from interpreter command line, you can type \u00ab QUIT \u00bb. This will force to reboot to Orix (you can also use reset button) How the .tap file starts If you only type \u00ab basic11 \u00bb, this will start bank 6 (normal basic rom). The default folder in that case is \u00ab/home/basic11 \u00bb If you type \u00ab basic11 \u00bb with a tape file as an argument, there is 2 cases 1. The tape file (key) is already known in oric.org website, then basic11 try to find it in its databank file (/var/cache/basic11/ folder). If the key is found, it will start the tape file located in \u00ab/usr/share/basic11/... \u00bb 2. If the key is unknown, it will try to find it in \u00ab/home/basic11 \u00bb If the tap file is in the oric.org db file, basic11 will load the software configuration from the db software file (as joystick configuration, and the id of the rom). Basic11 load the right rom into ram bank, override the default basic11 path to the tape file folder (\u00ab usr/share/basic11/[firstletter software]. It means that if you load this kind of software and you can quit the software, each file action in basic11 rom, will be performed in \u00ab usr/share/basic11/[firstletter software]. \u00bb Not working tapes (for instance) \u2022 All Oric-1 games can be started with FUNCT+L in ROM menu : start oric-1 (depending of your device), and put .tap files in /home/basic10 \u2022 Software which does not work (25), but the number can be reduced in future release. cobra Cobra pinball Damsel in distress Rush hour 4K Le diamant de l\u2019ile maudite Durendal HU*BERT Hunchback Schtroumpfs Stanley (ROM 0,1 tested) Them Titan Visif Xenon III Dig Dog Elektro Storm Kilburn Encounter Le tresor du pirate L\u2019aigle d\u2019or (ROM 0,1 tested) Compatible (micropuce) Volcanic demo Clavidact DAO Cobra Soft CW-Morse The Hellion MARC Caspak Kryllis : when we lost one life, the game does not restar Tape with altered charset Fire flash Scuba Dive 3D fongus (i,f letters) Joysticks issues We did keyboard/joystick mapping for a lot of games, but we did not set the keyboard mapping for all software. If you want to help us, contact us. Some game does not work because they handle their own keyboard routine. It could be handle with hardware tricks but, it\u2019s not done. Some others games uses special keys (SHIFT, CTRL) for direction or the first button. Theses cases are not handle yet : but it could in the future. SYNOPSYS basic11 basic11 -g basic11 -l basic11 \"MYTAPE DESCRIPTION This command starts the atmos rom. This rom did not test RAM and cload/csave are done on sdcard. It means that it calls file from sdcard. Cload works with .tap file. Multitap files works too. Get a tape file, and place it in the root folder of the sdcard. Starts basic11 : /#basic11 or /#basic11 \"DEFENDER\" CLOAD\"ZORGONS => it will load zorgons.tap Working software Some games are not working because the rom in order to have the software working is release yet SOURCE https://github.com/orix-software/shell/blob/master/src/commands/basic11.asm","title":"basic11"},{"location":"commands/basic11/#basic11","text":"","title":"basic11"},{"location":"commands/basic11/#introduction","text":"Start Atmos rom. You can type basic11 or press FUNCT+B to start. Load a personal .tap file When you starts basic11 commands, the default path is \u00ab /home/basic11/ \u00bb. Each action on the basic11 mode will be done in this folder (cload/csave). If you cload a tape file, it must be in \u00ab /home/basic11 \u00bb folder. You have downloaded a .tap file, and want to use it. Then, you can create a folder /home/basic11/ Under Orix /#mkdir home /#cd home /home#mkdir basic11 /home#cd basic11 Put you file in this folder from your PC, and start basic11 (you don\u2019t need to be in the \u00ab/home/basic11 \u00bb folder to start basic11 with no parameter. By default, basic11 starts in \u00ab /home/basic11/ \u00bb Oric.org tape file When you downloaded sdcard.tgz and unzip it into sdcard or usbkey device, there is many tape file included in this archive. You don\u2019t need to move these type file, if you know the key, you can starts it from commands line. In this case, it will load the correct basic1.1 rom to start the tape file (see below), and the correct joystick configuration if it\u2019s correct. Oric.org tape file update Each week a new software.tgz is generated. You can download it from \u00ab repo \u00bb and unzip it on the device. It will generate last tape file and last joysticks configuration. Search a tape file from command line Basic11 has also many.tap files inserted in sdcard.tgz 8 Try to find the software with option -l /# basic11 -l If you find your software, you can do perform ctrl+c. You can type space to do a pause. On that case, you can launch the tape file like : /# basic11 \u00abKEYDISPLAYED When KEYDISPLAYED is the key displayed in key column. Please note that the key must be in UPPERCASE Load a tap file from command line Note that MYFILE must be in UPPERCASE /# basic11 \u00abMYFILE If MYFILE is in the oric.org database, it will launch the software with the filename MYFILE. If basic11 command does not find MYFILE in the oric.org database, it will try to load it from /home/basic11/ folder. Save your program If you start \u00ab basic11 \u00bb with no options, basic rom will starts and each csave (or cload) actions will store files in \u00ab /home/basic11 \u00bb folder","title":"Introduction"},{"location":"commands/basic11/#start-basic11-menu","text":"If you type \u00ab basic11 -g \u00bb on command line or FUNCT+G, you will have a menu with all software which have a download link on oric.org (only atmos version and when a tape file is available). /#basic11 -g You can use left and right letters to change to a new letter. If the letter is empty, it means that there is no available tap file for this letter. You can use up and down link to navigate into software. If you press enter, the software will starts. Note that not all games are working yet. Some times, chars are corrupted. If the joysticks does not works, there is two case : \u2022 the game does not call rom routine to manage keyboard \u2022 keyboard mapping is not done yet You can use arrows to navigate into the menu : \u2022 up and down to select the software \u2022 right and left to switch to the menu letters Some letters are empty. It means that there is no software with tape file available on oric.org for this letter Quit basic11 If you want to quit basic11 from interpreter command line, you can type \u00ab QUIT \u00bb. This will force to reboot to Orix (you can also use reset button)","title":"Start basic11 menu"},{"location":"commands/basic11/#how-the-tap-file-starts","text":"If you only type \u00ab basic11 \u00bb, this will start bank 6 (normal basic rom). The default folder in that case is \u00ab/home/basic11 \u00bb If you type \u00ab basic11 \u00bb with a tape file as an argument, there is 2 cases 1. The tape file (key) is already known in oric.org website, then basic11 try to find it in its databank file (/var/cache/basic11/ folder). If the key is found, it will start the tape file located in \u00ab/usr/share/basic11/... \u00bb 2. If the key is unknown, it will try to find it in \u00ab/home/basic11 \u00bb If the tap file is in the oric.org db file, basic11 will load the software configuration from the db software file (as joystick configuration, and the id of the rom). Basic11 load the right rom into ram bank, override the default basic11 path to the tape file folder (\u00ab usr/share/basic11/[firstletter software]. It means that if you load this kind of software and you can quit the software, each file action in basic11 rom, will be performed in \u00ab usr/share/basic11/[firstletter software]. \u00bb Not working tapes (for instance) \u2022 All Oric-1 games can be started with FUNCT+L in ROM menu : start oric-1 (depending of your device), and put .tap files in /home/basic10 \u2022 Software which does not work (25), but the number can be reduced in future release. cobra Cobra pinball Damsel in distress Rush hour 4K Le diamant de l\u2019ile maudite Durendal HU*BERT Hunchback Schtroumpfs Stanley (ROM 0,1 tested) Them Titan Visif Xenon III Dig Dog Elektro Storm Kilburn Encounter Le tresor du pirate L\u2019aigle d\u2019or (ROM 0,1 tested) Compatible (micropuce) Volcanic demo Clavidact DAO Cobra Soft CW-Morse The Hellion MARC Caspak Kryllis : when we lost one life, the game does not restar","title":"How the .tap file starts"},{"location":"commands/basic11/#tape-with-altered-charset","text":"Fire flash Scuba Dive 3D fongus (i,f letters) Joysticks issues We did keyboard/joystick mapping for a lot of games, but we did not set the keyboard mapping for all software. If you want to help us, contact us. Some game does not work because they handle their own keyboard routine. It could be handle with hardware tricks but, it\u2019s not done. Some others games uses special keys (SHIFT, CTRL) for direction or the first button. Theses cases are not handle yet : but it could in the future.","title":"Tape with altered charset"},{"location":"commands/basic11/#synopsys","text":"basic11 basic11 -g basic11 -l basic11 \"MYTAPE","title":"SYNOPSYS"},{"location":"commands/basic11/#description","text":"This command starts the atmos rom. This rom did not test RAM and cload/csave are done on sdcard. It means that it calls file from sdcard. Cload works with .tap file. Multitap files works too. Get a tape file, and place it in the root folder of the sdcard. Starts basic11 : /#basic11 or /#basic11 \"DEFENDER\" CLOAD\"ZORGONS => it will load zorgons.tap","title":"DESCRIPTION"},{"location":"commands/basic11/#working-software","text":"Some games are not working because the rom in order to have the software working is release yet","title":"Working software"},{"location":"commands/basic11/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/basic11.asm","title":"SOURCE"},{"location":"commands/blakes7/","text":"Blakes7 Start Blakes7 /#blakes7 If you want to remove your saved game : /#cd /usr/share/blakes7 /usr/share/blakes7# rm 136.o Check the version /#blakes7 -v","title":"blakes7"},{"location":"commands/blakes7/#blakes7","text":"Start Blakes7 /#blakes7 If you want to remove your saved game : /#cd /usr/share/blakes7 /usr/share/blakes7# rm 136.o","title":"Blakes7"},{"location":"commands/blakes7/#check-the-version","text":"/#blakes7 -v","title":"Check the version"},{"location":"commands/bootfd/","text":"Command: bootfd Starts microdisc bootsector bootfd is a tool to boot the boot sector when a drive is connected. Insert a disk and type : /#bootfd The binary is located in \"/bin\" folder. It will load microdisc rom and will start it. If it displays \"microdis.rom not found\", then place \"microdis.rom\" file in the right folder. If you have firmware 1, you will be able to load \u00ab blake's 7 \u00bb. If you have firmware 2, all sedoric .dsk should start. For instance, only Space99 does not work, it stops after intro. SYNOPSYS bootfd EXAMPLES bootfd Boots only microdisc boot sector with the help of microdisc.rom. In this version, we don't verify if a dsk is inserted or not. If there is no disk, the oric will crash SOURCE Src code : https://github.com/orix-software/bootfd.git (Assembly and C)","title":"bootfd"},{"location":"commands/bootfd/#command-bootfd","text":"","title":"Command: bootfd"},{"location":"commands/bootfd/#starts-microdisc-bootsector","text":"bootfd is a tool to boot the boot sector when a drive is connected. Insert a disk and type : /#bootfd The binary is located in \"/bin\" folder. It will load microdisc rom and will start it. If it displays \"microdis.rom not found\", then place \"microdis.rom\" file in the right folder. If you have firmware 1, you will be able to load \u00ab blake's 7 \u00bb. If you have firmware 2, all sedoric .dsk should start. For instance, only Space99 does not work, it stops after intro.","title":"Starts microdisc bootsector"},{"location":"commands/bootfd/#synopsys","text":"bootfd","title":"SYNOPSYS"},{"location":"commands/bootfd/#examples","text":"bootfd Boots only microdisc boot sector with the help of microdisc.rom. In this version, we don't verify if a dsk is inserted or not. If there is no disk, the oric will crash","title":"EXAMPLES"},{"location":"commands/bootfd/#source","text":"Src code : https://github.com/orix-software/bootfd.git (Assembly and C)","title":"SOURCE"},{"location":"commands/born1983/","text":"Born1983 Launch born 1983 demo /#born1983","title":"born1983"},{"location":"commands/born1983/#born1983","text":"Launch born 1983 demo /#born1983","title":"Born1983"},{"location":"commands/cat/","text":"cat Introduction Display a file to the screen SYNOPSYS cat FILENAME NOTES Displays content of the FILENAME SOURCE https://github.com/orix-software/shell/blob/master/src/commands/cat.asm","title":"cat"},{"location":"commands/cat/#cat","text":"","title":"cat"},{"location":"commands/cat/#introduction","text":"Display a file to the screen","title":"Introduction"},{"location":"commands/cat/#synopsys","text":"cat FILENAME","title":"SYNOPSYS"},{"location":"commands/cat/#notes","text":"Displays content of the FILENAME","title":"NOTES"},{"location":"commands/cat/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/cat.asm","title":"SOURCE"},{"location":"commands/cd/","text":"cd Introduction Change directory SYNOPSYS cd DIRECTORY EXAMPLES cd /usr/bin cd .. cd / SOURCE https://github.com/orix-software/shell/blob/master/src/commands/cd.asm","title":"cd"},{"location":"commands/cd/#cd","text":"","title":"cd"},{"location":"commands/cd/#introduction","text":"Change directory","title":"Introduction"},{"location":"commands/cd/#synopsys","text":"cd DIRECTORY","title":"SYNOPSYS"},{"location":"commands/cd/#examples","text":"cd /usr/bin cd .. cd /","title":"EXAMPLES"},{"location":"commands/cd/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/cd.asm","title":"SOURCE"},{"location":"commands/cksum/","text":"Command: cksum checksum utility SYNOPSYS cksum file [...] cksum @batchfile cksum -h EXAMPLES cksum /bin/cksum DESCRIPTION checksum and count the bytes in a file OPTIONS -h show this help message and exit SOURCE https://github.com/orix-software/cksum","title":"cksum"},{"location":"commands/cksum/#command-cksum","text":"","title":"Command: cksum"},{"location":"commands/cksum/#checksum-utility","text":"","title":"checksum utility"},{"location":"commands/cksum/#synopsys","text":"cksum file [...] cksum @batchfile cksum -h","title":"SYNOPSYS"},{"location":"commands/cksum/#examples","text":"cksum /bin/cksum","title":"EXAMPLES"},{"location":"commands/cksum/#description","text":"checksum and count the bytes in a file","title":"DESCRIPTION"},{"location":"commands/cksum/#options","text":"-h show this help message and exit","title":"OPTIONS"},{"location":"commands/cksum/#source","text":"https://github.com/orix-software/cksum","title":"SOURCE"},{"location":"commands/clear/","text":"clear Introduction Clear the screen SYNOPSYS clear SOURCE https://github.com/orix-software/shell/blob/master/src/commands/clear.asm","title":"clear"},{"location":"commands/clear/#clear","text":"","title":"clear"},{"location":"commands/clear/#introduction","text":"Clear the screen","title":"Introduction"},{"location":"commands/clear/#synopsys","text":"clear","title":"SYNOPSYS"},{"location":"commands/clear/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/clear.asm","title":"SOURCE"},{"location":"commands/commands_for_nav/","text":"asm2k2: commands/asm2k2.md bank: commands/bank.md basic10: commands/basic10.md basic11: commands/basic11.md barboric: commands/barboric.md blakes7: commands/blakes7.md bootfd: commands/bootfd.md born1983: commands/born1983.md cat: commands/cat.md cd: commands/cd.md cksum: commands/cksum.md clear: commands/clear.md cp: commands/cp.md df: commands/df.md otimer: commands/otimer.md dsk-util: commands/dsk-util.md echo: commands/echo.md env: commands/env.md forth: commands/forth.md ftdos: commands/ftdos.md grep: commands/grep.md help: commands/help.md hexdump: commands/hexdump.md ioports: commands/ioports.md list: commands/list.md ls: commands/ls.md lscpu: commands/lscpu.md lsmem: commands/lsmem.md loader: commands/loader.md man: commands/man.md mkdir: commands/mkdir.md mount: commands/mount.md orixcfg: commands/orixcfg.md pwd: commands/pwd.md ps: commands/ps.md quintes: commands/quintes.md raw2dsk: commands/raw2dsk.md readdsk: commands/readdsk.md reboot: commands/reboot.md rm: commands/rm.md setfont: commands/setfont.md loader: commands/loader.md twilconf: commands/twilconf.md strerr: commands/strerr.md sh: commands/sh.md submit: commands/submit.md touch: commands/touch.md twil: commands/twil.md twiload: commands/twiload.md uname: commands/uname.md untar: commands/untar.md vidplay: commands/vidplay.md viewscr: commands/viewscr.md viewhrs: commands/viewhrs.md zerofx: commands/zerofx.md","title":"Commands for nav"},{"location":"commands/cp/","text":"cp Introduction Copy a file to another file SYNOPSYS cp from to DESCRIPTION Copy a file to another. Only 40KB can be copied. It's a software limit. cp tries to allocate 40KB, if there is not enough memory it displays Out of memory. EXAMPLES cp from.txt to.txt SOURCE https://github.com/orix-software/shell/blob/master/src/commands/cp.asm","title":"cp"},{"location":"commands/cp/#cp","text":"","title":"cp"},{"location":"commands/cp/#introduction","text":"Copy a file to another file","title":"Introduction"},{"location":"commands/cp/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/cp/#cp-from-to","text":"","title":"cp from to"},{"location":"commands/cp/#description","text":"Copy a file to another. Only 40KB can be copied. It's a software limit. cp tries to allocate 40KB, if there is not enough memory it displays Out of memory.","title":"DESCRIPTION"},{"location":"commands/cp/#examples","text":"cp from.txt to.txt","title":"EXAMPLES"},{"location":"commands/cp/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/cp.asm","title":"SOURCE"},{"location":"commands/df/","text":"df Displays storage device informations","title":"df"},{"location":"commands/df/#df","text":"Displays storage device informations","title":"df"},{"location":"commands/dsk-util/","text":"Command: dsk-util Disk image utility SYNOPSYS dsk-util -f|-s file.dsk dsk-util -h EXAMPLES dsk-util -f ftdos.dsk dsk-util -s sedoric3.dsk DESCRIPTION dsk-util display the directory of a disk image file. OPTIONS -h show this help message and exit -f FTDOS disk image -s Sedoric disk image SOURCE https://github.com/orix-software/dsk-util","title":"dsk-util"},{"location":"commands/dsk-util/#command-dsk-util","text":"","title":"Command: dsk-util"},{"location":"commands/dsk-util/#disk-image-utility","text":"","title":"Disk image utility"},{"location":"commands/dsk-util/#synopsys","text":"dsk-util -f|-s file.dsk dsk-util -h","title":"SYNOPSYS"},{"location":"commands/dsk-util/#examples","text":"dsk-util -f ftdos.dsk dsk-util -s sedoric3.dsk","title":"EXAMPLES"},{"location":"commands/dsk-util/#description","text":"dsk-util display the directory of a disk image file.","title":"DESCRIPTION"},{"location":"commands/dsk-util/#options","text":"-h show this help message and exit -f FTDOS disk image -s Sedoric disk image","title":"OPTIONS"},{"location":"commands/dsk-util/#source","text":"https://github.com/orix-software/dsk-util","title":"SOURCE"},{"location":"commands/echo/","text":"echo Introduction Display a message SYNOPSYS echo hello DESCRIPTION Display a message SOURCE https://github.com/orix-software/shell/blob/master/src/commands/echo.asm","title":"echo"},{"location":"commands/echo/#echo","text":"","title":"echo"},{"location":"commands/echo/#introduction","text":"Display a message","title":"Introduction"},{"location":"commands/echo/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/echo/#echo-hello","text":"","title":"echo hello"},{"location":"commands/echo/#description","text":"Display a message","title":"DESCRIPTION"},{"location":"commands/echo/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/echo.asm","title":"SOURCE"},{"location":"commands/env/","text":"env Introduction Displays env variables SYNOPSYS env DESCRIPTION Displays env variables. It can't be used in command line or shell script for instance SOURCE https://github.com/orix-software/shell/blob/master/src/commands/env.asm","title":"env"},{"location":"commands/env/#env","text":"","title":"env"},{"location":"commands/env/#introduction","text":"Displays env variables","title":"Introduction"},{"location":"commands/env/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/env/#env_1","text":"","title":"env"},{"location":"commands/env/#description","text":"Displays env variables. It can't be used in command line or shell script for instance","title":"DESCRIPTION"},{"location":"commands/env/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/env.asm","title":"SOURCE"},{"location":"commands/forth/","text":"Command: forth Launch forth for Orix SYNOPSYS forth DESCRIPTION Forth is a language based on teleforth (telestrat). You can type VLIST to list all words. If you need to switch to hires, you can type GRAFX and HIRES . If you need to switch to text: GRAFX and TEXT You can use forth language. It works the same ways than Tele forth (it's teleforth but it write file on sdcard/usbdrive). You can download Teleforth langage in order to see how to program in forth. When you type \u00ab forth \u00bb forth starts with the current folder directory. If you were in /, forth will load and save file in this folder. In others cases, you can create a forth folder in home and goes into it in forth for example : mkdir home cd home mkdir forth forth if you type \u00ab cd forth\u00bb in forth environnement, all files actions will be perform in \u00ab / home/ forth \u00bb SOURCE https://github.com/assinie/Tele-Forth","title":"forth"},{"location":"commands/forth/#command-forth","text":"Launch forth for Orix","title":"Command: forth"},{"location":"commands/forth/#synopsys","text":"forth","title":"SYNOPSYS"},{"location":"commands/forth/#description","text":"Forth is a language based on teleforth (telestrat). You can type VLIST to list all words. If you need to switch to hires, you can type GRAFX and HIRES . If you need to switch to text: GRAFX and TEXT You can use forth language. It works the same ways than Tele forth (it's teleforth but it write file on sdcard/usbdrive). You can download Teleforth langage in order to see how to program in forth. When you type \u00ab forth \u00bb forth starts with the current folder directory. If you were in /, forth will load and save file in this folder. In others cases, you can create a forth folder in home and goes into it in forth for example : mkdir home","title":"DESCRIPTION"},{"location":"commands/forth/#cd-home","text":"","title":"cd home"},{"location":"commands/forth/#mkdir-forth","text":"forth if you type \u00ab cd forth\u00bb in forth environnement, all files actions will be perform in \u00ab / home/ forth \u00bb","title":"mkdir forth"},{"location":"commands/forth/#source","text":"https://github.com/assinie/Tele-Forth","title":"SOURCE"},{"location":"commands/ftdos/","text":"Ftdos Introduction ftdos command starts ftdos .dsk file without jasmin floppy disc controler. It's a beta version. Usage To start a .dsk file /#ftdos mydsk To display the ftdos command version : /#ftdos -v ftdos disks must be present in /home/basic11/dsk/ Informations Write on .dsk file is not supported refers to ftdos manual for usages you need to switch off/on the oric when you reset into ftdos mode, because there is a bug when we reset during ftdos mode. Ftdos does not load and reboot into Orix","title":"ftdos"},{"location":"commands/ftdos/#ftdos","text":"","title":"Ftdos"},{"location":"commands/ftdos/#introduction","text":"ftdos command starts ftdos .dsk file without jasmin floppy disc controler. It's a beta version.","title":"Introduction"},{"location":"commands/ftdos/#usage","text":"To start a .dsk file /#ftdos mydsk To display the ftdos command version : /#ftdos -v ftdos disks must be present in /home/basic11/dsk/","title":"Usage"},{"location":"commands/ftdos/#informations","text":"Write on .dsk file is not supported refers to ftdos manual for usages you need to switch off/on the oric when you reset into ftdos mode, because there is a bug when we reset during ftdos mode. Ftdos does not load and reboot into Orix","title":"Informations"},{"location":"commands/grep/","text":"Command: grep grep utility SYNOPSYS grep [-ncisw] string filename grep -h DESCRIPTION grep display all lines of a text file that contain a string. OPTIONS -h^GDisplay command syntax -n^GShow line numbers -c^GCount only the matching lines -i^GIgnore case -w^GString can use wildcards *, ?, ^ and $ -s^GSilent mode EXAMPLES grep error menu.sub grep -n \"level 1\" menu.sub grep -i ERROR menu.sub grep -ni 'level 2' menu.sub grep -w '*lev?? 2*'menu.sub grep -w '^if' menu.sub grep -w 'error$' menu.sub grep -w 'if*level ??' menu.sub SOURCE https://github.com/orix-software/grep","title":"grep"},{"location":"commands/grep/#command-grep","text":"","title":"Command: grep"},{"location":"commands/grep/#grep-utility","text":"","title":"grep utility"},{"location":"commands/grep/#synopsys","text":"grep [-ncisw] string filename grep -h","title":"SYNOPSYS"},{"location":"commands/grep/#description","text":"grep display all lines of a text file that contain a string.","title":"DESCRIPTION"},{"location":"commands/grep/#options","text":"-h^GDisplay command syntax -n^GShow line numbers -c^GCount only the matching lines -i^GIgnore case -w^GString can use wildcards *, ?, ^ and $ -s^GSilent mode","title":"OPTIONS"},{"location":"commands/grep/#examples","text":"grep error menu.sub grep -n \"level 1\" menu.sub grep -i ERROR menu.sub grep -ni 'level 2' menu.sub grep -w '*lev?? 2*'menu.sub grep -w '^if' menu.sub grep -w 'error$' menu.sub grep -w 'if*level ??' menu.sub","title":"EXAMPLES"},{"location":"commands/grep/#source","text":"https://github.com/orix-software/grep","title":"SOURCE"},{"location":"commands/help/","text":"help Introduction Display commands SYNOPSYS help DESCRIPTION No parameter : Displays all internals shell command bX parameter : Displays all internals commands in bank X SOURCE https://github.com/orix-software/shell/blob/master/src/commands/help.asm","title":"help"},{"location":"commands/help/#help","text":"","title":"help"},{"location":"commands/help/#introduction","text":"Display commands","title":"Introduction"},{"location":"commands/help/#synopsys","text":"help","title":"SYNOPSYS"},{"location":"commands/help/#description","text":"No parameter : Displays all internals shell command bX parameter : Displays all internals commands in bank X","title":"DESCRIPTION"},{"location":"commands/help/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/help.asm","title":"SOURCE"},{"location":"commands/hexdump/","text":"Command: hexdump hexdump utility SYNOPSYS hexdump -v hexdump -h hexdump -b bankid [,offset] hexdump file EXAMPLES hexdump /bin/hexdump hexdump -b 7 hexdump -b 33,16128 DESCRIPTION Display file or bank contents in hexadecimal. You can use [SPACE] to pause the display ou [CTRL]+C to abort. SOURCE https://github.com/orix-software/hexdump","title":"hexdump"},{"location":"commands/hexdump/#command-hexdump","text":"","title":"Command: hexdump"},{"location":"commands/hexdump/#hexdump-utility","text":"","title":"hexdump utility"},{"location":"commands/hexdump/#synopsys","text":"hexdump -v hexdump -h hexdump -b bankid [,offset] hexdump file","title":"SYNOPSYS"},{"location":"commands/hexdump/#examples","text":"hexdump /bin/hexdump hexdump -b 7 hexdump -b 33,16128","title":"EXAMPLES"},{"location":"commands/hexdump/#description","text":"Display file or bank contents in hexadecimal. You can use [SPACE] to pause the display ou [CTRL]+C to abort.","title":"DESCRIPTION"},{"location":"commands/hexdump/#source","text":"https://github.com/orix-software/hexdump","title":"SOURCE"},{"location":"commands/ioports/","text":"ioports Introduction Display I/O Ports of the board SYNOPSYS ioports DESCRIPTION Displays I/O ports. SOURCE https://github.com/orix-software/shell/blob/master/src/commands/ioports.asm","title":"ioports"},{"location":"commands/ioports/#ioports","text":"","title":"ioports"},{"location":"commands/ioports/#introduction","text":"Display I/O Ports of the board","title":"Introduction"},{"location":"commands/ioports/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/ioports/#ioports_1","text":"","title":"ioports"},{"location":"commands/ioports/#description","text":"Displays I/O ports.","title":"DESCRIPTION"},{"location":"commands/ioports/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/ioports.asm","title":"SOURCE"},{"location":"commands/list/","text":"Command: list LIST utility SYNOPSYS list [-c] [+offset] file EXAMPLES list /home/basic11/prog.bas list +19 scuba.tap DESCRIPTION Similar to LIST instruction of the BASIC ROM but for files. With +nnn you can go past the tape header of a tape file. You can use [SPACE] to pause the display ou [CTRL]+C to abort. OPTIONS -h show help message and exit -c Color +nnn skip nnn bytes before starting the listing SOURCE https://github.com/orix-software/list","title":"list"},{"location":"commands/list/#command-list","text":"","title":"Command: list"},{"location":"commands/list/#list-utility","text":"","title":"LIST utility"},{"location":"commands/list/#synopsys","text":"list [-c] [+offset] file","title":"SYNOPSYS"},{"location":"commands/list/#examples","text":"list /home/basic11/prog.bas list +19 scuba.tap","title":"EXAMPLES"},{"location":"commands/list/#description","text":"Similar to LIST instruction of the BASIC ROM but for files. With +nnn you can go past the tape header of a tape file. You can use [SPACE] to pause the display ou [CTRL]+C to abort.","title":"DESCRIPTION"},{"location":"commands/list/#options","text":"-h show help message and exit -c Color +nnn skip nnn bytes before starting the listing","title":"OPTIONS"},{"location":"commands/list/#source","text":"https://github.com/orix-software/list","title":"SOURCE"},{"location":"commands/loader/","text":"Loader Uses funct + L to launch the menu or type \"twiload\" if you have Oric-1 keyboard You can select the rom you want to start : For atmos (usbdrive or sdcard), root path of the rom is /home/basic11 For Oric-1 (usbdrive or sdcard), root path of the rom is /home/basic10 For Pravetzt (usbdrive or sdcard), root path of the rom is /home/pravetzt and others Roms Usage up/left arrow : move into list space : displays infos of the sofware if available ESC : quit loader Informations Informations Loader can starts tape file as atmos .tap file by category (demo, games). Demo, games, tools, music categories displays atmos tape file and Oric-1 tapes files. It means that loader is able to start atmos software only and Oric-1 only. In order to avoid 2 softwares for Oric-1 and another one for atmos when it's available for theses 2 machines, the choice is that loader displays atmos tape file, and if the software does not exist on the atmos, Oric-1 version is displayed. Number of software for each category since 15/5/2022 Roms : 60 Demo : 35 Games : 788 Tools : 142 Music : 80","title":"loader"},{"location":"commands/loader/#loader","text":"Uses funct + L to launch the menu or type \"twiload\" if you have Oric-1 keyboard You can select the rom you want to start : For atmos (usbdrive or sdcard), root path of the rom is /home/basic11 For Oric-1 (usbdrive or sdcard), root path of the rom is /home/basic10 For Pravetzt (usbdrive or sdcard), root path of the rom is /home/pravetzt and others Roms","title":"Loader"},{"location":"commands/loader/#usage","text":"up/left arrow : move into list space : displays infos of the sofware if available ESC : quit loader","title":"Usage"},{"location":"commands/loader/#informations","text":"","title":"Informations"},{"location":"commands/loader/#informations_1","text":"Loader can starts tape file as atmos .tap file by category (demo, games). Demo, games, tools, music categories displays atmos tape file and Oric-1 tapes files. It means that loader is able to start atmos software only and Oric-1 only. In order to avoid 2 softwares for Oric-1 and another one for atmos when it's available for theses 2 machines, the choice is that loader displays atmos tape file, and if the software does not exist on the atmos, Oric-1 version is displayed. Number of software for each category since 15/5/2022 Roms : 60 Demo : 35 Games : 788 Tools : 142 Music : 80","title":"Informations"},{"location":"commands/ls/","text":"ls Display catalog List all the file in the current folder. Token are supported (*,?) ex : \u00ab ls ?e.tap \u00bb will list all files with a \u2018e \u2019 in the second letter SYNOPSYS list all the files in the current folder ls List all *.tap files ls *.tap List size and datetime of the file + ls -l DESCRIPTION Directories are in FBLUE G color. It manages '-l' and Pattern works in different ways : ls *.tap SOURCE https://github.com/orix-software/shell/blob/master/src/commands/ls.asm","title":"ls"},{"location":"commands/ls/#ls","text":"","title":"ls"},{"location":"commands/ls/#display-catalog","text":"List all the file in the current folder. Token are supported (*,?) ex : \u00ab ls ?e.tap \u00bb will list all files with a \u2018e \u2019 in the second letter","title":"Display catalog"},{"location":"commands/ls/#synopsys","text":"list all the files in the current folder ls List all *.tap files ls *.tap List size and datetime of the file + ls -l","title":"SYNOPSYS"},{"location":"commands/ls/#description","text":"Directories are in FBLUE G color. It manages '-l' and Pattern works in different ways : ls *.tap","title":"DESCRIPTION"},{"location":"commands/ls/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/ls.asm","title":"SOURCE"},{"location":"commands/lscpu/","text":"lscpu Introduction Displays cpu info. It detects : 6502, 65c02 and 65816 SYNOPSYS lscpu DESCRIPTION Displays cpu info EXAMPLES lscpu SOURCE https://github.com/orix-software/shell/blob/master/src/commands/lscpu.asm","title":"lscpu"},{"location":"commands/lscpu/#lscpu","text":"","title":"lscpu"},{"location":"commands/lscpu/#introduction","text":"Displays cpu info. It detects : 6502, 65c02 and 65816","title":"Introduction"},{"location":"commands/lscpu/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/lscpu/#lscpu_1","text":"","title":"lscpu"},{"location":"commands/lscpu/#description","text":"Displays cpu info","title":"DESCRIPTION"},{"location":"commands/lscpu/#examples","text":"lscpu","title":"EXAMPLES"},{"location":"commands/lscpu/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/lscpu.asm","title":"SOURCE"},{"location":"commands/lsmem/","text":"lsmem Introduction Displays malloc table SYNOPSYS lsmem DESCRIPTION Displays malloc table. Free chunks and busy chuncks are displayed with ranges. EXAMPLES lsmem SOURCE https://github.com/orix-software/shell/blob/master/src/commands/lsmem.asm","title":"lsmem"},{"location":"commands/lsmem/#lsmem","text":"","title":"lsmem"},{"location":"commands/lsmem/#introduction","text":"Displays malloc table","title":"Introduction"},{"location":"commands/lsmem/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/lsmem/#lsmem_1","text":"","title":"lsmem"},{"location":"commands/lsmem/#description","text":"Displays malloc table. Free chunks and busy chuncks are displayed with ranges.","title":"DESCRIPTION"},{"location":"commands/lsmem/#examples","text":"lsmem","title":"EXAMPLES"},{"location":"commands/lsmem/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/lsmem.asm","title":"SOURCE"},{"location":"commands/man/","text":"man Introduction display manual pages SYNOPSYS man lsmem DESCRIPTION Displays manual. All .hlp files are located in /usr/share/man/. It manages multiples text screen (if .hlp is bigger than a screen when space is pressed, it switch to next page). Keys SPACE to switch to next page ESC to exit EXAMPLES man ls SOURCE https://github.com/orix-software/shell/blob/master/src/commands/man.asm","title":"man"},{"location":"commands/man/#man","text":"","title":"man"},{"location":"commands/man/#introduction","text":"display manual pages","title":"Introduction"},{"location":"commands/man/#synopsys","text":"man lsmem","title":"SYNOPSYS"},{"location":"commands/man/#description","text":"Displays manual. All .hlp files are located in /usr/share/man/. It manages multiples text screen (if .hlp is bigger than a screen when space is pressed, it switch to next page).","title":"DESCRIPTION"},{"location":"commands/man/#keys","text":"SPACE to switch to next page ESC to exit","title":"Keys"},{"location":"commands/man/#examples","text":"man ls","title":"EXAMPLES"},{"location":"commands/man/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/man.asm","title":"SOURCE"},{"location":"commands/mkdir/","text":"mkdir Introduction Create a folder SYNOPSYS /#mkdir PATH DESCRIPTION Create a folder. -p (recursive mode) option is not available EXAMPLES mkdir /opt SOURCE https://github.com/orix-software/shell/blob/master/src/commands/mkdir.asm","title":"mkdir"},{"location":"commands/mkdir/#mkdir","text":"","title":"mkdir"},{"location":"commands/mkdir/#introduction","text":"Create a folder","title":"Introduction"},{"location":"commands/mkdir/#synopsys","text":"/#mkdir PATH","title":"SYNOPSYS"},{"location":"commands/mkdir/#description","text":"Create a folder. -p (recursive mode) option is not available","title":"DESCRIPTION"},{"location":"commands/mkdir/#examples","text":"mkdir /opt","title":"EXAMPLES"},{"location":"commands/mkdir/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/mkdir.asm","title":"SOURCE"},{"location":"commands/mount/","text":"mount Introduction Displays mounts SYNOPSYS mount DESCRIPTION Displays mount (usb key or sdcard) SOURCE https://github.com/orix-software/shell/blob/master/src/commands/mount.asm","title":"mount"},{"location":"commands/mount/#mount","text":"","title":"mount"},{"location":"commands/mount/#introduction","text":"Displays mounts","title":"Introduction"},{"location":"commands/mount/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/mount/#mount_1","text":"","title":"mount"},{"location":"commands/mount/#description","text":"Displays mount (usb key or sdcard)","title":"DESCRIPTION"},{"location":"commands/mount/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/mount.asm","title":"SOURCE"},{"location":"commands/orixcfg/","text":"orixcfg Introduction Update kernel, shell : orixcfg When a new released is done, you can update the eeprom with the new kernel and new roms. If you want to know if you need to update the kernel, you can compare your current version, and the last release version. You can go to http://orix.oric.org The sequence of the Orix release is Year.X. There is 4 releases a year, and each one must be done until you reach the final one, in order to avoid some case. If your version is v2020.3 and the last available version is v2021.4. You need to update to v2020.4, then v2021.1, v2021.2, v2021.3, v2021.4, v2022.1, v2022.4 It's maybe possible to jump to version v2022.3, but it's at your own risk because there is a \u00ab chance \u00bb that some kernel calls changed, and orixcfg could do wrong step. When you need to update kernel, you can update it with orixcfg. You just need to define set 4 on the command line. This step is very dangerous if you don't load the right file. There is no verification and any file on the command line will be load in the kernel set. Usually, kernel set file is named kernxxxx.r64. If you did something wrong on this step, you won't be able to start orix again. It means that you will need to remove eeprom from the card and program it with a eeprom programmer This next command will load kernel.r64 to kernel set. Please wait until Orix reboots. If you have a kernel 2020.3 and you need to load a kernel 2021,1, you will need to load previous kernel set before the update of 2021.1. .r64 extension means that it's a 64KB set. It's usually used to define that the file contains 4 roms of 16KB. Please note that we provide 2 kernels version. One named \u00ab kernelsd.r64 \u00bb which means that the default device will be sdcard, and the other one \u00ab kernelus.r64 \u00bb which means that default device will be \u00ab usb \u00bb (usbkey). If you load the wrong kernel at this step, you can use twil command to switch to the right device, and you can start again kernel update with the right file (kernelsd.r64 or kernelus.r64 depending of your configuration). orixcfg -r -s 4 kernelsd.r64 Load a ROM into a ram slot Space between values and switches are not optionnal, orixcfg needs theses spaces /#orixcfg -b XX -l myrom.rom This command will load myrom.rom (in the current path), in RAM bank XX Older usage as : orixcfg -r -s X -b Y myrom.rom is no longer included in orixcfg since orixcfg v2021.3 Load a set of ROM into ROM slot orixcfg -r -s 0 myrom.r64 []{#anchor-72}This command will load myrom.r64 (in the current path), in set 0. For instance, you can not load one bank, you need to load 64KB set. Clear bank ram or initialize it Ram bank are not initialized when the board is tested. If you have garbage on screen when you uses bank (after you used twil -w). You have to clear all ram bank (ram bank are battery saved). If you want to clear bank 4 of the set 0, you can do this command. You need to do this command for each bank of each set. For instance, there is no switch to clear all the ram with one command. /#orixcfg -w -s 0 -b 4 -c Flush all ram bank orixcfg -w -f SYNOPSYS orixcfg Load a .rom into RAM (in the example, set 0, bank 4) orixcfg -w -s 0 -b 4 myrom.rom Clear a ram bank (in the example, set 0, bank 4) orixcfg -w -s 0 -b 4 -c Load an eeprom set (in the example, set 0), only 64KB set orixcfg -r -s 0 myset.r64 Update kernel orixcfg -r -s 4 kernelus.r64 DESCRIPTION Manage twilighte board configuration","title":"orixcfg"},{"location":"commands/orixcfg/#orixcfg","text":"","title":"orixcfg"},{"location":"commands/orixcfg/#introduction","text":"Update kernel, shell : orixcfg When a new released is done, you can update the eeprom with the new kernel and new roms. If you want to know if you need to update the kernel, you can compare your current version, and the last release version. You can go to http://orix.oric.org The sequence of the Orix release is Year.X. There is 4 releases a year, and each one must be done until you reach the final one, in order to avoid some case. If your version is v2020.3 and the last available version is v2021.4. You need to update to v2020.4, then v2021.1, v2021.2, v2021.3, v2021.4, v2022.1, v2022.4 It's maybe possible to jump to version v2022.3, but it's at your own risk because there is a \u00ab chance \u00bb that some kernel calls changed, and orixcfg could do wrong step. When you need to update kernel, you can update it with orixcfg. You just need to define set 4 on the command line. This step is very dangerous if you don't load the right file. There is no verification and any file on the command line will be load in the kernel set. Usually, kernel set file is named kernxxxx.r64. If you did something wrong on this step, you won't be able to start orix again. It means that you will need to remove eeprom from the card and program it with a eeprom programmer This next command will load kernel.r64 to kernel set. Please wait until Orix reboots. If you have a kernel 2020.3 and you need to load a kernel 2021,1, you will need to load previous kernel set before the update of 2021.1. .r64 extension means that it's a 64KB set. It's usually used to define that the file contains 4 roms of 16KB. Please note that we provide 2 kernels version. One named \u00ab kernelsd.r64 \u00bb which means that the default device will be sdcard, and the other one \u00ab kernelus.r64 \u00bb which means that default device will be \u00ab usb \u00bb (usbkey). If you load the wrong kernel at this step, you can use twil command to switch to the right device, and you can start again kernel update with the right file (kernelsd.r64 or kernelus.r64 depending of your configuration). orixcfg -r -s 4 kernelsd.r64","title":"Introduction"},{"location":"commands/orixcfg/#load-a-rom-into-a-ram-slot","text":"Space between values and switches are not optionnal, orixcfg needs theses spaces /#orixcfg -b XX -l myrom.rom This command will load myrom.rom (in the current path), in RAM bank XX Older usage as : orixcfg -r -s X -b Y myrom.rom is no longer included in orixcfg since orixcfg v2021.3","title":"Load a ROM into a ram slot"},{"location":"commands/orixcfg/#load-a-set-of-rom-into-rom-slot","text":"orixcfg -r -s 0 myrom.r64 []{#anchor-72}This command will load myrom.r64 (in the current path), in set 0. For instance, you can not load one bank, you need to load 64KB set.","title":"Load a set of ROM into ROM slot"},{"location":"commands/orixcfg/#clear-bank-ram-or-initialize-it","text":"Ram bank are not initialized when the board is tested. If you have garbage on screen when you uses bank (after you used twil -w). You have to clear all ram bank (ram bank are battery saved). If you want to clear bank 4 of the set 0, you can do this command. You need to do this command for each bank of each set. For instance, there is no switch to clear all the ram with one command. /#orixcfg -w -s 0 -b 4 -c","title":"Clear bank ram or initialize it"},{"location":"commands/orixcfg/#flush-all-ram-bank","text":"orixcfg -w -f","title":"Flush all ram bank"},{"location":"commands/orixcfg/#synopsys","text":"orixcfg Load a .rom into RAM (in the example, set 0, bank 4) orixcfg -w -s 0 -b 4 myrom.rom Clear a ram bank (in the example, set 0, bank 4) orixcfg -w -s 0 -b 4 -c Load an eeprom set (in the example, set 0), only 64KB set orixcfg -r -s 0 myset.r64 Update kernel orixcfg -r -s 4 kernelus.r64","title":"SYNOPSYS"},{"location":"commands/orixcfg/#description","text":"Manage twilighte board configuration","title":"DESCRIPTION"},{"location":"commands/otimer/","text":"otimer Introduction Display timer since the Oric is power on SYNOPSYS otimer NOTES Each time Oric reboots, this timer is reset SOURCE https://github.com/orix-software/shell/blob/master/src/commands/otimer.asm","title":"otimer"},{"location":"commands/otimer/#otimer","text":"","title":"otimer"},{"location":"commands/otimer/#introduction","text":"Display timer since the Oric is power on","title":"Introduction"},{"location":"commands/otimer/#synopsys","text":"otimer","title":"SYNOPSYS"},{"location":"commands/otimer/#notes","text":"Each time Oric reboots, this timer is reset","title":"NOTES"},{"location":"commands/otimer/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/otimer.asm","title":"SOURCE"},{"location":"commands/ps/","text":"ps Introduction Displays process list SYNOPSYS ps DESCRIPTION Displays process list EXAMPLES ps SOURCE https://github.com/orix-software/shell/blob/master/src/commands/ps.asm","title":"ps"},{"location":"commands/ps/#ps","text":"","title":"ps"},{"location":"commands/ps/#introduction","text":"Displays process list","title":"Introduction"},{"location":"commands/ps/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/ps/#ps_1","text":"","title":"ps"},{"location":"commands/ps/#description","text":"Displays process list","title":"DESCRIPTION"},{"location":"commands/ps/#examples","text":"ps","title":"EXAMPLES"},{"location":"commands/ps/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/ps.asm","title":"SOURCE"},{"location":"commands/pwd/","text":"pwd Introduction Display the current path SYNOPSYS pwd SOURCE https://github.com/orix-software/shell/blob/master/src/commands/pwd.asm","title":"pwd"},{"location":"commands/pwd/#pwd","text":"","title":"pwd"},{"location":"commands/pwd/#introduction","text":"Display the current path","title":"Introduction"},{"location":"commands/pwd/#synopsys","text":"pwd","title":"SYNOPSYS"},{"location":"commands/pwd/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/pwd.asm","title":"SOURCE"},{"location":"commands/quintes/","text":"Quintessential demo Start quintessential demo /#quintes","title":"quintes"},{"location":"commands/quintes/#quintessential-demo","text":"Start quintessential demo /#quintes","title":"Quintessential demo"},{"location":"commands/raw2dsk/","text":"raw2dsk raw2dsk utility SYNOPSYS raw2dsk rawfile dskfile EXAMPLES raw2dsk dumpdsk.raw dumpdsk.dsk DESCRIPTION raw2dsk convert raw floppy disk dump file to .dsk file OPTIONS no options SOURCE https://github.com/orix-software/raw2dsk","title":"raw2dsk"},{"location":"commands/raw2dsk/#raw2dsk","text":"","title":"raw2dsk"},{"location":"commands/raw2dsk/#raw2dsk-utility","text":"","title":"raw2dsk utility"},{"location":"commands/raw2dsk/#synopsys","text":"raw2dsk rawfile dskfile","title":"SYNOPSYS"},{"location":"commands/raw2dsk/#examples","text":"raw2dsk dumpdsk.raw dumpdsk.dsk","title":"EXAMPLES"},{"location":"commands/raw2dsk/#description","text":"raw2dsk convert raw floppy disk dump file to .dsk file","title":"DESCRIPTION"},{"location":"commands/raw2dsk/#options","text":"no options","title":"OPTIONS"},{"location":"commands/raw2dsk/#source","text":"https://github.com/orix-software/raw2dsk","title":"SOURCE"},{"location":"commands/readdsk/","text":"Readdsk Dump a real floppy disk. It needs a real floppy drive controler to be attached with twilighte board Usage readdsk myfile.raw -v : verbose -vv : more verbose, displays sectors content -h : this help -V : displays version readdsk produces a rawfile. raw2dsk must be launch to build a .dsk file","title":"readdsk"},{"location":"commands/readdsk/#readdsk","text":"Dump a real floppy disk. It needs a real floppy drive controler to be attached with twilighte board","title":"Readdsk"},{"location":"commands/readdsk/#usage","text":"readdsk myfile.raw -v : verbose -vv : more verbose, displays sectors content -h : this help -V : displays version readdsk produces a rawfile. raw2dsk must be launch to build a .dsk file","title":"Usage"},{"location":"commands/reboot/","text":"reboot Introduction reboot machine SYNOPSYS reboot DESCRIPTION Reboot the machine: it call NMI VECTORS and flush page 2 and page 0 SOURCE https://github.com/orix-software/shell/blob/master/src/commands/reboot.asm","title":"reboot"},{"location":"commands/reboot/#reboot","text":"","title":"reboot"},{"location":"commands/reboot/#introduction","text":"reboot machine","title":"Introduction"},{"location":"commands/reboot/#synopsys","text":"reboot","title":"SYNOPSYS"},{"location":"commands/reboot/#description","text":"Reboot the machine: it call NMI VECTORS and flush page 2 and page 0","title":"DESCRIPTION"},{"location":"commands/reboot/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/reboot.asm","title":"SOURCE"},{"location":"commands/rm/","text":"rm Introduction remove file SYNOPSYS /# rm /myfile DESCRIPTION rm file or directory. For instance, rm can only remove file in root folder, relative arg does not work yet EXAMPLES rm /myffile SOURCE https://github.com/orix-software/shell/blob/master/src/commands/rm.asm","title":"rm"},{"location":"commands/rm/#rm","text":"","title":"rm"},{"location":"commands/rm/#introduction","text":"remove file","title":"Introduction"},{"location":"commands/rm/#synopsys","text":"/# rm /myfile","title":"SYNOPSYS"},{"location":"commands/rm/#description","text":"rm file or directory. For instance, rm can only remove file in root folder, relative arg does not work yet","title":"DESCRIPTION"},{"location":"commands/rm/#examples","text":"rm /myffile","title":"EXAMPLES"},{"location":"commands/rm/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/rm.asm","title":"SOURCE"},{"location":"commands/setfont/","text":"setfont Introduction Change the default font SYNOPSYS setfont fontname DESCRIPTION This command overwrite the current charset with a new one EXAMPLES setfont boldfr0 setfont default Lists of fonts BLACKFR0 BOLDFR0 CLEARUK0 CURSIVFR DIGITAFR FANTA1UK FANTA3UK GREEKUK0 NAROW2FR ORICFR0 SMLCAPUK SQUBOLUK BLACKUK0 BOLDUK0 CURSI2FR CURSIVUK DIGITAUK FANTA2UK GOTHIQFR MIROIRUK NAROW2UK ORICUK0 SQUAREUK SYMBOLUK BOLD2FR0 CLEARFR0 CURSI2UK DEFAULT ENVERSUK FANTA3FR GOTHIQUK MODERNFR NARROWUK SLANTUK0 SQUBOLFR NOTES Font files are in /usr/share/fonts SOURCE https://github.com/orix-software/shell/blob/master/src/commands/setfont.asm","title":"setfont"},{"location":"commands/setfont/#setfont","text":"","title":"setfont"},{"location":"commands/setfont/#introduction","text":"Change the default font","title":"Introduction"},{"location":"commands/setfont/#synopsys","text":"setfont fontname","title":"SYNOPSYS"},{"location":"commands/setfont/#description","text":"This command overwrite the current charset with a new one","title":"DESCRIPTION"},{"location":"commands/setfont/#examples","text":"setfont boldfr0 setfont default","title":"EXAMPLES"},{"location":"commands/setfont/#lists-of-fonts","text":"BLACKFR0 BOLDFR0 CLEARUK0 CURSIVFR DIGITAFR FANTA1UK FANTA3UK GREEKUK0 NAROW2FR ORICFR0 SMLCAPUK SQUBOLUK BLACKUK0 BOLDUK0 CURSI2FR CURSIVUK DIGITAUK FANTA2UK GOTHIQFR MIROIRUK NAROW2UK ORICUK0 SQUAREUK SYMBOLUK BOLD2FR0 CLEARFR0 CURSI2UK DEFAULT ENVERSUK FANTA3FR GOTHIQUK MODERNFR NARROWUK SLANTUK0 SQUBOLFR","title":"Lists of fonts"},{"location":"commands/setfont/#notes","text":"Font files are in /usr/share/fonts","title":"NOTES"},{"location":"commands/setfont/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/setfont.asm","title":"SOURCE"},{"location":"commands/sh/","text":"sh Introduction When kernel has finished to initialize at boot time, sh command is started in interactive mode Interactive mode Esc-b : move cursor at the beginning of the previous word Esc-f : move cursor at the end of the next word Esc-l : switch current word into lowercase, and put cursor at the end of the word Esc-u : switch current word into uppercase, and put cursor at the end of the word Ctrl-a : move cursor at the beginning of the line Ctrl-e : move cursor at the end of the line Ctrl-c : cancel current line Ctrl-k : delete the end of the line Ctrl-l : clear screen, and displays the line, the cursors keeps his position Ctrl-u : clear the line and put cursor at the beginning of the line Ctrl-t : swap char under the cursor with the previous one, and shift the cursor to the right Ctrl-o : Switch into replacement or insertion mode Shortcuts for tools Funct+A : Start Systemd rom Funct+B : Start Basic11 Funct+G : Start basic11 gui Funct+L : Start Loader Funct+T : Start Twilighte setup Available commands The command line is limited in characters (37). If you reach this limit, you won\u2019t be able to type the complete command line Known bugs \u00ab ./ \u00bb can not be used to launch a binar","title":"sh"},{"location":"commands/sh/#sh","text":"","title":"sh"},{"location":"commands/sh/#introduction","text":"When kernel has finished to initialize at boot time, sh command is started in interactive mode","title":"Introduction"},{"location":"commands/sh/#interactive-mode","text":"Esc-b : move cursor at the beginning of the previous word Esc-f : move cursor at the end of the next word Esc-l : switch current word into lowercase, and put cursor at the end of the word Esc-u : switch current word into uppercase, and put cursor at the end of the word Ctrl-a : move cursor at the beginning of the line Ctrl-e : move cursor at the end of the line Ctrl-c : cancel current line Ctrl-k : delete the end of the line Ctrl-l : clear screen, and displays the line, the cursors keeps his position Ctrl-u : clear the line and put cursor at the beginning of the line Ctrl-t : swap char under the cursor with the previous one, and shift the cursor to the right Ctrl-o : Switch into replacement or insertion mode","title":"Interactive mode"},{"location":"commands/sh/#shortcuts-for-tools","text":"Funct+A : Start Systemd rom Funct+B : Start Basic11 Funct+G : Start basic11 gui Funct+L : Start Loader Funct+T : Start Twilighte setup","title":"Shortcuts for tools"},{"location":"commands/sh/#available-commands","text":"The command line is limited in characters (37). If you reach this limit, you won\u2019t be able to type the complete command line Known bugs \u00ab ./ \u00bb can not be used to launch a binar","title":"Available commands"},{"location":"commands/strerr/","text":"Command: strerr strerr utility SYNOPSYS strerr -h|-v|-a strerr [-q] start[,end] strerr [-a[q]] [start] EXAMPLES strerr 1 strerr 1,4 strerr ,18 strerr -a 3 DESCRIPTION strerr return string describing error number OPTIONS -h display command syntax -v display program version -a display all message from start -q quiet mode start message number (def: 0) end last message number (def: 0) SOURCE https://github.com/orix-software/strerr","title":"Command: strerr"},{"location":"commands/strerr/#command-strerr","text":"","title":"Command: strerr"},{"location":"commands/strerr/#strerr-utility","text":"","title":"strerr utility"},{"location":"commands/strerr/#synopsys","text":"strerr -h|-v|-a strerr [-q] start[,end] strerr [-a[q]] [start]","title":"SYNOPSYS"},{"location":"commands/strerr/#examples","text":"strerr 1 strerr 1,4 strerr ,18 strerr -a 3","title":"EXAMPLES"},{"location":"commands/strerr/#description","text":"strerr return string describing error number","title":"DESCRIPTION"},{"location":"commands/strerr/#options","text":"-h display command syntax -v display program version -a display all message from start -q quiet mode start message number (def: 0) end last message number (def: 0)","title":"OPTIONS"},{"location":"commands/strerr/#source","text":"https://github.com/orix-software/strerr","title":"SOURCE"},{"location":"commands/submit/","text":"Command: submit submit utility SYNOPSYS submit file [arg...] EXAMPLES submit help.sub DESCRIPTION submit is a command language interpreter that executes commands read from a file. OPTIONS no options SOURCE https://github.com/orix-software/submit","title":"submit"},{"location":"commands/submit/#command-submit","text":"","title":"Command: submit"},{"location":"commands/submit/#submit-utility","text":"","title":"submit utility"},{"location":"commands/submit/#synopsys","text":"submit file [arg...]","title":"SYNOPSYS"},{"location":"commands/submit/#examples","text":"submit help.sub","title":"EXAMPLES"},{"location":"commands/submit/#description","text":"submit is a command language interpreter that executes commands read from a file.","title":"DESCRIPTION"},{"location":"commands/submit/#options","text":"no options","title":"OPTIONS"},{"location":"commands/submit/#source","text":"https://github.com/orix-software/submit","title":"SOURCE"},{"location":"commands/touch/","text":"touch Introduction Create an empty file SYNOPSYS touch myfile DESCRIPTION Create an empty file. Time does not affect the timstamp of the file. SOURCE https://github.com/orix-software/shell/blob/master/src/commands/touch.asm","title":"touch"},{"location":"commands/touch/#touch","text":"","title":"touch"},{"location":"commands/touch/#introduction","text":"Create an empty file","title":"Introduction"},{"location":"commands/touch/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/touch/#touch-myfile","text":"","title":"touch myfile"},{"location":"commands/touch/#description","text":"Create an empty file. Time does not affect the timstamp of the file.","title":"DESCRIPTION"},{"location":"commands/touch/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/touch.asm","title":"SOURCE"},{"location":"commands/twil/","text":"twil Introduction Twil command can displays the current firmware of twilighte card, and can swap root folder to usbkey or sdcard. SYNOPSYS /#twil -f : displays Twilighte board firmware /#twil -u : switch default device : usbdrive /#twil -s : swap default device to : sdcard DESCRIPTION SOURCE https://github.com/orix-software/shell/blob/master/src/commands/twil.asm","title":"twil"},{"location":"commands/twil/#twil","text":"","title":"twil"},{"location":"commands/twil/#introduction","text":"Twil command can displays the current firmware of twilighte card, and can swap root folder to usbkey or sdcard.","title":"Introduction"},{"location":"commands/twil/#synopsys","text":"/#twil -f : displays Twilighte board firmware /#twil -u : switch default device : usbdrive /#twil -s : swap default device to : sdcard","title":"SYNOPSYS"},{"location":"commands/twil/#description","text":"","title":"DESCRIPTION"},{"location":"commands/twil/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/twil.asm","title":"SOURCE"},{"location":"commands/twilconf/","text":"","title":"Twilconf"},{"location":"commands/twiload/","text":"Twilload Start loader","title":"twiload"},{"location":"commands/twiload/#twilload","text":"Start loader","title":"Twilload"},{"location":"commands/uname/","text":"uname Introduction Display kernel info SYNOPSYS uname [-a] DESCRIPTION Display kernel info SOURCE https://github.com/orix-software/shell/blob/master/src/commands/uname.asm","title":"uname"},{"location":"commands/uname/#uname","text":"","title":"uname"},{"location":"commands/uname/#introduction","text":"Display kernel info","title":"Introduction"},{"location":"commands/uname/#synopsys","text":"uname [-a]","title":"SYNOPSYS"},{"location":"commands/uname/#description","text":"Display kernel info","title":"DESCRIPTION"},{"location":"commands/uname/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/uname.asm","title":"SOURCE"},{"location":"commands/untar/","text":"Command: untar untar utility SYNOPSYS untar -t[v]f tarfile untar -x[v]f tarfile EXAMPLES untar -tf /home/test.tar DESCRIPTION untar list and extract files in a TAR archive OPTIONS -h ^Bshow this help message and exit -t ^Blist files -x ^Bextract files -v ^Bverbose mode SOURCE https://github.com/orix-software/untar","title":"untar"},{"location":"commands/untar/#command-untar","text":"","title":"Command: untar"},{"location":"commands/untar/#untar-utility","text":"","title":"untar utility"},{"location":"commands/untar/#synopsys","text":"untar -t[v]f tarfile untar -x[v]f tarfile","title":"SYNOPSYS"},{"location":"commands/untar/#examples","text":"untar -tf /home/test.tar","title":"EXAMPLES"},{"location":"commands/untar/#description","text":"untar list and extract files in a TAR archive","title":"DESCRIPTION"},{"location":"commands/untar/#options","text":"-h ^Bshow this help message and exit -t ^Blist files -x ^Bextract files -v ^Bverbose mode","title":"OPTIONS"},{"location":"commands/untar/#source","text":"https://github.com/orix-software/untar","title":"SOURCE"},{"location":"commands/vidplay/","text":"Vidplay Play .vhi video (some are located in /usr/share/vidplay/)","title":"vidplay"},{"location":"commands/vidplay/#vidplay","text":"Play .vhi video (some are located in /usr/share/vidplay/)","title":"Vidplay"},{"location":"commands/viewhrs/","text":"viewhrs Introduction Displays a hrs file SYNOPSYS /#viewhrs toto.hrs DESCRIPTION Displays a hrs file EXAMPLES viewhrs me.hrs SOURCE https://github.com/orix-software/shell/blob/master/src/commands/viewhrs.asm","title":"viewhrs"},{"location":"commands/viewhrs/#viewhrs","text":"","title":"viewhrs"},{"location":"commands/viewhrs/#introduction","text":"Displays a hrs file","title":"Introduction"},{"location":"commands/viewhrs/#synopsys","text":"/#viewhrs toto.hrs","title":"SYNOPSYS"},{"location":"commands/viewhrs/#description","text":"Displays a hrs file","title":"DESCRIPTION"},{"location":"commands/viewhrs/#examples","text":"viewhrs me.hrs","title":"EXAMPLES"},{"location":"commands/viewhrs/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/viewhrs.asm","title":"SOURCE"},{"location":"commands/viewscr/","text":"Command: viewscr viewscr utility SYNOPSYS viewscr file [...] EXAMPLES viewscr format.scr viewscr address.win monac1.hlp DESCRIPTION Display TEXT screen dump files like SCR files from FTDOS disks or HLP, WIN files from Sedoric disks. SOURCE https://github.com/orix-software/viewscr","title":"viewscr"},{"location":"commands/viewscr/#command-viewscr","text":"","title":"Command: viewscr"},{"location":"commands/viewscr/#viewscr-utility","text":"","title":"viewscr utility"},{"location":"commands/viewscr/#synopsys","text":"viewscr file [...]","title":"SYNOPSYS"},{"location":"commands/viewscr/#examples","text":"viewscr format.scr viewscr address.win monac1.hlp","title":"EXAMPLES"},{"location":"commands/viewscr/#description","text":"Display TEXT screen dump files like SCR files from FTDOS disks or HLP, WIN files from Sedoric disks.","title":"DESCRIPTION"},{"location":"commands/viewscr/#source","text":"https://github.com/orix-software/viewscr","title":"SOURCE"},{"location":"commands/zerofx/","text":"ZeroFX demo Launch zerofx /#zerofx","title":"zerofx"},{"location":"commands/zerofx/#zerofx-demo","text":"Launch zerofx /#zerofx","title":"ZeroFX demo"},{"location":"developer_manual/","text":"Installation for developpers There is two way to develop : Oricutron and cross dev with test on real computer Step 1 : Download the oricutron archive with all things set : oricutron_twilighte_board_for_projects.zip or Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron or download last windows binaries : https://iss.sandacite.com/iss/oricutron/ In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board = yes plugins/twilighte_board/twilighte.cfg you can put any rom you want. Step 2 : get main rom (kernel and shell) Skip this step, if you downloaded \"oricutron_twilighte_board_for_projects\" arhive Step 3 : start oricutron Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then \"usbdrive/\" folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip Step 4 : Download/build cc65 Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder) Step 5 : Download SDK (mainly for assembly) Clone https://github.com/assinie/orix-sdk in your project folder","title":"Install"},{"location":"developer_manual/#installation-for-developpers","text":"There is two way to develop : Oricutron and cross dev with test on real computer","title":"Installation for developpers"},{"location":"developer_manual/#step-1-download-the-oricutron-archive-with-all-things-set","text":"oricutron_twilighte_board_for_projects.zip or Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron or download last windows binaries : https://iss.sandacite.com/iss/oricutron/ In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board = yes plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Step 1 : Download the oricutron archive with all things set :"},{"location":"developer_manual/#step-2-get-main-rom-kernel-and-shell","text":"Skip this step, if you downloaded \"oricutron_twilighte_board_for_projects\" arhive","title":"Step 2 : get main rom (kernel and shell)"},{"location":"developer_manual/#step-3-start-oricutron","text":"Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then \"usbdrive/\" folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip","title":"Step 3 : start oricutron"},{"location":"developer_manual/#step-4-downloadbuild-cc65","text":"Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder)","title":"Step 4 : Download/build cc65"},{"location":"developer_manual/#step-5-download-sdk-mainly-for-assembly","text":"Clone https://github.com/assinie/orix-sdk in your project folder","title":"Step 5 : Download SDK  (mainly for assembly)"},{"location":"developer_manual/basic11_informations/","text":"basic11 rom Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance Si on tape : /#basic11 Cela lance la ROM Si on tape : /#basic11 \"TAPEFILE\" Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent) Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : '/usr/share/basic11/3/' pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom. Si on tape : /#basic11 -l Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici Fonctionnement global Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1 Format du fichier \"maindb\" (basic11.db) Version 1 1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture) Format du fichier .db d'un soft version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"basic11 rom"},{"location":"developer_manual/basic11_informations/#basic11-rom","text":"Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance","title":"basic11 rom"},{"location":"developer_manual/basic11_informations/#si-on-tape-basic11","text":"Cela lance la ROM","title":"Si on tape : /#basic11"},{"location":"developer_manual/basic11_informations/#si-on-tape-basic11-tapefile","text":"Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent) Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : '/usr/share/basic11/3/' pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom.","title":"Si on tape : /#basic11 \"TAPEFILE\""},{"location":"developer_manual/basic11_informations/#si-on-tape-basic11-l","text":"Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici","title":"Si on tape : /#basic11 -l"},{"location":"developer_manual/basic11_informations/#fonctionnement-global","text":"Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1","title":"Fonctionnement global"},{"location":"developer_manual/basic11_informations/#format-du-fichier-maindb-basic11db","text":"","title":"Format du fichier \"maindb\" (basic11.db)"},{"location":"developer_manual/basic11_informations/#version-1","text":"1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture)","title":"Version 1"},{"location":"developer_manual/basic11_informations/#format-du-fichier-db-dun-soft","text":"version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Format du fichier .db d'un soft"},{"location":"developer_manual/binary_starts/","text":"Binary start sequence All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls XEXEC kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD Step 1 : check if binary is in a bank XEXEC reads all banks from 4 to 1 and tries to check if the program is in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks). If the commands is not found, it swaps \"Twilighte banking register\" to provide others 65KB of bank, kernel checks banks again. When kernel reached the 32 banks of rom, it swap to ram set, and reads all theses 32 banks of RAM. If the command is not found, kernel send error code, and shell will display error message according to kernel error code. That is why commands located in bank (eeprom and after RAM) are quicker to start. EEPROM banks are quicker to launch because kernel starts with eeprom set. Step 2 : Check if the binary is on the device If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If the binary open fails, it returns \"command not found\" or impossible to mount if device is not present. Step 3 : binary on storage device is found Kernel opens the file, reads the header, and loads the content of the binary on the right address. When it's OK, the binary is started (and a fork occurs)","title":"Binary boot sequence"},{"location":"developer_manual/binary_starts/#binary-start-sequence","text":"All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls XEXEC kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD","title":"Binary start sequence"},{"location":"developer_manual/binary_starts/#step-1-check-if-binary-is-in-a-bank","text":"XEXEC reads all banks from 4 to 1 and tries to check if the program is in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks). If the commands is not found, it swaps \"Twilighte banking register\" to provide others 65KB of bank, kernel checks banks again. When kernel reached the 32 banks of rom, it swap to ram set, and reads all theses 32 banks of RAM. If the command is not found, kernel send error code, and shell will display error message according to kernel error code. That is why commands located in bank (eeprom and after RAM) are quicker to start. EEPROM banks are quicker to launch because kernel starts with eeprom set.","title":"Step 1 : check if binary is in a bank"},{"location":"developer_manual/binary_starts/#step-2-check-if-the-binary-is-on-the-device","text":"If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If the binary open fails, it returns \"command not found\" or impossible to mount if device is not present.","title":"Step 2 : Check if the binary is on the device"},{"location":"developer_manual/binary_starts/#step-3-binary-on-storage-device-is-found","text":"Kernel opens the file, reads the header, and loads the content of the binary on the right address. When it's OK, the binary is started (and a fork occurs)","title":"Step 3 : binary on storage device is found"},{"location":"developer_manual/buildman/","text":"Manual pages man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Generate man pages"},{"location":"developer_manual/buildman/#manual-pages","text":"man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Manual pages"},{"location":"developer_manual/buildrom/","text":"Build an Orix rom Guideline In order to have commands available from shell, some rules must be set in the bank structure ( https://github.com/orix-software/empty-rom/ ). Bank structure must be used, or commands won't be accessed from the kernel or commands (As help -b XX) A ROM will be in an ROM slot or a RAM slot. Ram slot is useful if some values must be set internaly (and it avoid malloc use, but it's not the way a ROM should not done if the process can be launched twice at the same time). The twilighte board had been released without the sram saved with a battery, there is a lot more twilighte board in the workd without SRAM saved by battery than with a battery. In that case, if a .rom is coded with the behavior to keep information into it's bank slot (like configuration), it will lost (and the content of the rom) when oric is switch off. Since shell 2022.4, it's possible to load roms with a shortcut from a config file in /etc Some existing roms are in a eeprom slot (kernel, shell, monitor, forth ..). Systemd rom is a rom loaded into RAM bank. C language can be used for bank, but the 16KB of a bank is quickly filled with C code. orix-sdk must be intensively used, and if it can't be used, kernel primitives must be used. If a universal feature is missing in kernel, it's better to insert into kernel than develop only for the ROM. Each rom contains 1 or X commands. In order to have multitasking in the future, commands must use malloc and free from kernel (and file operations from the kernel) commands must use zero page from $80 to $80+26 because kernel saves 26 bytes from $80 to $80+26 in order to swap processes. Address $80 to $80+26 are reserved for binary functionnality. It's also possible to use RES and RESB (used in kernel primitive), if you don't call kernel primitives, or else, it well be erased in each kernel primitive call limit for a rom is 16KB. But, it's maybe enough because many operations are done with kernel calls (fopen for example). Kernel is always available (Bank 7) when \"set\" banking is RAM or EEPROM (kernel is always available during swapping banks with twilighte banking register ($343)). Bank Structure If you want to build an orix compatible rom, a special format is used for Orix bank. A rom template can be downloaded here : https://github.com/orix-software/empty-rom/ Rom definition $fff0 : 1 byte, rom type (Value 0 : empty bank, value 1 : command bank) Zero page userzp is equal to $8C. It's a range from $8C to $8C+16 which is saved for each process, when a process is forked Kernel uses some address in zero page. But userzp to userzp+16 offset are reserved for binary, Orix banks. Address below userzp can be used, but kernel could erase it when IRQ or Kernels calls are performed Kernel saves 16 bytes (zeropage) when a binary is forked. It means that, a XEXEC calls in a binary, kernel will save PPID offset from userzp to userzp+16, and kernel will restore theses offsets when the PID has finished. In the future, multitasking will work in the same ways, and there is no guarantee that a binary will have its values restores when offset are greater than userzp+16 Launch the ROM Oricutron If it's a rom which must be in a ram slot, the config file (twilighte.cfg) must be set it in in bankram section or else insert it in bankrom section. Real Rom can be loaded on eeprom easily, it will erase 4 banks : /#orixcfg -r -s 0 myrom.rom Rom must be loaded into ram slot, it will erase only one bank : /#orixcfg -w -s 0 -b 4 myrom.rom At this step if everything is OK, each commands from the bank can be accessed from shell.","title":"Build an Orix rom"},{"location":"developer_manual/buildrom/#build-an-orix-rom","text":"","title":"Build an Orix rom"},{"location":"developer_manual/buildrom/#guideline","text":"In order to have commands available from shell, some rules must be set in the bank structure ( https://github.com/orix-software/empty-rom/ ). Bank structure must be used, or commands won't be accessed from the kernel or commands (As help -b XX) A ROM will be in an ROM slot or a RAM slot. Ram slot is useful if some values must be set internaly (and it avoid malloc use, but it's not the way a ROM should not done if the process can be launched twice at the same time). The twilighte board had been released without the sram saved with a battery, there is a lot more twilighte board in the workd without SRAM saved by battery than with a battery. In that case, if a .rom is coded with the behavior to keep information into it's bank slot (like configuration), it will lost (and the content of the rom) when oric is switch off. Since shell 2022.4, it's possible to load roms with a shortcut from a config file in /etc Some existing roms are in a eeprom slot (kernel, shell, monitor, forth ..). Systemd rom is a rom loaded into RAM bank. C language can be used for bank, but the 16KB of a bank is quickly filled with C code. orix-sdk must be intensively used, and if it can't be used, kernel primitives must be used. If a universal feature is missing in kernel, it's better to insert into kernel than develop only for the ROM. Each rom contains 1 or X commands. In order to have multitasking in the future, commands must use malloc and free from kernel (and file operations from the kernel) commands must use zero page from $80 to $80+26 because kernel saves 26 bytes from $80 to $80+26 in order to swap processes. Address $80 to $80+26 are reserved for binary functionnality. It's also possible to use RES and RESB (used in kernel primitive), if you don't call kernel primitives, or else, it well be erased in each kernel primitive call limit for a rom is 16KB. But, it's maybe enough because many operations are done with kernel calls (fopen for example). Kernel is always available (Bank 7) when \"set\" banking is RAM or EEPROM (kernel is always available during swapping banks with twilighte banking register ($343)).","title":"Guideline"},{"location":"developer_manual/buildrom/#bank-structure","text":"If you want to build an orix compatible rom, a special format is used for Orix bank. A rom template can be downloaded here : https://github.com/orix-software/empty-rom/","title":"Bank Structure"},{"location":"developer_manual/buildrom/#rom-definition","text":"$fff0 : 1 byte, rom type (Value 0 : empty bank, value 1 : command bank)","title":"Rom definition"},{"location":"developer_manual/buildrom/#zero-page","text":"userzp is equal to $8C. It's a range from $8C to $8C+16 which is saved for each process, when a process is forked Kernel uses some address in zero page. But userzp to userzp+16 offset are reserved for binary, Orix banks. Address below userzp can be used, but kernel could erase it when IRQ or Kernels calls are performed Kernel saves 16 bytes (zeropage) when a binary is forked. It means that, a XEXEC calls in a binary, kernel will save PPID offset from userzp to userzp+16, and kernel will restore theses offsets when the PID has finished. In the future, multitasking will work in the same ways, and there is no guarantee that a binary will have its values restores when offset are greater than userzp+16","title":"Zero page"},{"location":"developer_manual/buildrom/#launch-the-rom","text":"","title":"Launch the ROM"},{"location":"developer_manual/buildrom/#oricutron","text":"If it's a rom which must be in a ram slot, the config file (twilighte.cfg) must be set it in in bankram section or else insert it in bankrom section.","title":"Oricutron"},{"location":"developer_manual/buildrom/#real","text":"Rom can be loaded on eeprom easily, it will erase 4 banks : /#orixcfg -r -s 0 myrom.rom Rom must be loaded into ram slot, it will erase only one bank : /#orixcfg -w -s 0 -b 4 myrom.rom At this step if everything is OK, each commands from the bank can be accessed from shell.","title":"Real"},{"location":"developer_manual/buildstandalonerom/","text":"Build a standalone ROM Prerequisites Before starting : Read Oricutron VS Real hardware Guidelines A standalone ROM is a ROM which does not need the kernel and manage the fully main memory. It's not the main choice when a ROM is built, but it's used to handle easily compatibility for \"Legacy roms\" as Atmos Rom, Oric-1 and others customs roms released. It means that all code to manage files, joysticks, text I/O, Hires I/O must be inserted in this rom. This mode must avoided because it won't handle evolution handled in the kernel and the Twilighte board Access to sdcard and usbdrive Orix and kernel handles devices : usbdrive (Usbkey) and sdcard. When a standalone rom is built, it must keep default device, in that case, it requires to ask to the kernel which is the default device before flushing main memory. Launching a standalone ROM If you are on Oricutron, you can put in bank 7, your rom and start Oricutron in twilighte board mode. On real computer, you need to copy your ROM into a folder (ex : /usr/share/myroms/myrom.rom) Modify /etc/systemd/banks.cnf to add a new rom entry Type funct + L and you will be able to start your standalone ROM","title":"Build standalone Rom"},{"location":"developer_manual/buildstandalonerom/#build-a-standalone-rom","text":"","title":"Build a standalone ROM"},{"location":"developer_manual/buildstandalonerom/#prerequisites","text":"Before starting : Read Oricutron VS Real hardware","title":"Prerequisites"},{"location":"developer_manual/buildstandalonerom/#guidelines","text":"A standalone ROM is a ROM which does not need the kernel and manage the fully main memory. It's not the main choice when a ROM is built, but it's used to handle easily compatibility for \"Legacy roms\" as Atmos Rom, Oric-1 and others customs roms released. It means that all code to manage files, joysticks, text I/O, Hires I/O must be inserted in this rom. This mode must avoided because it won't handle evolution handled in the kernel and the Twilighte board","title":"Guidelines"},{"location":"developer_manual/buildstandalonerom/#access-to-sdcard-and-usbdrive","text":"Orix and kernel handles devices : usbdrive (Usbkey) and sdcard. When a standalone rom is built, it must keep default device, in that case, it requires to ask to the kernel which is the default device before flushing main memory.","title":"Access to sdcard and usbdrive"},{"location":"developer_manual/buildstandalonerom/#launching-a-standalone-rom","text":"If you are on Oricutron, you can put in bank 7, your rom and start Oricutron in twilighte board mode. On real computer, you need to copy your ROM into a folder (ex : /usr/share/myroms/myrom.rom) Modify /etc/systemd/banks.cnf to add a new rom entry Type funct + L and you will be able to start your standalone ROM","title":"Launching a standalone ROM"},{"location":"developer_manual/cc65/","text":"Cc65 use cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary.","title":"cc65"},{"location":"developer_manual/cc65/#cc65-use","text":"cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary.","title":"Cc65 use"},{"location":"developer_manual/firmware/","text":"Firmwares You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables : Firmware 1 Firmware 2 Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank Firmware 3 Under development Firmware 4 It's under development but it will handles others hardware chips.","title":"Firmware informations"},{"location":"developer_manual/firmware/#firmwares","text":"You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables :","title":"Firmwares"},{"location":"developer_manual/firmware/#firmware-1","text":"","title":"Firmware 1"},{"location":"developer_manual/firmware/#firmware-2","text":"Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank","title":"Firmware 2"},{"location":"developer_manual/firmware/#firmware-3","text":"Under development","title":"Firmware 3"},{"location":"developer_manual/firmware/#firmware-4","text":"It's under development but it will handles others hardware chips.","title":"Firmware 4"},{"location":"developer_manual/guidelines/","text":"Guidelines Ways to do a binary There is many ways to buid a binary : bank or on storage To summarize, the best speed shoud be read only bank, but it could a bit slow when program runs cd type Starting speed Loading kernel search command speed Runtime speed Eeprom bank RAM bank Binary from /bin Eeprom bank : No loading, Best mode to find a command for the kernel and probably slower due to zp use and indirect mode to access memory. RAM bank : No loading, second Best mode to find a command for the kernel and probably slower due to zp use and indirect mode to access memory. Binary on the storage : loading, the worst way to find a command : kernel search into bank and after in the storage. Probably faster than bank (due to absolute mode in it's own buffers).","title":"Development guidelines"},{"location":"developer_manual/guidelines/#guidelines","text":"","title":"Guidelines"},{"location":"developer_manual/guidelines/#ways-to-do-a-binary","text":"There is many ways to buid a binary : bank or on storage To summarize, the best speed shoud be read only bank, but it could a bit slow when program runs cd type Starting speed Loading kernel search command speed Runtime speed Eeprom bank RAM bank Binary from /bin Eeprom bank : No loading, Best mode to find a command for the kernel and probably slower due to zp use and indirect mode to access memory. RAM bank : No loading, second Best mode to find a command for the kernel and probably slower due to zp use and indirect mode to access memory. Binary on the storage : loading, the worst way to find a command : kernel search into bank and after in the storage. Probably faster than bank (due to absolute mode in it's own buffers).","title":"Ways to do a binary"},{"location":"developer_manual/hardware/","text":"Hardware Twilighte Board .","title":"Hardware"},{"location":"developer_manual/hardware/#hardware","text":"Twilighte Board .","title":"Hardware"},{"location":"developer_manual/header/","text":"Header Orix binary v2 format (relocated : bitfield table, available since Kernel 2022.4) .byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number like o65 format .byt $02 ; version of this header cpu_mode: .byt $00 ; CPU see below for description ;7 .byt < SIZE_BITFIELD , > SIZE_BITFIELD ; size of the bitfield map low ;9 .byt $00 ; reserved ;10 .byt $00 ; reserved ;11 .byt $00 ; reserved ;12 .byt < OFFSET_BITFIELD , > OFFSET_BITFIELD ; offset of the bitfield ;14 .byt < start_adress , > start_adress ; loading adress ;16 .byt < endofmemory , > EndOfMemory ; end of loading adress ; 18 .byt < start_adress , > start_adress ; Execution adress ; end of header start_adress: lda $00 rts EndOfMemory: Orix binary v1 format (Will be deprecated) Orix binary v1 is not a relocated format. The binary must be never under $800. Relocation format (Format 2 see below) is now provided in kernel v2022.4 You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly .byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt < start_adress , > start_adress ; loading adress .byt < endofmemory , > EndOfMemory ; end of loading adress .byt < start_adress , > start_adress ; starting adress start_adress: *= $1000 lda # $41 sta $bb80 rts EndOfMemory: Description cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell)","title":"Binary header format"},{"location":"developer_manual/header/#header","text":"","title":"Header"},{"location":"developer_manual/header/#orix-binary-v2-format-relocated-bitfield-table-available-since-kernel-20224","text":".byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number like o65 format .byt $02 ; version of this header cpu_mode: .byt $00 ; CPU see below for description ;7 .byt < SIZE_BITFIELD , > SIZE_BITFIELD ; size of the bitfield map low ;9 .byt $00 ; reserved ;10 .byt $00 ; reserved ;11 .byt $00 ; reserved ;12 .byt < OFFSET_BITFIELD , > OFFSET_BITFIELD ; offset of the bitfield ;14 .byt < start_adress , > start_adress ; loading adress ;16 .byt < endofmemory , > EndOfMemory ; end of loading adress ; 18 .byt < start_adress , > start_adress ; Execution adress ; end of header start_adress: lda $00 rts EndOfMemory:","title":"Orix binary v2 format (relocated : bitfield table, available since Kernel 2022.4)"},{"location":"developer_manual/header/#orix-binary-v1-format-will-be-deprecated","text":"Orix binary v1 is not a relocated format. The binary must be never under $800. Relocation format (Format 2 see below) is now provided in kernel v2022.4 You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly .byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt < start_adress , > start_adress ; loading adress .byt < endofmemory , > EndOfMemory ; end of loading adress .byt < start_adress , > start_adress ; starting adress start_adress: *= $1000 lda # $41 sta $bb80 rts EndOfMemory:","title":"Orix binary v1 format (Will be deprecated)"},{"location":"developer_manual/header/#description","text":"cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell)","title":"Description"},{"location":"developer_manual/joysticks/","text":"Joysticks management Joystick supports are available in oricutron. Joysticks works exactly than on telestrat computer.","title":"Joysticks management"},{"location":"developer_manual/joysticks/#joysticks-management","text":"Joystick supports are available in oricutron. Joysticks works exactly than on telestrat computer.","title":"Joysticks management"},{"location":"developer_manual/kernel/","text":"Kernel Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orixsdk manages some kernel calls, and it's better to use macro set to call some primitives Useful links Documented primitives Primitives Orixsdk (sdk for assembly) : Orixsdk C programming : cc65 (telestrat target)","title":"Kernel"},{"location":"developer_manual/kernel/#kernel","text":"Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orixsdk manages some kernel calls, and it's better to use macro set to call some primitives","title":"Kernel"},{"location":"developer_manual/kernel/#useful-links","text":"Documented primitives Primitives Orixsdk (sdk for assembly) : Orixsdk C programming : cc65 (telestrat target)","title":"Useful links"},{"location":"developer_manual/memory/","text":"Memory management Hardware informations Twilighte board handles 512KB of RAM and 512KB of eeprom Orix Roms Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. XMALLOC primitives only returns pointer from main memory. Kernel can't instanciate extra memory from bank for instance. Standalone ROM Extra memory can be accessed without kernel primitive with simple code The banking management is the same as Telestrat in order to have Orix working on Telestrat too, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility There is a register which contains a set of 4 banks. This register accept values from 0 to 7 : $343. Each value set another set of 4 banks. For example, if $343 contains 2, it will displays others parts of eeprom or SRAM when bit b0, b1, b2 in $321 register contains 4,3,2,1 Banking management explanation Switching to another bank should not be done, but the behavior of the card is explained below. For example, a ROM can be loaded into eeprom or ram with orixcfg Some others ROMS (as systemd, or others standalone rom) are loaded on the fly with loader menu. If it needs more ram than the main memory, extended driver is not coded, but it could on the future. Kernel is always reached when $321&7 is equal to 7 . $343 register does not change the behavior of the value set in $321, when $321&7=7 $321&6=6 and $321&5=5. When it's below 5, banks are swapped when register value of $343 change To summarize : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown but for others banks (4,3,2,1), you have (depending the value of $343) bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want Theses banks can be switches to others set banking RAM or ROM with a flag. You should not use this code, because it's not necessary to use theses routines when you do an orix bank (Kernel provides routines, or facility to call binaries in banks) In the case you need to switch to another bank, you can do this : If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda $321 and # %11111000 ; Do mask for b0,b1, b2 of banking register ora # $04 ; Switch to bank 4 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM mode : sei lda $342 ora # %00100000 ; switch to ram set sta $342 lda $321 and # %11111000 ; Do mask for b0,b1, b2 of banking register ora # $04 ; Switch to bank 4 sta $321 cli if you want to switch to antoher set RAM bank : sei lda # $01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora # %00100000 ; switch to ram set sta $342 lda # $04 ; switch to bank set of ram bank sta $321 cli","title":"Memory management"},{"location":"developer_manual/memory/#memory-management","text":"","title":"Memory management"},{"location":"developer_manual/memory/#hardware-informations","text":"Twilighte board handles 512KB of RAM and 512KB of eeprom","title":"Hardware informations"},{"location":"developer_manual/memory/#orix-roms","text":"Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. XMALLOC primitives only returns pointer from main memory. Kernel can't instanciate extra memory from bank for instance.","title":"Orix Roms"},{"location":"developer_manual/memory/#standalone-rom","text":"Extra memory can be accessed without kernel primitive with simple code The banking management is the same as Telestrat in order to have Orix working on Telestrat too, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility There is a register which contains a set of 4 banks. This register accept values from 0 to 7 : $343. Each value set another set of 4 banks. For example, if $343 contains 2, it will displays others parts of eeprom or SRAM when bit b0, b1, b2 in $321 register contains 4,3,2,1","title":"Standalone ROM"},{"location":"developer_manual/memory/#banking-management-explanation","text":"Switching to another bank should not be done, but the behavior of the card is explained below. For example, a ROM can be loaded into eeprom or ram with orixcfg Some others ROMS (as systemd, or others standalone rom) are loaded on the fly with loader menu. If it needs more ram than the main memory, extended driver is not coded, but it could on the future. Kernel is always reached when $321&7 is equal to 7 . $343 register does not change the behavior of the value set in $321, when $321&7=7 $321&6=6 and $321&5=5. When it's below 5, banks are swapped when register value of $343 change To summarize : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown but for others banks (4,3,2,1), you have (depending the value of $343) bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want Theses banks can be switches to others set banking RAM or ROM with a flag. You should not use this code, because it's not necessary to use theses routines when you do an orix bank (Kernel provides routines, or facility to call binaries in banks) In the case you need to switch to another bank, you can do this : If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda $321 and # %11111000 ; Do mask for b0,b1, b2 of banking register ora # $04 ; Switch to bank 4 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM mode : sei lda $342 ora # %00100000 ; switch to ram set sta $342 lda $321 and # %11111000 ; Do mask for b0,b1, b2 of banking register ora # $04 ; Switch to bank 4 sta $321 cli if you want to switch to antoher set RAM bank : sei lda # $01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora # %00100000 ; switch to ram set sta $342 lda # $04 ; switch to bank set of ram bank sta $321 cli","title":"Banking management explanation"},{"location":"developer_manual/oricutronvsreal/","text":"Oricutron VS real hardware Differencies and issues usb controller is not fully emulated, it means that a lot of commands does not work on the emulation (mainly low usb command) uppercase and lower case for filenames are not managed in oricutron. It means that a code could work on Oricutron but it won't work on real. Every access to sdcard or usbdrive with FAT fileformat must be done with filename and path in uppercase (eg : toto.txt must be sent to the controler like TOTO.TXT)","title":"Oricutron VS real hardware"},{"location":"developer_manual/oricutronvsreal/#oricutron-vs-real-hardware","text":"","title":"Oricutron VS real hardware"},{"location":"developer_manual/oricutronvsreal/#differencies-and-issues","text":"usb controller is not fully emulated, it means that a lot of commands does not work on the emulation (mainly low usb command) uppercase and lower case for filenames are not managed in oricutron. It means that a code could work on Oricutron but it won't work on real. Every access to sdcard or usbdrive with FAT fileformat must be done with filename and path in uppercase (eg : toto.txt must be sent to the controler like TOTO.TXT)","title":"Differencies and issues"},{"location":"developer_manual/orixsdk/","text":"Orix SDK It provides macro to help assembly coding for Orix : https://github.com/assinie/orix-sdk/ The main way to handle orix-sdk is to add it as gitmodules (for example in a \"dependencies folder\") Install in a project mkdir myasmproject cd myasm_project mkdir dependencies && cd dependencies git clone https://github.com/assinie/orix-sdk.git Load Orix SDK you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"dependencies/orix-sdk/macros/SDK.mac\"","title":"Main usage"},{"location":"developer_manual/orixsdk/#orix-sdk","text":"It provides macro to help assembly coding for Orix : https://github.com/assinie/orix-sdk/ The main way to handle orix-sdk is to add it as gitmodules (for example in a \"dependencies folder\")","title":"Orix SDK"},{"location":"developer_manual/orixsdk/#install-in-a-project","text":"mkdir myasmproject cd myasm_project mkdir dependencies && cd dependencies git clone https://github.com/assinie/orix-sdk.git","title":"Install in a project"},{"location":"developer_manual/orixsdk/#load-orix-sdk","text":"you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"dependencies/orix-sdk/macros/SDK.mac\"","title":"Load Orix SDK"},{"location":"developer_manual/pizero_connection/","text":"Pi zero connection You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk. How to install Download img Pi image 'gzip -d' it or use 7zip Download and install Win32 disk imager : DiskImager insert a sdcard into your PC, and write the orixpi.img on the sdcard with Win32 disk imager remove sdcard from the pc and insert it to pizero when Win32 disk imager had finished insert a usb cable in the second usb port (it's really important), and insert usb cable into the PC Wait one minute, your PC should detect a new storage device (it's the pi) in the new device, copy all files you need for Orix (sdcard.tgz content for example) with an text editor, edit on this new mass storage : /etc/pizero/wpa/wpa.cnf and insert the wifi network you use and the password unplug the zero pi and insert it in the usb twilighte board port switch on the oric with the board and wait 1 minutes If everything is ok, you should see your files with \"ls\" and the pizero should be in your wifi network, you can now access to the network folder of pizero from your pc (with the right IP)","title":"Cross development on real hardware"},{"location":"developer_manual/pizero_connection/#pi-zero-connection","text":"You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Pi zero connection"},{"location":"developer_manual/pizero_connection/#how-to-install","text":"Download img Pi image 'gzip -d' it or use 7zip Download and install Win32 disk imager : DiskImager insert a sdcard into your PC, and write the orixpi.img on the sdcard with Win32 disk imager remove sdcard from the pc and insert it to pizero when Win32 disk imager had finished insert a usb cable in the second usb port (it's really important), and insert usb cable into the PC Wait one minute, your PC should detect a new storage device (it's the pi) in the new device, copy all files you need for Orix (sdcard.tgz content for example) with an text editor, edit on this new mass storage : /etc/pizero/wpa/wpa.cnf and insert the wifi network you use and the password unplug the zero pi and insert it in the usb twilighte board port switch on the oric with the board and wait 1 minutes If everything is ok, you should see your files with \"ls\" and the pizero should be in your wifi network, you can now access to the network folder of pizero from your pc (with the right IP)","title":"How to install"},{"location":"developer_manual/relocbin/","text":"Relocation format If you want to generate a relocatable format for orix, follow this link : https://github.com/assinie/orix-sdk/blob/master/README.md","title":"Relocation format"},{"location":"developer_manual/relocbin/#relocation-format","text":"If you want to generate a relocatable format for orix, follow this link : https://github.com/assinie/orix-sdk/blob/master/README.md","title":"Relocation format"},{"location":"developer_manual/orixsdk_macros/cgetc/","text":"cgetc ;---------------------------------------------------------------------- ; usage: ; cgetc ; cgetc var ; ; note: ; - Keycode in A register and var if provided ; ; Call XWR0 ;---------------------------------------------------------------------- cgetc var File : SDK_conio.mac","title":"cgetc"},{"location":"developer_manual/orixsdk_macros/cgetc/#cgetc","text":";---------------------------------------------------------------------- ; usage: ; cgetc ; cgetc var ; ; note: ; - Keycode in A register and var if provided ; ; Call XWR0 ;---------------------------------------------------------------------- cgetc var File : SDK_conio.mac","title":"cgetc"},{"location":"developer_manual/orixsdk_macros/chdir/","text":"CHDIR macro ;---------------------------------------------------------------------- ; ; usage: ; chdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XPUTCWD function ;---------------------------------------------------------------------- chdir myfolder rts myfolder: .asciiz \"home\"","title":"getcwd"},{"location":"developer_manual/orixsdk_macros/chdir/#chdir-macro","text":";---------------------------------------------------------------------- ; ; usage: ; chdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XPUTCWD function ;---------------------------------------------------------------------- chdir myfolder rts myfolder: .asciiz \"home\"","title":"CHDIR macro"},{"location":"developer_manual/orixsdk_macros/cputc/","text":"cputc ;---------------------------------------------------------------------- ; usage: ; cputc ; cputc n ; cputc 'c' ; ; note: ; - no parameter: use the value of A register ; ; Alias for: print #'c' ; ; Call XWR0 ;---------------------------------------------------------------------- cputc char","title":"cputc"},{"location":"developer_manual/orixsdk_macros/cputc/#cputc","text":";---------------------------------------------------------------------- ; usage: ; cputc ; cputc n ; cputc 'c' ; ; note: ; - no parameter: use the value of A register ; ; Alias for: print #'c' ; ; Call XWR0 ;---------------------------------------------------------------------- cputc char","title":"cputc"},{"location":"developer_manual/orixsdk_macros/crlf/","text":"crlf crlf","title":"crlf"},{"location":"developer_manual/orixsdk_macros/crlf/#crlf","text":"crlf","title":"crlf"},{"location":"developer_manual/orixsdk_macros/cursor/","text":"cursor ;---------------------------------------------------------------------- ; ; usage: ; cursor ON|OFF ; ; Call XCSSCR/XCOSCR functions ;---------------------------------------------------------------------- cursor mode","title":"cursor"},{"location":"developer_manual/orixsdk_macros/cursor/#cursor","text":";---------------------------------------------------------------------- ; ; usage: ; cursor ON|OFF ; ; Call XCSSCR/XCOSCR functions ;---------------------------------------------------------------------- cursor mode","title":"cursor"},{"location":"developer_manual/orixsdk_macros/exec/","text":"exec ;---------------------------------------------------------------------- ; ; usage: ; exec command ; ; note: ; command may be : (ptr), address ; ; Call XEXEC function ;---------------------------------------------------------------------- exec command","title":"exec"},{"location":"developer_manual/orixsdk_macros/exec/#exec","text":";---------------------------------------------------------------------- ; ; usage: ; exec command ; ; note: ; command may be : (ptr), address ; ; Call XEXEC function ;---------------------------------------------------------------------- exec command","title":"exec"},{"location":"developer_manual/orixsdk_macros/fclose/","text":"FCLOSE macro ;---------------------------------------------------------------------- ; ; usage: ; fclose (fp) [,TELEMON] ; ; Call XCLOSE function ;----------------------------------------------------------------------","title":"fclose"},{"location":"developer_manual/orixsdk_macros/fclose/#fclose-macro","text":";---------------------------------------------------------------------- ; ; usage: ; fclose (fp) [,TELEMON] ; ; Call XCLOSE function ;----------------------------------------------------------------------","title":"FCLOSE macro"},{"location":"developer_manual/orixsdk_macros/fopen/","text":"FOPEN ;---------------------------------------------------------------------- ; ; usage: ; fopen file, mode [,TELEMON] [,ptr] [,oom_msg_ptr] [,fail_value] ; ; note: ; - file may be: (ptr), address ; - if parameter 'ptr' is present, store resulting AX in ptr & ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AX is $FFFF (ie XOPEN error) ; ; Call XOPEN function ;---------------------------------------------------------------------- ex : .include \"telestrat.inc\" ; from cc65 .include \"fcntl.inc\" ; from cc65 .include \"../dependencies/orix-sdk/macros/SDK_file.mac\" .include \"../dependencies/orix-sdk/macros/SDK_print.mac\" start: fopen ( basic11_ptr2 ), O_RDONLY ,, fp ; open the filename located in ptr 'basic11_ptr2', in readonly and store the fp in fp address cpx # $FF bne @read_maindb ; not null then start because we did not found a conf cmp # $FF bne @read_maindb ; not null then start because we did not found a conf print str_basic11_missing crlf ; Macro for return line lda # $FF ldx # $FF rts fp: .res 2 @read_maindb: ; bla The filename/path address must not be in the rom. If it's the case, the string must be copied into main memory because Kernel overlap the ROM. fopen macro from SDK will produce an error, if the 'address' is in a ROM range (eg : $c000-$FFFF). If you use a ptr, macro can not detect it, and XOPEN primitive won't be able to open your file See XOPEN kernel primitive : XOPEN","title":"fopen"},{"location":"developer_manual/orixsdk_macros/fopen/#fopen","text":";---------------------------------------------------------------------- ; ; usage: ; fopen file, mode [,TELEMON] [,ptr] [,oom_msg_ptr] [,fail_value] ; ; note: ; - file may be: (ptr), address ; - if parameter 'ptr' is present, store resulting AX in ptr & ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AX is $FFFF (ie XOPEN error) ; ; Call XOPEN function ;---------------------------------------------------------------------- ex : .include \"telestrat.inc\" ; from cc65 .include \"fcntl.inc\" ; from cc65 .include \"../dependencies/orix-sdk/macros/SDK_file.mac\" .include \"../dependencies/orix-sdk/macros/SDK_print.mac\" start: fopen ( basic11_ptr2 ), O_RDONLY ,, fp ; open the filename located in ptr 'basic11_ptr2', in readonly and store the fp in fp address cpx # $FF bne @read_maindb ; not null then start because we did not found a conf cmp # $FF bne @read_maindb ; not null then start because we did not found a conf print str_basic11_missing crlf ; Macro for return line lda # $FF ldx # $FF rts fp: .res 2 @read_maindb: ; bla The filename/path address must not be in the rom. If it's the case, the string must be copied into main memory because Kernel overlap the ROM. fopen macro from SDK will produce an error, if the 'address' is in a ROM range (eg : $c000-$FFFF). If you use a ptr, macro can not detect it, and XOPEN primitive won't be able to open your file See XOPEN kernel primitive : XOPEN","title":"FOPEN"},{"location":"developer_manual/orixsdk_macros/fread/","text":"FREAD macro Output A & X returns length in 16 bits ;---------------------------------------------------------------------- ; ; usage: ; fread ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFREAD function ;---------------------------------------------------------------------- Example : fopen ( MAN_SAVE_MALLOC_PTR ), O_RDONLY cpx # $FF bne next cmp # $FF bne next ; Not found rts next: ; Save FP sta MAN_FP stx MAN_FP + 1 fread ( myptr ), 1080 , 1 , MAN_FP ; myptr is from a malloc for example fclose ( MAN_FP )","title":"fread"},{"location":"developer_manual/orixsdk_macros/fread/#fread-macro","text":"","title":"FREAD macro"},{"location":"developer_manual/orixsdk_macros/fread/#output","text":"A & X returns length in 16 bits ;---------------------------------------------------------------------- ; ; usage: ; fread ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFREAD function ;---------------------------------------------------------------------- Example : fopen ( MAN_SAVE_MALLOC_PTR ), O_RDONLY cpx # $FF bne next cmp # $FF bne next ; Not found rts next: ; Save FP sta MAN_FP stx MAN_FP + 1 fread ( myptr ), 1080 , 1 , MAN_FP ; myptr is from a malloc for example fclose ( MAN_FP )","title":"Output"},{"location":"developer_manual/orixsdk_macros/fwrite/","text":"FWRITE macro ;---------------------------------------------------------------------- ; ; usage: ; fwrite ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFWRITE function ;----------------------------------------------------------------------","title":"fwrite"},{"location":"developer_manual/orixsdk_macros/fwrite/#fwrite-macro","text":";---------------------------------------------------------------------- ; ; usage: ; fwrite ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFWRITE function ;----------------------------------------------------------------------","title":"FWRITE macro"},{"location":"developer_manual/orixsdk_macros/getcwd/","text":"getcwd ;---------------------------------------------------------------------- ; ; usage: ; getcwd ptr [,TELEMON] ; ; note: ; ptr may be: ptr, address ; ; Call XGETCWD function ;---------------------------------------------------------------------- .macro getcwd ptr, option pwd : = userzp ; 2 byte getcwd pwd","title":"getcwd"},{"location":"developer_manual/orixsdk_macros/getcwd/#getcwd","text":";---------------------------------------------------------------------- ; ; usage: ; getcwd ptr [,TELEMON] ; ; note: ; ptr may be: ptr, address ; ; Call XGETCWD function ;---------------------------------------------------------------------- .macro getcwd ptr, option pwd : = userzp ; 2 byte getcwd pwd","title":"getcwd"},{"location":"developer_manual/orixsdk_macros/getmainargs/","text":"Getmainargs XMAINARGS = $2C XGETARGV = $2E argv : = userzp ; 2 bytes argc : = userzp + 2 ; 1 byte ; Init struct initmainargs argv , argc , 0 getmainarg # 1 , ( argv ) ; Save the ptr of the parameter sta argv sty argv + 1 BRK_TELEMON XWSTR0 ; Displays the arg 1 from the command line Result (argbin) is binary in assembly with a parameter \"foo\" /#argbin foo foo","title":"getmainargs"},{"location":"developer_manual/orixsdk_macros/getmainargs/#getmainargs","text":"XMAINARGS = $2C XGETARGV = $2E argv : = userzp ; 2 bytes argc : = userzp + 2 ; 1 byte ; Init struct initmainargs argv , argc , 0 getmainarg # 1 , ( argv ) ; Save the ptr of the parameter sta argv sty argv + 1 BRK_TELEMON XWSTR0 ; Displays the arg 1 from the command line Result (argbin) is binary in assembly with a parameter \"foo\" /#argbin foo foo","title":"Getmainargs"},{"location":"developer_manual/orixsdk_macros/initmainargs/","text":"initmainargs Init struct of the mainargs from current process .include \"telestrat.inc\" XMAINARGS = $2C XGETARGV = $2E argv : = userzp ; 2 bytes argc : = userzp + 2 ; 1 byte initmainargs argv , argc , 0 rts","title":"initmainargs"},{"location":"developer_manual/orixsdk_macros/initmainargs/#initmainargs","text":"","title":"initmainargs"},{"location":"developer_manual/orixsdk_macros/initmainargs/#init-struct-of-the-mainargs-from-current-process","text":".include \"telestrat.inc\" XMAINARGS = $2C XGETARGV = $2E argv : = userzp ; 2 bytes argc : = userzp + 2 ; 1 byte initmainargs argv , argc , 0 rts","title":"Init struct of the mainargs from current process"},{"location":"developer_manual/orixsdk_macros/malloc/","text":"Malloc usage: malloc size [,ptr] [,oom_msg_ptr] [,fail_value] malloc #$0100 malloc (ptr) malloc value Note: - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 - if parameter 'oom_msg_ptr' is present, emit string pointed by 'oom_msg_ptr' and return if AY is null (ie malloc error) Call XMALLOC function","title":"malloc"},{"location":"developer_manual/orixsdk_macros/malloc/#malloc","text":"usage: malloc size [,ptr] [,oom_msg_ptr] [,fail_value] malloc #$0100 malloc (ptr) malloc value Note: - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 - if parameter 'oom_msg_ptr' is present, emit string pointed by 'oom_msg_ptr' and return if AY is null (ie malloc error) Call XMALLOC function","title":"Malloc"},{"location":"developer_manual/orixsdk_macros/mfree/","text":"Mfree (free pointer) usage: mfree (ptr) mfree ( mymalloc ) ; mymalloc is a 2 bytes zp ptr rts Call XFREE function.","title":"mfree"},{"location":"developer_manual/orixsdk_macros/mfree/#mfree-free-pointer","text":"usage: mfree (ptr) mfree ( mymalloc ) ; mymalloc is a 2 bytes zp ptr rts Call XFREE function.","title":"Mfree (free pointer)"},{"location":"developer_manual/orixsdk_macros/mkdir/","text":"MKDIR macro ;---------------------------------------------------------------------- ; ; usage: ; mkdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XMKDIR function ;---------------------------------------------------------------------- mkdir myfolder rts myfolder: .asciiz \"here\"","title":"mkdir"},{"location":"developer_manual/orixsdk_macros/mkdir/#mkdir-macro","text":";---------------------------------------------------------------------- ; ; usage: ; mkdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XMKDIR function ;---------------------------------------------------------------------- mkdir myfolder rts myfolder: .asciiz \"here\"","title":"MKDIR macro"},{"location":"developer_manual/orixsdk_macros/print/","text":"Print macro print string in text mode ;---------------------------------------------------------------------- ; ; usage: ; print #byte [,TELEMON|SAVE] ; print (pointer) [,TELEMON|SAVE] ; print address [,TELEMON|SAVE] ; ; Option: ; - TELEMON: when used within TELEMON bank ; - NOSAVE : does not preserve A,X,Y registers ; ; Call XWSTR0 function ; ;---------------------------------------------------------------------- print helloworld_str crlf ; Return line rts helloworld_str: .asciiz \"Hello world!\"","title":"print"},{"location":"developer_manual/orixsdk_macros/print/#print-macro","text":"print string in text mode ;---------------------------------------------------------------------- ; ; usage: ; print #byte [,TELEMON|SAVE] ; print (pointer) [,TELEMON|SAVE] ; print address [,TELEMON|SAVE] ; ; Option: ; - TELEMON: when used within TELEMON bank ; - NOSAVE : does not preserve A,X,Y registers ; ; Call XWSTR0 function ; ;---------------------------------------------------------------------- print helloworld_str crlf ; Return line rts helloworld_str: .asciiz \"Hello world!\"","title":"Print macro"},{"location":"developer_manual/orixsdk_macros/scroll/","text":"scroll macro scroll [Direction],firstline, last_line_to_scroll General case scroll up , 0 , 26 ; Scroll all lines from bottom to the first line : it erases the first line with the second and so open scroll down , 0 , 26 the first line to scroll is computed and is in X register ldx # 3 scroll up ,, 26 ; The second arg is empty because we notice to the macro that it's provided by X register This only work with X register","title":"scroll"},{"location":"developer_manual/orixsdk_macros/scroll/#scroll-macro","text":"scroll [Direction],firstline, last_line_to_scroll","title":"scroll macro"},{"location":"developer_manual/orixsdk_macros/scroll/#general-case","text":"scroll up , 0 , 26 ; Scroll all lines from bottom to the first line : it erases the first line with the second and so open scroll down , 0 , 26","title":"General case"},{"location":"developer_manual/orixsdk_macros/scroll/#the-first-line-to-scroll-is-computed-and-is-in-x-register","text":"ldx # 3 scroll up ,, 26 ; The second arg is empty because we notice to the macro that it's provided by X register This only work with X register","title":"the first line to scroll is computed and is in X register"},{"location":"developer_manual/orixsdk_macros/setscreen/","text":"setscreen ;---------------------------------------------------------------------- ; ; usage: ; setscreen [text|hires] ; ; Call XTEXT/XHIRES functions setscreen mode","title":"setscreen"},{"location":"developer_manual/orixsdk_macros/setscreen/#setscreen","text":";---------------------------------------------------------------------- ; ; usage: ; setscreen [text|hires] ; ; Call XTEXT/XHIRES functions setscreen mode","title":"setscreen"},{"location":"developer_manual/orixsdk_macros/strncat/","text":"strncat concat 2 strings. Strings must be terminated by 0 strncat src, dest, n lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;strncpy(src, dest, n) lda files_type_loader_low sta ptr2 lda files_type_loader_high sta ptr2 + 1 strncat RESB , ptr1 , # 13 dest ptr will be changed by strncat. dest pointer must be saved","title":"strncat"},{"location":"developer_manual/orixsdk_macros/strncat/#strncat","text":"concat 2 strings. Strings must be terminated by 0 strncat src, dest, n lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;strncpy(src, dest, n) lda files_type_loader_low sta ptr2 lda files_type_loader_high sta ptr2 + 1 strncat RESB , ptr1 , # 13 dest ptr will be changed by strncat. dest pointer must be saved","title":"strncat"},{"location":"developer_manual/orixsdk_macros/strncpy/","text":"strncpy ;---------------------------------------------------------------------- ; strncpy src, dest, n ; ; Sortie: ; A: 0 et Z=1 si copie effectu\u00e9e, inchang\u00e9 si non ; X: 0 ; Y: Longueur r\u00e9ellement copi\u00e9e ;---------------------------------------------------------------------- lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;Limit 20 bytes (immediate mode) strncpy(src, dest, n)","title":"strncpy"},{"location":"developer_manual/orixsdk_macros/strncpy/#strncpy","text":";---------------------------------------------------------------------- ; strncpy src, dest, n ; ; Sortie: ; A: 0 et Z=1 si copie effectu\u00e9e, inchang\u00e9 si non ; X: 0 ; Y: Longueur r\u00e9ellement copi\u00e9e ;---------------------------------------------------------------------- lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;Limit 20 bytes (immediate mode) strncpy(src, dest, n)","title":"strncpy"},{"location":"developer_manual/orixsdk_macros/unlink/","text":"UNLINK macro unlink myfile rts myfile: .asciiz \"toto.txt\"","title":"unlink"},{"location":"developer_manual/orixsdk_macros/unlink/#unlink-macro","text":"unlink myfile rts myfile: .asciiz \"toto.txt\"","title":"UNLINK macro"},{"location":"hardware/disk_controler_and_twilighte_board/","text":"Disk controler and twilighte board","title":"Disk controler and twilighte board"},{"location":"hardware/disk_controler_and_twilighte_board/#disk-controler-and-twilighte-board","text":"","title":"Disk controler and twilighte board"},{"location":"hardware/eeprom_structure/","text":"eeprom structure 112KB The eeprom structure is (minimum requirement to boot): First bank (16KB) : empty First bank (16KB) : empty First bank (16KB) : empty First bank (16KB) : empty Shell (16KB) basic11 (16KB) Kernel (16KB)","title":"Eeprom structure"},{"location":"hardware/eeprom_structure/#eeprom-structure","text":"112KB The eeprom structure is (minimum requirement to boot): First bank (16KB) : empty First bank (16KB) : empty First bank (16KB) : empty First bank (16KB) : empty Shell (16KB) basic11 (16KB) Kernel (16KB)","title":"eeprom structure"},{"location":"hardware/hardware_issues/","text":"Hardwares issues Oric does not work with the board See Incompatibilty section The screen is black at the first boot On some Oric, the board does not start at boot time. If you press reset, it should start normally USB mass storage and sdcard compatibility Some tests had been done on some usb mass storage key and sdcard, here is some informations Working sdcard samsung evo 32GB and 16GB samsung evo plus 32GB and 16GB and many others Working usb mass storage Sandisk 32GB pi zero in gadget mode Non working usb mass storage key verbatim 'store and go' 8GB","title":"Hardware issues"},{"location":"hardware/hardware_issues/#hardwares-issues","text":"","title":"Hardwares issues"},{"location":"hardware/hardware_issues/#oric-does-not-work-with-the-board","text":"See Incompatibilty section","title":"Oric does not work with the board"},{"location":"hardware/hardware_issues/#the-screen-is-black-at-the-first-boot","text":"On some Oric, the board does not start at boot time. If you press reset, it should start normally","title":"The screen is black at the first boot"},{"location":"hardware/hardware_issues/#usb-mass-storage-and-sdcard-compatibility","text":"Some tests had been done on some usb mass storage key and sdcard, here is some informations","title":"USB mass storage and sdcard compatibility"},{"location":"hardware/hardware_issues/#working-sdcard","text":"samsung evo 32GB and 16GB samsung evo plus 32GB and 16GB and many others","title":"Working sdcard"},{"location":"hardware/hardware_issues/#working-usb-mass-storage","text":"Sandisk 32GB pi zero in gadget mode","title":"Working usb mass storage"},{"location":"hardware/hardware_issues/#non-working-usb-mass-storage-key","text":"verbatim 'store and go' 8GB","title":"Non working usb mass storage key"},{"location":"hardware/i_o/","text":"I/O The I/O ports can be see also when you type /#ioports $321 register for the id of the bank to switch b0, b1, b2 which can select the id of the bank wanted. $314 register This register is in firmware 2, and can mirror $314 calls to change to overlay memory $342 : twilighte board register b0,b1,b2 version number is equal to 1 or 2, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $343 : Twilighte banking register This register can contains values from 0 to 7 included. It defines the \"set\" of 64KB which be present in slot 4,3,2 and 1 of register $321 which contains the bank.","title":"I/O"},{"location":"hardware/i_o/#io","text":"The I/O ports can be see also when you type /#ioports","title":"I/O"},{"location":"hardware/i_o/#321-register-for-the-id-of-the-bank-to-switch","text":"b0, b1, b2 which can select the id of the bank wanted.","title":"$321 register for the id of the bank to switch"},{"location":"hardware/i_o/#314-register","text":"This register is in firmware 2, and can mirror $314 calls to change to overlay memory","title":"$314 register"},{"location":"hardware/i_o/#342-twilighte-board-register","text":"b0,b1,b2 version number is equal to 1 or 2, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"hardware/i_o/#343-twilighte-banking-register","text":"This register can contains values from 0 to 7 included. It defines the \"set\" of 64KB which be present in slot 4,3,2 and 1 of register $321 which contains the bank.","title":"$343 : Twilighte banking register"},{"location":"hardware/incompatibility_oric/","text":"Board Incompatibility Some oric crashes sometimes with the board. If you have an amplibus (as Silicebit one with 74HCT541), you can plug it in the oric, and insert the expansion board from twilighte board in it, and the twilighte board in this last board. It should solve all Oric compatibility with the board.","title":"Oric incompatibility"},{"location":"hardware/incompatibility_oric/#board-incompatibility","text":"Some oric crashes sometimes with the board. If you have an amplibus (as Silicebit one with 74HCT541), you can plug it in the oric, and insert the expansion board from twilighte board in it, and the twilighte board in this last board. It should solve all Oric compatibility with the board.","title":"Board Incompatibility"},{"location":"hardware/joysticks/","text":"Joysticks Read joysticks states On the board, joysticks works likes Telestrat one's. Right port has 3 buttons Left port has 1 button There is 2 bits to read joysticks states. Bit 7 and 6","title":"Joysticks"},{"location":"hardware/joysticks/#joysticks","text":"","title":"Joysticks"},{"location":"hardware/joysticks/#read-joysticks-states","text":"On the board, joysticks works likes Telestrat one's. Right port has 3 buttons Left port has 1 button There is 2 bits to read joysticks states. Bit 7 and 6","title":"Read joysticks states"},{"location":"hardware/memory/","text":"Memory Twilighte boards handles 512KB of RAM (SRAM) and 512KB of eeprom. Theses RAM and ROM are in banking mode : It replaces the top memory ($c000 to $FFFF) as Overlay ram works with microdisc systems. There is 32 banks of RAMs and 32 banks of ROMs bank command line command can displays the availables banks.","title":"Memory"},{"location":"hardware/memory/#memory","text":"Twilighte boards handles 512KB of RAM (SRAM) and 512KB of eeprom. Theses RAM and ROM are in banking mode : It replaces the top memory ($c000 to $FFFF) as Overlay ram works with microdisc systems. There is 32 banks of RAMs and 32 banks of ROMs bank command line command can displays the availables banks.","title":"Memory"},{"location":"hardware/microdisc_controler/","text":"How to connect a microdisc controler with the twilighte board Solder A14 et A15 on the microdisc controler to ground remove eeprom connect silicebit amplibus on twilighte board expansion port Issues Reset from expansion board does not work, the one on the microdisc controler is working The usb controler in the twilighte board extension refuses to work properly during 20 minutes , you need to wait 20 minutes before trying to use commands on twilighte configuration. Steps Step 1 : Check Drive Check if the switches are ok on the drive : Step 3 : solder A14 and A15 to ground on microdisc to oric connector Step 4 : Remove Eprom See the blue empty connector : the eprom is removed Step 5 : Connect and switch on Connect microdisc controler to the oric with the amplibus like this (Insert Silicebit amplibus into expansion board connector and the ribbon to microdisc controler in silicebit amplibus connector) Connect the drive to microdisc controler Switch on the oric with its own psu Switch on the microdisc controleur with its own psu too The internal usb controler in Twilighte board refuses to work correctly during 20 minutes, in this configuration. Wait a bit. It's a problem with the ribbon cable connected in the amplibus Step 6 : Uses bootfd to start bootsector /#bootfd Step 7 (Optionnal) : Use a pico psu for the microdisc controler If you have a micro psu, you can plug it for your usb controler. You can also buy an connector to plug the micro psu if you want to insert it in a case. The following photo shows the pico psu and the adaptor for pico psu. Solder \"power on\" on the adaptator, in order to have the pico starting plug a 12V PSU (1,5A used during test), in the jack connector of the pico psu","title":"How to connect a microdisc controler with the twilighte board"},{"location":"hardware/microdisc_controler/#how-to-connect-a-microdisc-controler-with-the-twilighte-board","text":"Solder A14 et A15 on the microdisc controler to ground remove eeprom connect silicebit amplibus on twilighte board expansion port","title":"How to connect a microdisc controler with the twilighte board"},{"location":"hardware/microdisc_controler/#issues","text":"Reset from expansion board does not work, the one on the microdisc controler is working The usb controler in the twilighte board extension refuses to work properly during 20 minutes , you need to wait 20 minutes before trying to use commands on twilighte configuration.","title":"Issues"},{"location":"hardware/microdisc_controler/#steps","text":"","title":"Steps"},{"location":"hardware/microdisc_controler/#step-1-check-drive","text":"Check if the switches are ok on the drive :","title":"Step 1 : Check Drive"},{"location":"hardware/microdisc_controler/#step-3-solder-a14-and-a15-to-ground-on-microdisc-to-oric-connector","text":"","title":"Step 3 : solder A14 and A15 to ground on microdisc to oric connector"},{"location":"hardware/microdisc_controler/#step-4-remove-eprom","text":"See the blue empty connector : the eprom is removed","title":"Step 4 : Remove Eprom"},{"location":"hardware/microdisc_controler/#step-5-connect-and-switch-on","text":"Connect microdisc controler to the oric with the amplibus like this (Insert Silicebit amplibus into expansion board connector and the ribbon to microdisc controler in silicebit amplibus connector) Connect the drive to microdisc controler Switch on the oric with its own psu Switch on the microdisc controleur with its own psu too The internal usb controler in Twilighte board refuses to work correctly during 20 minutes, in this configuration. Wait a bit. It's a problem with the ribbon cable connected in the amplibus","title":"Step 5 : Connect and switch on"},{"location":"hardware/microdisc_controler/#step-6-uses-bootfd-to-start-bootsector","text":"/#bootfd","title":"Step 6 : Uses bootfd to start bootsector"},{"location":"hardware/microdisc_controler/#step-7-optionnal-use-a-pico-psu-for-the-microdisc-controler","text":"If you have a micro psu, you can plug it for your usb controler. You can also buy an connector to plug the micro psu if you want to insert it in a case. The following photo shows the pico psu and the adaptor for pico psu. Solder \"power on\" on the adaptator, in order to have the pico starting plug a 12V PSU (1,5A used during test), in the jack connector of the pico psu","title":"Step 7 (Optionnal) : Use a pico psu for the microdisc controler"},{"location":"hardware/nappe/","text":"Ribbon cable management on twilighte board The twilighte board is built without ribbon cable but it can be done with amplibus and a ribbon cable. It works only if there is 2 lines of 74hct541 (see bellow). This trick is also useful for Oric which does not want to start with the board. The board has some incompatibility issue with some oric, but it's can be connected with 2 lines of 74HCT541. One from an amplibus for example, and another from the twilighte board expansion board. First step build the ribbon cable Get a floppy disk ribbon cable. And put a female HE10 34 like this at approximately 13 cms (It could be more, but greater cable is not tested yet)from the previous connector : Put the notch (black connector) at the bottom and crimp the HE10 34 connector (Grey connector) like this : On the picture the notch is not visible on the black connector, because it's on the other side. But the hole on the grey connector is visible. It's really important to keep theses positions. Now we can use any amplibus or another expansion board from the twilighte board with a simple amplibus If you have a amplibus as Silicebit one (see the picture), you can now connect the ribbon cable to these amplibus (Black connector on the previous picture) (notch must be at the bottom as the Silicebit amplibus permits). And plug the grey connector to twilighte board expansion board. The grey connector must be with the hole at the top when connected to expansion board. You have an extra twilighte expansion board if you have this one, you can not connect without a connector modification. The angle connector to the twilighte board side must be to the top of the board. The previous ribbon cable can be connected with the notch at the bottom of the card like the next picture Full overview :","title":"Ribbon cable"},{"location":"hardware/nappe/#ribbon-cable-management-on-twilighte-board","text":"The twilighte board is built without ribbon cable but it can be done with amplibus and a ribbon cable. It works only if there is 2 lines of 74hct541 (see bellow). This trick is also useful for Oric which does not want to start with the board. The board has some incompatibility issue with some oric, but it's can be connected with 2 lines of 74HCT541. One from an amplibus for example, and another from the twilighte board expansion board.","title":"Ribbon cable management on twilighte board"},{"location":"hardware/nappe/#first-step-build-the-ribbon-cable","text":"Get a floppy disk ribbon cable. And put a female HE10 34 like this at approximately 13 cms (It could be more, but greater cable is not tested yet)from the previous connector : Put the notch (black connector) at the bottom and crimp the HE10 34 connector (Grey connector) like this : On the picture the notch is not visible on the black connector, because it's on the other side. But the hole on the grey connector is visible. It's really important to keep theses positions. Now we can use any amplibus or another expansion board from the twilighte board","title":"First step build the ribbon cable"},{"location":"hardware/nappe/#with-a-simple-amplibus","text":"If you have a amplibus as Silicebit one (see the picture), you can now connect the ribbon cable to these amplibus (Black connector on the previous picture) (notch must be at the bottom as the Silicebit amplibus permits). And plug the grey connector to twilighte board expansion board. The grey connector must be with the hole at the top when connected to expansion board.","title":"with a simple amplibus"},{"location":"hardware/nappe/#you-have-an-extra-twilighte-expansion-board","text":"if you have this one, you can not connect without a connector modification. The angle connector to the twilighte board side must be to the top of the board. The previous ribbon cable can be connected with the notch at the bottom of the card like the next picture Full overview :","title":"You have an extra twilighte expansion board"},{"location":"hardware/synth_vocal_mea80900/","text":"Voice synthesizer compatibility Voice synthetizer works with the board. It needs a silicebit amplibus to have the extension working. How to plug with the board","title":"Plug voice synthetizer"},{"location":"hardware/synth_vocal_mea80900/#voice-synthesizer-compatibility","text":"Voice synthetizer works with the board. It needs a silicebit amplibus to have the extension working.","title":"Voice synthesizer compatibility"},{"location":"hardware/synth_vocal_mea80900/#how-to-plug-with-the-board","text":"","title":"How to plug with the board"},{"location":"hardware/ch376/vars8/","text":"CH376 extra vars Vars 8 #define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous - classe du p\u00e9riph\u00e9rique de stockage USB SubClass - Code , le bit 6 est 0 pour indiquer que la sous - classe est 6 et le bit 6 est 1 pour indiquer que la sous - classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l ' \u00e9tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l ' \u00e9tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB , si le bit 5 est 1 , la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB , si le bit 5 est 1 , il y a un p\u00e9riph\u00e9rique USB dans le port USB , et si le bit 5 est 0 , il n ' y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l ' \u00e9tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB . Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu ' il a \u00e9t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0 , il ne r\u00e9essayera pas lorsque NAK est re\u00e7u , le bit 7 est 1 et le bit 6 est 0 , et r\u00e9essayera \u00e0 l ' infini lors de la r\u00e9ception de NAK ( vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative ), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l ' expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0 , l ' indicateur du syst\u00e8me de fichiers FAT du disque logique , 00 - FAT12 , 01 - FAT16 , 10 - FAT32 , 11 - ill\u00e9gal * / / * Bit 2 , indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9t\u00e9 modifi\u00e9es , 0 - non modifi\u00e9 , 1 - modifi\u00e9 * / / * Bit 3 , la longueur du fichier doit \u00eatre modifi\u00e9e , le fichier actuel est ajout\u00e9 avec les donn\u00e9es , 0 - Aucune modification n ' est pas ajout\u00e9e , 1 - Ajout\u00e9 et doit \u00eatre modifi\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0 , version de la carte SD , 0 - prend uniquement en charge la premi\u00e8re version SD , 1 - prend en charge la deuxi\u00e8me version SD * / / * Bit 1 , reconnaissance automatique , carte 0 - SD , carte 1 - MMC * / / * Bit 2 , identification automatique , carte SD de capacit\u00e9 standard 0 , carte SD 1 grande capacit\u00e9 ( HC - SD ) * / / * Bit 4 , d\u00e9lai d ' expiration de la commande ACMD41 * / / * Bit 5 , d\u00e9lai d ' expiration de la commande CMD1 * / / * Bit 6 , d\u00e9lai d ' expiration de la commande CMD58 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0 , doit \u00eatre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4 , le num\u00e9ro d ' unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB , apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB , la valeur par d\u00e9faut est d ' acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0 , le num\u00e9ro d ' unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB , plus 1 est \u00e9gal au nombre d ' unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"CH376 extra vars"},{"location":"hardware/ch376/vars8/#ch376-extra-vars","text":"","title":"CH376 extra vars"},{"location":"hardware/ch376/vars8/#vars-8","text":"#define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous - classe du p\u00e9riph\u00e9rique de stockage USB SubClass - Code , le bit 6 est 0 pour indiquer que la sous - classe est 6 et le bit 6 est 1 pour indiquer que la sous - classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l ' \u00e9tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l ' \u00e9tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB , si le bit 5 est 1 , la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB , si le bit 5 est 1 , il y a un p\u00e9riph\u00e9rique USB dans le port USB , et si le bit 5 est 0 , il n ' y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l ' \u00e9tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB . Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu ' il a \u00e9t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0 , il ne r\u00e9essayera pas lorsque NAK est re\u00e7u , le bit 7 est 1 et le bit 6 est 0 , et r\u00e9essayera \u00e0 l ' infini lors de la r\u00e9ception de NAK ( vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative ), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l ' expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0 , l ' indicateur du syst\u00e8me de fichiers FAT du disque logique , 00 - FAT12 , 01 - FAT16 , 10 - FAT32 , 11 - ill\u00e9gal * / / * Bit 2 , indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9t\u00e9 modifi\u00e9es , 0 - non modifi\u00e9 , 1 - modifi\u00e9 * / / * Bit 3 , la longueur du fichier doit \u00eatre modifi\u00e9e , le fichier actuel est ajout\u00e9 avec les donn\u00e9es , 0 - Aucune modification n ' est pas ajout\u00e9e , 1 - Ajout\u00e9 et doit \u00eatre modifi\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0 , version de la carte SD , 0 - prend uniquement en charge la premi\u00e8re version SD , 1 - prend en charge la deuxi\u00e8me version SD * / / * Bit 1 , reconnaissance automatique , carte 0 - SD , carte 1 - MMC * / / * Bit 2 , identification automatique , carte SD de capacit\u00e9 standard 0 , carte SD 1 grande capacit\u00e9 ( HC - SD ) * / / * Bit 4 , d\u00e9lai d ' expiration de la commande ACMD41 * / / * Bit 5 , d\u00e9lai d ' expiration de la commande CMD1 * / / * Bit 6 , d\u00e9lai d ' expiration de la commande CMD58 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0 , doit \u00eatre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4 , le num\u00e9ro d ' unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB , apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB , la valeur par d\u00e9faut est d ' acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0 , le num\u00e9ro d ' unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB , plus 1 est \u00e9gal au nombre d ' unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"Vars 8"},{"location":"kernel/xvalues/","text":"XVARS Get vars from kernel Get Os string (Orix) XVARS_KERNEL_OSNAME = 9 ldx #XVARS_KERNEL_OSNAME BRK_KERNEL XVARS ; A and X contains","title":"XVARS"},{"location":"kernel/xvalues/#xvars","text":"Get vars from kernel","title":"XVARS"},{"location":"kernel/xvalues/#get-os-string-orix","text":"XVARS_KERNEL_OSNAME = 9 ldx #XVARS_KERNEL_OSNAME BRK_KERNEL XVARS ; A and X contains","title":"Get Os string (Orix)"},{"location":"kernel/primitives/","text":"Summary Kernel calls are done with brk VALUE. Some parameter are set into A,X,Y and some others ones needs to be set in Kernel zp memory. Orix-sdk must be used in order to manage in the right way kernel calls Args from commandline XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct Numbers XBINDX : convert a number to decimal XHEXA : convert a number to hexadecimal and printit XDECIM : display a number to the output XDECAY : Convert a string into a number (16 bits) Memory XMALLOC : allocate memory from main memory XFREE : free memory Files XOPEN : Open a file XWRITE : Write bytes to file XFREAD : read bytes from file XCLOSE : Close file XFSEEK : Seek into files XMKDIR : Create a folder XGETCWD : get current path XPUTCWD : change current path XOPENDIR : opendir XREADDIR : readdir (return a struct with the files) XCLOSEDIR : readdir (return a struct with the files) XRM : remove file Text mode XWSTR0 : Display a string XSCROB : scroll from bottom to top XSCROH : scroll from top to bottom Graphic mode XHIRES : start graphic mode Execute XEXEC : Execute binary Keyboard XRDW0 : Get a char from keyboard (wait for a key) XRD0 : check if a char is typed on the keyboard (continue execution) Kernel values XVALUES XVARS","title":"General list"},{"location":"kernel/primitives/#summary","text":"Kernel calls are done with brk VALUE. Some parameter are set into A,X,Y and some others ones needs to be set in Kernel zp memory. Orix-sdk must be used in order to manage in the right way kernel calls","title":"Summary"},{"location":"kernel/primitives/#args-from-commandline","text":"XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct","title":"Args from commandline"},{"location":"kernel/primitives/#numbers","text":"XBINDX : convert a number to decimal XHEXA : convert a number to hexadecimal and printit XDECIM : display a number to the output XDECAY : Convert a string into a number (16 bits)","title":"Numbers"},{"location":"kernel/primitives/#memory","text":"XMALLOC : allocate memory from main memory XFREE : free memory","title":"Memory"},{"location":"kernel/primitives/#files","text":"XOPEN : Open a file XWRITE : Write bytes to file XFREAD : read bytes from file XCLOSE : Close file XFSEEK : Seek into files XMKDIR : Create a folder XGETCWD : get current path XPUTCWD : change current path XOPENDIR : opendir XREADDIR : readdir (return a struct with the files) XCLOSEDIR : readdir (return a struct with the files) XRM : remove file","title":"Files"},{"location":"kernel/primitives/#text-mode","text":"XWSTR0 : Display a string XSCROB : scroll from bottom to top XSCROH : scroll from top to bottom","title":"Text mode"},{"location":"kernel/primitives/#graphic-mode","text":"XHIRES : start graphic mode","title":"Graphic mode"},{"location":"kernel/primitives/#execute","text":"XEXEC : Execute binary","title":"Execute"},{"location":"kernel/primitives/#keyboard","text":"XRDW0 : Get a char from keyboard (wait for a key) XRD0 : check if a char is typed on the keyboard (continue execution)","title":"Keyboard"},{"location":"kernel/primitives/#kernel-values","text":"XVALUES XVARS","title":"Kernel values"},{"location":"kernel/primitives/xbindx/","text":"XBINDX (16 bit number to decimal) Description convert A & Y number into decimal string Input A & Y the 16 bits value TR5 the pointer of the address to put decimal number (String) DEFAFF : space before the number Output A, TR4, TR5 Example 1 : Displays value AY (16 bits number) in $bb80 text mode lda # < $bb80 sta TR5 lda # > $bb80 sta TR5 + 1 lda # $20 sta DEFAFF ldx # $01 ldy # $00 lda # $10 BRK_KERNEL XBINDX rts","title":"XBINDX (16 bit number to decimal)"},{"location":"kernel/primitives/xbindx/#xbindx-16-bit-number-to-decimal","text":"","title":"XBINDX (16 bit number to decimal)"},{"location":"kernel/primitives/xbindx/#description","text":"convert A & Y number into decimal string","title":"Description"},{"location":"kernel/primitives/xbindx/#input","text":"A & Y the 16 bits value TR5 the pointer of the address to put decimal number (String) DEFAFF : space before the number","title":"Input"},{"location":"kernel/primitives/xbindx/#output","text":"A, TR4, TR5","title":"Output"},{"location":"kernel/primitives/xbindx/#example-1-displays-value-ay-16-bits-number-in-bb80-text-mode","text":"lda # < $bb80 sta TR5 lda # > $bb80 sta TR5 + 1 lda # $20 sta DEFAFF ldx # $01 ldy # $00 lda # $10 BRK_KERNEL XBINDX rts","title":"Example 1 : Displays value AY (16 bits number) in $bb80 text mode"},{"location":"kernel/primitives/xclose/","text":"XCLOSE Description Close file Input A : fd Output Modify RESB Samples Example lda # MYFD BRK_KERNEL XCLOSE See fclose macro from orix-sdk to use it","title":"XCLOSE"},{"location":"kernel/primitives/xclose/#xclose","text":"","title":"XCLOSE"},{"location":"kernel/primitives/xclose/#description","text":"Close file","title":"Description"},{"location":"kernel/primitives/xclose/#input","text":"A : fd","title":"Input"},{"location":"kernel/primitives/xclose/#output","text":"","title":"Output"},{"location":"kernel/primitives/xclose/#modify","text":"RESB","title":"Modify"},{"location":"kernel/primitives/xclose/#samples","text":"","title":"Samples"},{"location":"kernel/primitives/xclose/#example","text":"lda # MYFD BRK_KERNEL XCLOSE See fclose macro from orix-sdk to use it","title":"Example"},{"location":"kernel/primitives/xclosedir/","text":"XCLOSEDIR","title":"XCLOSEDIR"},{"location":"kernel/primitives/xclosedir/#xclosedir","text":"","title":"XCLOSEDIR"},{"location":"kernel/primitives/xdecay/","text":"XDECAY Convert a string into number A et Y contains the ptr of the string XDECAY returns the value (16 bits) in AY and X contains the length of the decimal number provided in the input lda # < mystring ldy # > mystring BRK_KERNEL XDECAY ; A and Y contains the 16 bits value ; X contains the length of chars in mystring rts mystring: .asciiz \"125\"","title":"XDECAY"},{"location":"kernel/primitives/xdecay/#xdecay","text":"Convert a string into number A et Y contains the ptr of the string XDECAY returns the value (16 bits) in AY and X contains the length of the decimal number provided in the input lda # < mystring ldy # > mystring BRK_KERNEL XDECAY ; A and Y contains the 16 bits value ; X contains the length of chars in mystring rts mystring: .asciiz \"125\"","title":"XDECAY"},{"location":"kernel/primitives/xdecim/","text":"XDECIM Displays an integer into the the screen ldy # $00 ldx # $20 ; stx DEFAFF ldx # $00 BRK_KERNEL XDECIM rts","title":"XDECIM"},{"location":"kernel/primitives/xdecim/#xdecim","text":"Displays an integer into the the screen ldy # $00 ldx # $20 ; stx DEFAFF ldx # $00 BRK_KERNEL XDECIM rts","title":"XDECIM"},{"location":"kernel/primitives/xexec/","text":"XEXEC Description Start a binary (located in a ROM or on the current device) Input A & Y the ptr of the string. Output Returns an error if the binary is not found Modify RES, RESB (kernel_create_process), TR0, TR1, TR4 (kernel_create_process), TR5 (kernel_create_process) KERNEL_ERRNO (kernel_create_process), KERNEL_XKERNEL_CREATE_PROCESS_TMP (kernel_create_process),kernel_process_struct::kernel_pid_list (kernel_create_process) DECDEB, DECFIN, DECCIB,DECTRV,ACC1M VEXBNK, BUFEDT, BNKOLD, KERNEL_TMP_XEXEC, BNK_TO_SWITCH, KERNEL_KERNEL_XEXEC_BNKOLD Example lda # < str ldy # > str ldx # $00 ; Fork BRK_KERNEL XEXEC rts str: .asciiz \"mybin\" XEXEC does not manage './' or '../' before kernel v2023.2 ./ calls and /mypath/mybinary calls are available since kernel v2023.2, but '../' is not available","title":"XEXEC"},{"location":"kernel/primitives/xexec/#xexec","text":"","title":"XEXEC"},{"location":"kernel/primitives/xexec/#description","text":"Start a binary (located in a ROM or on the current device)","title":"Description"},{"location":"kernel/primitives/xexec/#input","text":"A & Y the ptr of the string.","title":"Input"},{"location":"kernel/primitives/xexec/#output","text":"Returns an error if the binary is not found","title":"Output"},{"location":"kernel/primitives/xexec/#modify","text":"RES, RESB (kernel_create_process), TR0, TR1, TR4 (kernel_create_process), TR5 (kernel_create_process) KERNEL_ERRNO (kernel_create_process), KERNEL_XKERNEL_CREATE_PROCESS_TMP (kernel_create_process),kernel_process_struct::kernel_pid_list (kernel_create_process) DECDEB, DECFIN, DECCIB,DECTRV,ACC1M VEXBNK, BUFEDT, BNKOLD, KERNEL_TMP_XEXEC, BNK_TO_SWITCH, KERNEL_KERNEL_XEXEC_BNKOLD","title":"Modify"},{"location":"kernel/primitives/xexec/#example","text":"lda # < str ldy # > str ldx # $00 ; Fork BRK_KERNEL XEXEC rts str: .asciiz \"mybin\" XEXEC does not manage './' or '../' before kernel v2023.2 ./ calls and /mypath/mybinary calls are available since kernel v2023.2, but '../' is not available","title":"Example"},{"location":"kernel/primitives/xfread/","text":"XCLOSE Description Read byte from files Input AY contains the length to read PTR_READ_DEST must be set because it's the ptr_dest X contains the fd id Output A & X contains the length read Samples Example lda # < $A000 sta PTR_READ_DEST lda # > $A000 sta PTR_READ_DEST + 1 lda # < 12 ; Read 12 bytes ldy # > 12 ; REad 12 bytes ldx fp BRK_KERNEL XFREAD rts See fread macro from orix-sdk to use it XFREAD does not manage multiples opened files before kernel 2022.4","title":"XFREAD"},{"location":"kernel/primitives/xfread/#xclose","text":"","title":"XCLOSE"},{"location":"kernel/primitives/xfread/#description","text":"Read byte from files","title":"Description"},{"location":"kernel/primitives/xfread/#input","text":"AY contains the length to read PTR_READ_DEST must be set because it's the ptr_dest X contains the fd id","title":"Input"},{"location":"kernel/primitives/xfread/#output","text":"A & X contains the length read","title":"Output"},{"location":"kernel/primitives/xfread/#samples","text":"","title":"Samples"},{"location":"kernel/primitives/xfread/#example","text":"lda # < $A000 sta PTR_READ_DEST lda # > $A000 sta PTR_READ_DEST + 1 lda # < 12 ; Read 12 bytes ldy # > 12 ; REad 12 bytes ldx fp BRK_KERNEL XFREAD rts See fread macro from orix-sdk to use it XFREAD does not manage multiples opened files before kernel 2022.4","title":"Example"},{"location":"kernel/primitives/xfree/","text":"XFREE Description Free memory Input A&Y : ptr Output Samples Example lda ptr ldy ptr + 1 BRK_KERNEL XFREE See free macro from orix-sdk to use it XFREE still have bugs for versions before kernel v2022.2","title":"XFREE"},{"location":"kernel/primitives/xfree/#xfree","text":"","title":"XFREE"},{"location":"kernel/primitives/xfree/#description","text":"Free memory","title":"Description"},{"location":"kernel/primitives/xfree/#input","text":"A&Y : ptr","title":"Input"},{"location":"kernel/primitives/xfree/#output","text":"","title":"Output"},{"location":"kernel/primitives/xfree/#samples","text":"","title":"Samples"},{"location":"kernel/primitives/xfree/#example","text":"lda ptr ldy ptr + 1 BRK_KERNEL XFREE See free macro from orix-sdk to use it XFREE still have bugs for versions before kernel v2022.2","title":"Example"},{"location":"kernel/primitives/xfseek/","text":"XFSEEK Available in kernel 2022.2 Description Seek into file Input X whence AY : position 0 to 15 bits (word) RESB : position 16 to 32 bits(word) RES : fd (but only I byte is managed) Output Return A=EINVAL if whence is not recognize Return A=EOK if seek has been performed Return A=$FF if something is wrong when seek has performed Code Example ; Move to $20 bytes in the file from the current position ; [IN] X whence ; [IN] AY position 0 to 15 ; [IN] RESB position 0 to 31 ; [IN] RES fd ldy # $10 lda # $00 tax sta RESB sta RESB + 1 lda fp ldx # SEEK_CUR BRK_TELEMON XFSEEK XFSEEK is available since kernel v2022.2 XFSEEK have bugs for SEEK_CUR in 2022.4.1 (fixed in kernel 2023.1) XFSEEK does not manage SEEK_END","title":"XFSEEK"},{"location":"kernel/primitives/xfseek/#xfseek","text":"Available in kernel 2022.2","title":"XFSEEK"},{"location":"kernel/primitives/xfseek/#description","text":"Seek into file","title":"Description"},{"location":"kernel/primitives/xfseek/#input","text":"X whence AY : position 0 to 15 bits (word) RESB : position 16 to 32 bits(word) RES : fd (but only I byte is managed)","title":"Input"},{"location":"kernel/primitives/xfseek/#output","text":"Return A=EINVAL if whence is not recognize Return A=EOK if seek has been performed Return A=$FF if something is wrong when seek has performed","title":"Output"},{"location":"kernel/primitives/xfseek/#code","text":"","title":"Code"},{"location":"kernel/primitives/xfseek/#example","text":"; Move to $20 bytes in the file from the current position ; [IN] X whence ; [IN] AY position 0 to 15 ; [IN] RESB position 0 to 31 ; [IN] RES fd ldy # $10 lda # $00 tax sta RESB sta RESB + 1 lda fp ldx # SEEK_CUR BRK_TELEMON XFSEEK XFSEEK is available since kernel v2022.2 XFSEEK have bugs for SEEK_CUR in 2022.4.1 (fixed in kernel 2023.1) XFSEEK does not manage SEEK_END","title":"Example"},{"location":"kernel/primitives/xgetargv/","text":"XGETARGV Description Get argv. X register contains the number of the arg search Kernel handle a struct with XMAINARGS. This struct is handled by Kernel, and no action are required in external code, but here is how struct works : .struct XMAINARGS_STRUCT argv_ptr .res KERNEL_MAX_ARGS_COMMAND_LINE argv_value_ptr .res KERNEL_LENGTH_MAX_CMDLINE + KERNEL_MAX_ARGS_COMMAND_LINE ; add 0 to string .endstruct argv_ptr contains an offset of each param. It means that we can't have a length of args greater than 256. XMAINARGS and XGETARGV does not handle \"\" yet and \" \" Input A & Y the ptr of struct from XMAINARGS X the number of arg to get, first param is 0 not 1 ! Output A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed Example XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr + 1 ldx # $02 ; get arg 2 ; Get the third param lda debug_mainargs_ptr ldy debug_mainargs_ptr + 1 BRK_KERNEL XGETARGV ; A & Y contains ptr","title":"XGETARGV"},{"location":"kernel/primitives/xgetargv/#xgetargv","text":"","title":"XGETARGV"},{"location":"kernel/primitives/xgetargv/#description","text":"Get argv. X register contains the number of the arg search Kernel handle a struct with XMAINARGS. This struct is handled by Kernel, and no action are required in external code, but here is how struct works : .struct XMAINARGS_STRUCT argv_ptr .res KERNEL_MAX_ARGS_COMMAND_LINE argv_value_ptr .res KERNEL_LENGTH_MAX_CMDLINE + KERNEL_MAX_ARGS_COMMAND_LINE ; add 0 to string .endstruct argv_ptr contains an offset of each param. It means that we can't have a length of args greater than 256. XMAINARGS and XGETARGV does not handle \"\" yet and \" \"","title":"Description"},{"location":"kernel/primitives/xgetargv/#input","text":"A & Y the ptr of struct from XMAINARGS X the number of arg to get, first param is 0 not 1 !","title":"Input"},{"location":"kernel/primitives/xgetargv/#output","text":"A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed","title":"Output"},{"location":"kernel/primitives/xgetargv/#example","text":"XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr + 1 ldx # $02 ; get arg 2 ; Get the third param lda debug_mainargs_ptr ldy debug_mainargs_ptr + 1 BRK_KERNEL XGETARGV ; A & Y contains ptr","title":"Example"},{"location":"kernel/primitives/xgetcwd/","text":"XGETCWD (getcwd) Description Return current directory of the process Input Output A andY returns a ptr of the string Example BRK_KERNEL XGETCWD BRK_KERNEL XWSTR0 rts Memory usage zeropage RESB","title":"XGETCWD (getcwd)"},{"location":"kernel/primitives/xgetcwd/#xgetcwd-getcwd","text":"","title":"XGETCWD (getcwd)"},{"location":"kernel/primitives/xgetcwd/#description","text":"Return current directory of the process","title":"Description"},{"location":"kernel/primitives/xgetcwd/#input","text":"","title":"Input"},{"location":"kernel/primitives/xgetcwd/#output","text":"A andY returns a ptr of the string","title":"Output"},{"location":"kernel/primitives/xgetcwd/#example","text":"BRK_KERNEL XGETCWD BRK_KERNEL XWSTR0 rts","title":"Example"},{"location":"kernel/primitives/xgetcwd/#memory-usage","text":"","title":"Memory usage"},{"location":"kernel/primitives/xgetcwd/#zeropage","text":"RESB","title":"zeropage"},{"location":"kernel/primitives/xhexa/","text":"XHEXA Convert a number in A and returns hexadecimal to AY Samples Example lda # $FF BRK_KERNEL XHEXA ; A = 'F' ; Y = 'F' rts","title":"XHEXA"},{"location":"kernel/primitives/xhexa/#xhexa","text":"Convert a number in A and returns hexadecimal to AY","title":"XHEXA"},{"location":"kernel/primitives/xhexa/#samples","text":"","title":"Samples"},{"location":"kernel/primitives/xhexa/#example","text":"lda # $FF BRK_KERNEL XHEXA ; A = 'F' ; Y = 'F' rts","title":"Example"},{"location":"kernel/primitives/xhires/","text":"XHIRES Switch to Hires Samples Example ldx # $00 BRK_KERNEL XHIRES rts","title":"XHIRES"},{"location":"kernel/primitives/xhires/#xhires","text":"Switch to Hires","title":"XHIRES"},{"location":"kernel/primitives/xhires/#samples","text":"","title":"Samples"},{"location":"kernel/primitives/xhires/#example","text":"ldx # $00 BRK_KERNEL XHIRES rts","title":"Example"},{"location":"kernel/primitives/xmainargs/","text":"XMAINARGS (argmains) ID primitive : $2C Description Return argc and argv or a ptr with a content of the command line Input A => mode mode 0 : return a struct of args mode 1 : return the string of the command line (ptr) Output Mode 0 : A & Y :contains ptr to XMAINARGS Struct X: number of args Mode 1 : A & Y : a ptr to a new malloc which contains commandline Usage Mode 0 : parse command line and build argc/argv XMAINARGS = $2C lda # $00 ; Mode 0 BRK_TELEMON XMAINARGS stx save_argc sta save_argv sty save_argv + 1 rts Mode 1 : return command line XMAINARGS = $2C lda # $01 ; Mode 0 BRK_TELEMON XMAINARGS sta ptr_cmd sty ptr_cmd + 1 ; ptr_cmd contains the ptr to the command line. It allocates a string, it needs to be free when the program does not need it anymore rts See initmainargs macro from orix-sdk to use it XMAINARGS allocates a chunk in memory, it must be free at the end of the use of the parameters Mode 0 is available since v2022.4 XGETARGV does not handle \"\" yet and \" in parameters","title":"XMAINARGS"},{"location":"kernel/primitives/xmainargs/#xmainargs-argmains","text":"ID primitive : $2C","title":"XMAINARGS (argmains)"},{"location":"kernel/primitives/xmainargs/#description","text":"Return argc and argv or a ptr with a content of the command line","title":"Description"},{"location":"kernel/primitives/xmainargs/#input","text":"A => mode mode 0 : return a struct of args mode 1 : return the string of the command line (ptr)","title":"Input"},{"location":"kernel/primitives/xmainargs/#output","text":"Mode 0 : A & Y :contains ptr to XMAINARGS Struct X: number of args Mode 1 : A & Y : a ptr to a new malloc which contains commandline","title":"Output"},{"location":"kernel/primitives/xmainargs/#usage","text":"Mode 0 : parse command line and build argc/argv XMAINARGS = $2C lda # $00 ; Mode 0 BRK_TELEMON XMAINARGS stx save_argc sta save_argv sty save_argv + 1 rts Mode 1 : return command line XMAINARGS = $2C lda # $01 ; Mode 0 BRK_TELEMON XMAINARGS sta ptr_cmd sty ptr_cmd + 1 ; ptr_cmd contains the ptr to the command line. It allocates a string, it needs to be free when the program does not need it anymore rts See initmainargs macro from orix-sdk to use it XMAINARGS allocates a chunk in memory, it must be free at the end of the use of the parameters Mode 0 is available since v2022.4 XGETARGV does not handle \"\" yet and \" in parameters","title":"Usage"},{"location":"kernel/primitives/xmalloc/","text":"XMALLOC (malloc) Description Allocate memory. Use orix-sdk with macro to handle XMALLOC Input A and Y : number of bytes Output A&Y = $0000 : OOM or others errors else A&Y : ptr Usage lda # < 4000 ldy # > 4000 BRK_TELEMON XMALLOC ; A & Y contains a ptr rts See malloc macro from orix-sdk to use it easily Number of malloc are limited in kernel side for all programs running","title":"XMALLOC"},{"location":"kernel/primitives/xmalloc/#xmalloc-malloc","text":"","title":"XMALLOC (malloc)"},{"location":"kernel/primitives/xmalloc/#description","text":"Allocate memory. Use orix-sdk with macro to handle XMALLOC","title":"Description"},{"location":"kernel/primitives/xmalloc/#input","text":"A and Y : number of bytes","title":"Input"},{"location":"kernel/primitives/xmalloc/#output","text":"A&Y = $0000 : OOM or others errors else A&Y : ptr","title":"Output"},{"location":"kernel/primitives/xmalloc/#usage","text":"lda # < 4000 ldy # > 4000 BRK_TELEMON XMALLOC ; A & Y contains a ptr rts See malloc macro from orix-sdk to use it easily Number of malloc are limited in kernel side for all programs running","title":"Usage"},{"location":"kernel/primitives/xmkdir/","text":"XMKDIR (mkdir) ID primitive : $4B Description Create a folder. But it does not support absolute path for instance. It can only create path in the current path. Input A and Y : ptr of the string Output Return #ENODEV if the device can't be mount Usage lda # < str ldy # > str ldx # $00 BRK_TELEMON XMKDIR rts str: .asciiz \"myfolder\"","title":"XMKDIR"},{"location":"kernel/primitives/xmkdir/#xmkdir-mkdir","text":"ID primitive : $4B","title":"XMKDIR (mkdir)"},{"location":"kernel/primitives/xmkdir/#description","text":"Create a folder. But it does not support absolute path for instance. It can only create path in the current path.","title":"Description"},{"location":"kernel/primitives/xmkdir/#input","text":"A and Y : ptr of the string","title":"Input"},{"location":"kernel/primitives/xmkdir/#output","text":"Return #ENODEV if the device can't be mount","title":"Output"},{"location":"kernel/primitives/xmkdir/#usage","text":"lda # < str ldy # > str ldx # $00 BRK_TELEMON XMKDIR rts str: .asciiz \"myfolder\"","title":"Usage"},{"location":"kernel/primitives/xopen/","text":"XOPEN Description open a file Input Y : flag open mode A&X : path filename Output AX contains $FF if it does not exists A : FD id if file is found Modify RES, A X Y, XOPEN_SAVE XOPEN_FLAGS, XOPEN_RES_SAVE, XOPEN_SAVEA with XMALLOC call TR7 Internal kernel calls XMALLOC create_file_pointer Changelog Since kernel 2022.2 Flag | File exists | behaviour O_WRONLY | No | return Null O_WRONLY | Yes | open and return FD O_RDONLY | Yes | open and return FD O_WRONLY | No | return Null O_CREAT | No | Create file and open and return FD O_CREAT | Yes | open and return FD Usage lda # < str ldx # > str ldy # O_CREAT BRK_TELEMON XOPEN rts str: .asciiz \"myfile\" See fopen macro from orix-sdk to use it XOPEN does not manage './' or '../' calls Multiples opened files are working since kernel 2022.2 Max 2 opened files are working since kernel 2022.2, it's a constant defined in kernel build Flags behaviors since kernel 2023.1 Flag File exists Behaviour O_WRONLY & O_CREAT No Create file, open and return FD O_WRONLY No return Null (Changed since kernel 2023.1) O_WRONLY Yes open and return FD O_RDONLY Yes open and return FD O_WRONLY No return Null O_CREAT No Create file and open and return FD O_CREAT Yes open and return FD Flags behaviors before kernel 2023.1 Flag File exists Behaviour O_WRONLY & O_CREAT No Create file, open and return FD O_WRONLY No open and return FD O_WRONLY Yes open and return FD O_RDONLY Yes open and return FD O_WRONLY No return Null O_CREAT No Create file and open and return FD O_CREAT Yes open and return FD","title":"XOPEN"},{"location":"kernel/primitives/xopen/#xopen","text":"","title":"XOPEN"},{"location":"kernel/primitives/xopen/#description","text":"open a file","title":"Description"},{"location":"kernel/primitives/xopen/#input","text":"Y : flag open mode A&X : path filename","title":"Input"},{"location":"kernel/primitives/xopen/#output","text":"AX contains $FF if it does not exists A : FD id if file is found","title":"Output"},{"location":"kernel/primitives/xopen/#modify","text":"RES, A X Y, XOPEN_SAVE XOPEN_FLAGS, XOPEN_RES_SAVE, XOPEN_SAVEA with XMALLOC call TR7","title":"Modify"},{"location":"kernel/primitives/xopen/#internal-kernel-calls","text":"XMALLOC create_file_pointer","title":"Internal kernel calls"},{"location":"kernel/primitives/xopen/#changelog","text":"","title":"Changelog"},{"location":"kernel/primitives/xopen/#since-kernel-20222","text":"Flag | File exists | behaviour O_WRONLY | No | return Null O_WRONLY | Yes | open and return FD O_RDONLY | Yes | open and return FD O_WRONLY | No | return Null O_CREAT | No | Create file and open and return FD O_CREAT | Yes | open and return FD","title":"Since kernel 2022.2"},{"location":"kernel/primitives/xopen/#usage","text":"lda # < str ldx # > str ldy # O_CREAT BRK_TELEMON XOPEN rts str: .asciiz \"myfile\" See fopen macro from orix-sdk to use it XOPEN does not manage './' or '../' calls Multiples opened files are working since kernel 2022.2 Max 2 opened files are working since kernel 2022.2, it's a constant defined in kernel build Flags behaviors since kernel 2023.1 Flag File exists Behaviour O_WRONLY & O_CREAT No Create file, open and return FD O_WRONLY No return Null (Changed since kernel 2023.1) O_WRONLY Yes open and return FD O_RDONLY Yes open and return FD O_WRONLY No return Null O_CREAT No Create file and open and return FD O_CREAT Yes open and return FD Flags behaviors before kernel 2023.1 Flag File exists Behaviour O_WRONLY & O_CREAT No Create file, open and return FD O_WRONLY No open and return FD O_WRONLY Yes open and return FD O_RDONLY Yes open and return FD O_WRONLY No return Null O_CREAT No Create file and open and return FD O_CREAT Yes open and return FD","title":"Usage"},{"location":"kernel/primitives/xopendir/","text":"XOPENDIR Description Open a folder Input A & X : string Output A : fd Example 1 : Openfolder /bin ldx # $00 ; XOPENDIR Mode lda # < opendir ldy # > opendir BRK_TELEMON $2F cmp # $FF bne @ok cpx # $FF bne @ok print str_error rts @ok: ; Save ptr rts opendir: asciiz \"/bin\" XOPENDIR is in beta mode and close current open file : it brokes any fopen files.","title":"XOPENDIR"},{"location":"kernel/primitives/xopendir/#xopendir","text":"","title":"XOPENDIR"},{"location":"kernel/primitives/xopendir/#description","text":"Open a folder","title":"Description"},{"location":"kernel/primitives/xopendir/#input","text":"A & X : string","title":"Input"},{"location":"kernel/primitives/xopendir/#output","text":"A : fd","title":"Output"},{"location":"kernel/primitives/xopendir/#example-1-openfolder-bin","text":"ldx # $00 ; XOPENDIR Mode lda # < opendir ldy # > opendir BRK_TELEMON $2F cmp # $FF bne @ok cpx # $FF bne @ok print str_error rts @ok: ; Save ptr rts opendir: asciiz \"/bin\" XOPENDIR is in beta mode and close current open file : it brokes any fopen files.","title":"Example 1 : Openfolder /bin"},{"location":"kernel/primitives/xputcwd/","text":"XPUTCWD (chdir) Description Change current process directory Input A & Y the 16 bits values (string with \\0) Output N/A Example lda # < str ldy # > str BRK_KERNEL XPUTCWD rts str: .asciiz \"/etc\"","title":"XPUTCWD (chdir)"},{"location":"kernel/primitives/xputcwd/#xputcwd-chdir","text":"","title":"XPUTCWD (chdir)"},{"location":"kernel/primitives/xputcwd/#description","text":"Change current process directory","title":"Description"},{"location":"kernel/primitives/xputcwd/#input","text":"A & Y the 16 bits values (string with \\0)","title":"Input"},{"location":"kernel/primitives/xputcwd/#output","text":"N/A","title":"Output"},{"location":"kernel/primitives/xputcwd/#example","text":"lda # < str ldy # > str BRK_KERNEL XPUTCWD rts str: .asciiz \"/etc\"","title":"Example"},{"location":"kernel/primitives/xrd0/","text":"XRD0 Check if a key is pressed BRK_KERNEL XRD0 ; primitive exits even if no key had been pressed bcs @no_key_pressed ; When a key is pressed, A contains the ascii of the value @here_a_key_is_pressed: rts @no_key_pressed: rts","title":"XRD0"},{"location":"kernel/primitives/xrd0/#xrd0","text":"Check if a key is pressed BRK_KERNEL XRD0 ; primitive exits even if no key had been pressed bcs @no_key_pressed ; When a key is pressed, A contains the ascii of the value @here_a_key_is_pressed: rts @no_key_pressed: rts","title":"XRD0"},{"location":"kernel/primitives/xrdw0/","text":"XRDW0 Wait a key from the keyboard BRK_KERNEL XRDW0 ; When a key is pressed, A contains the ascii of the value","title":"XRDW0"},{"location":"kernel/primitives/xrdw0/#xrdw0","text":"Wait a key from the keyboard BRK_KERNEL XRDW0 ; When a key is pressed, A contains the ascii of the value","title":"XRDW0"},{"location":"kernel/primitives/xreaddir/","text":"XREADDIR Read current folder and returns all entry in AY. It returns max : 100 entry (READDIR_MAX_LINE = 100 values in kernel) Example ldx # $01 ; XREADDIR MODE Mode BRK_TELEMON $2F rts @ok: ; Save ptr rts XREADDIR returns a ptr","title":"XREADDIR"},{"location":"kernel/primitives/xreaddir/#xreaddir","text":"Read current folder and returns all entry in AY. It returns max : 100 entry (READDIR_MAX_LINE = 100 values in kernel)","title":"XREADDIR"},{"location":"kernel/primitives/xreaddir/#example","text":"ldx # $01 ; XREADDIR MODE Mode BRK_TELEMON $2F rts @ok: ; Save ptr rts XREADDIR returns a ptr","title":"Example"},{"location":"kernel/primitives/xrm/","text":"XRM Description Remove file in arg Input Output Samples Example","title":"XRM"},{"location":"kernel/primitives/xrm/#xrm","text":"","title":"XRM"},{"location":"kernel/primitives/xrm/#description","text":"Remove file in arg","title":"Description"},{"location":"kernel/primitives/xrm/#input","text":"","title":"Input"},{"location":"kernel/primitives/xrm/#output","text":"","title":"Output"},{"location":"kernel/primitives/xrm/#samples","text":"","title":"Samples"},{"location":"kernel/primitives/xrm/#example","text":"","title":"Example"},{"location":"kernel/primitives/xscrob/","text":"XSCROB (Scroll down) Scroll all lines from the top to the bottom ldx # $01 ; First line to scroll ldy # 25 ; Last line to scroll BRK_KERNEL XSCROB rts See scroll macro from orix-sdk to use it","title":"XSCROB"},{"location":"kernel/primitives/xscrob/#xscrob-scroll-down","text":"Scroll all lines from the top to the bottom ldx # $01 ; First line to scroll ldy # 25 ; Last line to scroll BRK_KERNEL XSCROB rts See scroll macro from orix-sdk to use it","title":"XSCROB (Scroll down)"},{"location":"kernel/primitives/xscroh/","text":"XSCROH (Scrollup text mode) Scroll all lines from bottom to the top Examples ldx # $01 ; First line to scroll ldy # 26 ; Last line to scroll BRK_KERNEL XSCROH See scroll macro from orix-sdk to use it","title":"XSCROH"},{"location":"kernel/primitives/xscroh/#xscroh-scrollup-text-mode","text":"Scroll all lines from bottom to the top","title":"XSCROH (Scrollup text mode)"},{"location":"kernel/primitives/xscroh/#examples","text":"ldx # $01 ; First line to scroll ldy # 26 ; Last line to scroll BRK_KERNEL XSCROH See scroll macro from orix-sdk to use it","title":"Examples"},{"location":"kernel/primitives/xtext/","text":"XTEXT Switch to text mode Example ldx # $00 BRK_TELEMON XTEXT rts","title":"XTEXT"},{"location":"kernel/primitives/xtext/#xtext","text":"Switch to text mode","title":"XTEXT"},{"location":"kernel/primitives/xtext/#example","text":"ldx # $00 BRK_TELEMON XTEXT rts","title":"Example"},{"location":"kernel/primitives/xvalues/","text":"XVALUES ROUTINE Get vars from kernel Get Free malloc table X = KERNEL_XVALUES_FREE_MALLOC_TABLE Get Busy malloc table X = KERNEL_XVALUES_BUSY_MALLOC_TABLE Get processName of the current chunk Y contains the id of the malloc busy table Y = the chunk X = 08 It returns in A & Y the ptr of the process name Get the position in the opened filed KERNEL_XVALUES_GET_FTELL_FROM_FD = $0A X=KERNEL_XVALUES_GET_FTELL_FROM_FD It returns in A, X, Y and RES, the position in the file Get the ptr of the pid list KERNEL_XVALUES_GET_PROCESS_ID_LIST=$0C ; A and Y contains the ptr Get the processname with the PID A = contains the POD X = KERNEL_XVALUES_GET_PROCESS_NAME_WITH_PID A & Y = contains the ptr of processname Get the number of malloc available in the kernel X = 5 Returns in A the number of the malloc Get the magic number of the kernel X = 6 Returns in A the magic number Get the max process configured in the kernel X = 8 Output : A contains the max process Get Os string (Orix) XVARS_KERNEL_OSNAME = 9 ldx # XVARS_KERNEL_OSNAME BRK_KERNEL XVARS ; A and X contains It will be available in Kernel v2023.2 Get an empty bank KERNEL_XVALUES_GET_FREE_BANK = $10 ldx # KERNEL_XVALUES_GET_FREE_BANK ldy # $00 ; RAM type BRK_TELEMON $2D ; XVALUES ; Y contains the id of the bank ; X contains set ($343 register) ; A the bank ($321 register) ; If there is no available bank, Y=0 rts It will be available in Kernel v2023.2 It can only allocate the first 8 banks It does not verify the content of any bank The content is reset every reboot","title":"XVALUES"},{"location":"kernel/primitives/xvalues/#xvalues-routine","text":"Get vars from kernel","title":"XVALUES ROUTINE"},{"location":"kernel/primitives/xvalues/#get-free-malloc-table","text":"X = KERNEL_XVALUES_FREE_MALLOC_TABLE","title":"Get Free malloc table"},{"location":"kernel/primitives/xvalues/#get-busy-malloc-table","text":"X = KERNEL_XVALUES_BUSY_MALLOC_TABLE","title":"Get Busy malloc table"},{"location":"kernel/primitives/xvalues/#get-processname-of-the-current-chunk","text":"Y contains the id of the malloc busy table Y = the chunk X = 08 It returns in A & Y the ptr of the process name","title":"Get processName of the current chunk"},{"location":"kernel/primitives/xvalues/#get-the-position-in-the-opened-filed","text":"KERNEL_XVALUES_GET_FTELL_FROM_FD = $0A X=KERNEL_XVALUES_GET_FTELL_FROM_FD It returns in A, X, Y and RES, the position in the file","title":"Get the position in the opened filed"},{"location":"kernel/primitives/xvalues/#get-the-ptr-of-the-pid-list","text":"KERNEL_XVALUES_GET_PROCESS_ID_LIST=$0C ; A and Y contains the ptr","title":"Get the ptr of the pid list"},{"location":"kernel/primitives/xvalues/#get-the-processname-with-the-pid","text":"A = contains the POD X = KERNEL_XVALUES_GET_PROCESS_NAME_WITH_PID A & Y = contains the ptr of processname","title":"Get the processname with the PID"},{"location":"kernel/primitives/xvalues/#get-the-number-of-malloc-available-in-the-kernel","text":"X = 5 Returns in A the number of the malloc","title":"Get the number of malloc available in the kernel"},{"location":"kernel/primitives/xvalues/#get-the-magic-number-of-the-kernel","text":"X = 6 Returns in A the magic number","title":"Get the magic number of the kernel"},{"location":"kernel/primitives/xvalues/#get-the-max-process-configured-in-the-kernel","text":"X = 8 Output : A contains the max process","title":"Get the max process configured in the kernel"},{"location":"kernel/primitives/xvalues/#get-os-string-orix","text":"XVARS_KERNEL_OSNAME = 9 ldx # XVARS_KERNEL_OSNAME BRK_KERNEL XVARS ; A and X contains It will be available in Kernel v2023.2","title":"Get Os string (Orix)"},{"location":"kernel/primitives/xvalues/#get-an-empty-bank","text":"KERNEL_XVALUES_GET_FREE_BANK = $10 ldx # KERNEL_XVALUES_GET_FREE_BANK ldy # $00 ; RAM type BRK_TELEMON $2D ; XVALUES ; Y contains the id of the bank ; X contains set ($343 register) ; A the bank ($321 register) ; If there is no available bank, Y=0 rts It will be available in Kernel v2023.2 It can only allocate the first 8 banks It does not verify the content of any bank The content is reset every reboot","title":"Get an empty bank"},{"location":"kernel/primitives/xvars/","text":"XVARS Get the number max of process ldx # KERNEL_XVARS_KERNEL_MAX_PROCESS ; Value = 8 BRK_KERNEL XVARS ; A and Y contains the number max of the process available Get the list of the process .include \"telestrat.inc\" ldx # KERNEL_XVARS_PID_LIST_PTR ; Value = $0A BRK_KERNEL XVARS ; A and Y contains the ptr of the list of current pid. ; If 0 is set, the slot is available and there is no process ; The end of the list is defined with #KERNEL_XVARS_KERNEL_MAX_PROCESS rts","title":"XVARS"},{"location":"kernel/primitives/xvars/#xvars","text":"","title":"XVARS"},{"location":"kernel/primitives/xvars/#get-the-number-max-of-process","text":"ldx # KERNEL_XVARS_KERNEL_MAX_PROCESS ; Value = 8 BRK_KERNEL XVARS ; A and Y contains the number max of the process available","title":"Get the number max of process"},{"location":"kernel/primitives/xvars/#get-the-list-of-the-process","text":".include \"telestrat.inc\" ldx # KERNEL_XVARS_PID_LIST_PTR ; Value = $0A BRK_KERNEL XVARS ; A and Y contains the ptr of the list of current pid. ; If 0 is set, the slot is available and there is no process ; The end of the list is defined with #KERNEL_XVARS_KERNEL_MAX_PROCESS rts","title":"Get the list of the process"},{"location":"kernel/primitives/xwr0/","text":"XWR0 Print a char to the screen .include \"telestrat.inc\" lda # 'A' BRK_TELEMON XWR0 rts See cgetc macro from orix-sdk to use it easily","title":"XWR0"},{"location":"kernel/primitives/xwr0/#xwr0","text":"Print a char to the screen .include \"telestrat.inc\" lda # 'A' BRK_TELEMON XWR0 rts See cgetc macro from orix-sdk to use it easily","title":"XWR0"},{"location":"kernel/primitives/xwrite/","text":"XFWRITE Description Write bytes to file Input AY contains the length to write PTR_READ_DEST must be set (ptr where data are read) X contains the fd id Output A & X contains the written length Modification Example lda # < $A000 sta PTR_READ_DEST lda # > $A000 sta PTR_READ_DEST + 1 lda # < 12 ldy # > 12 ldx fp BRK_KERNEL XFWRITE rts See fwrite macro from orix-sdk to use it easily XFWRITE does not manage multiples opened files : except since kernel 2022.2","title":"XWRITE"},{"location":"kernel/primitives/xwrite/#xfwrite","text":"","title":"XFWRITE"},{"location":"kernel/primitives/xwrite/#description","text":"Write bytes to file","title":"Description"},{"location":"kernel/primitives/xwrite/#input","text":"AY contains the length to write PTR_READ_DEST must be set (ptr where data are read) X contains the fd id","title":"Input"},{"location":"kernel/primitives/xwrite/#output","text":"A & X contains the written length","title":"Output"},{"location":"kernel/primitives/xwrite/#modification","text":"","title":"Modification"},{"location":"kernel/primitives/xwrite/#example","text":"lda # < $A000 sta PTR_READ_DEST lda # > $A000 sta PTR_READ_DEST + 1 lda # < 12 ldy # > 12 ldx fp BRK_KERNEL XFWRITE rts See fwrite macro from orix-sdk to use it easily XFWRITE does not manage multiples opened files : except since kernel 2022.2","title":"Example"},{"location":"kernel/primitives/xwstr0/","text":"XWSTR0 Displays a string .include \"telestrat.inc\" lda # < str ldy # > str BRK_KERNEL XWSTR0 rts str: .asciiz \"Hello world\" See print macro from orix-sdk to use it easily","title":"XWSTR0"},{"location":"kernel/primitives/xwstr0/#xwstr0","text":"Displays a string .include \"telestrat.inc\" lda # < str ldy # > str BRK_KERNEL XWSTR0 rts str: .asciiz \"Hello world\" See print macro from orix-sdk to use it easily","title":"XWSTR0"},{"location":"libs/twillib/","text":"Twil libs Manage rom/ram banks unsigned char twil_program_rambank ( unsigned char bank , char * file , unsigned char set ); unsigned char twil_clear_rambank ( unsigned char bank , unsigned char set ); unsigned char twil_lib_version ( void );","title":"Twilighte library"},{"location":"libs/twillib/#twil-libs","text":"Manage rom/ram banks unsigned char twil_program_rambank ( unsigned char bank , char * file , unsigned char set ); unsigned char twil_clear_rambank ( unsigned char bank , unsigned char set ); unsigned char twil_lib_version ( void );","title":"Twil libs"},{"location":"samples/asm_samples/","text":"Samples in Assembly Malloc Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 : = userzp malloc 4000 , myptr3 , str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Samples in Assembly"},{"location":"samples/asm_samples/#samples-in-assembly","text":"","title":"Samples in Assembly"},{"location":"samples/asm_samples/#malloc","text":"Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 : = userzp malloc 4000 , myptr3 , str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Malloc"},{"location":"samples/c_samples/","text":"Open and read files with cc65 #include <stdio.h> unsigned char chars [ 255 ]; main (){ fp = fopen ( \"/myfile\" , \"r\" ); if ( fp == NULL ) { printf ( \"Can't open %s \\n \" , argv [ 1 ]); return ( 1 ); } nb = fread ( chars , 255 , 1 , fp ); fclose ( fp ); }","title":"Open and read files with cc65"},{"location":"samples/c_samples/#open-and-read-files-with-cc65","text":"#include <stdio.h> unsigned char chars [ 255 ]; main (){ fp = fopen ( \"/myfile\" , \"r\" ); if ( fp == NULL ) { printf ( \"Can't open %s \\n \" , argv [ 1 ]); return ( 1 ); } nb = fread ( chars , 255 , 1 , fp ); fclose ( fp ); }","title":"Open and read files with cc65"},{"location":"samples/c_samples/getcwd/","text":"Get CWD in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD = $48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd (); int main () { printf ( \"Cwd : %s\" , ogetcwd ()); return 0 ; }","title":"Get CWD in cc65"},{"location":"samples/c_samples/getcwd/#get-cwd-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD = $48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd (); int main () { printf ( \"Cwd : %s\" , ogetcwd ()); return 0 ; }","title":"Get CWD in cc65"},{"location":"samples/c_samples/mkdir/","text":"Create a folder with cc65 For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir ( unsigned char * path ); int main () { mkdir ( \"myfolder\" ); return 0 ; }","title":"Create a folder with cc65"},{"location":"samples/c_samples/mkdir/#create-a-folder-with-cc65","text":"For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir ( unsigned char * path ); int main () { mkdir ( \"myfolder\" ); return 0 ; }","title":"Create a folder with cc65"},{"location":"samples/c_samples/putcwd/","text":"chdir in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD = $49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd (); int main () { oputcwd ( \"/etc\" ); return 0 ; }","title":"chdir in cc65"},{"location":"samples/c_samples/putcwd/#chdir-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD = $49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd (); int main () { oputcwd ( \"/etc\" ); return 0 ; }","title":"chdir in cc65"},{"location":"samples/c_samples/writefile/","text":"Write a file #include <stdio.h> static unsigned char buffer [ 4000 ]; int main () { FILE * fp ; unsigned int nb_write ; static unsigned char destfilename [ 9 ] = \"myfile.txt\" ; fp = fopen ( destfilename , \"wb\" ); if ( ! fp ) { printf ( \"Can't create output file \\n \" ); return 1 ; } nb_write = fwrite ( buffer , 1 , 4000 , fp ); fclose ( fp ); }","title":"Write a file"},{"location":"samples/c_samples/writefile/#write-a-file","text":"#include <stdio.h> static unsigned char buffer [ 4000 ]; int main () { FILE * fp ; unsigned int nb_write ; static unsigned char destfilename [ 9 ] = \"myfile.txt\" ; fp = fopen ( destfilename , \"wb\" ); if ( ! fp ) { printf ( \"Can't create output file \\n \" ); return 1 ; } nb_write = fwrite ( buffer , 1 , 4000 , fp ); fclose ( fp ); }","title":"Write a file"},{"location":"tools/mount/","text":"Mount (not developed yet) FP Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null. When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE ls case ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel cp/mv case don't know","title":"Mount (not developed yet)"},{"location":"tools/mount/#mount-not-developed-yet","text":"","title":"Mount (not developed yet)"},{"location":"tools/mount/#fp","text":"Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null.","title":"FP"},{"location":"tools/mount/#when-a-freadfwrite-is-done-if-extbank-is-different-to-0-then-kernel-will-launch-external-vector-with-a-and-y-contains-the-string-of-the-path-and-x-contains-the-action","text":"X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE","title":"When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action"},{"location":"tools/mount/#ls-case","text":"ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel","title":"ls case"},{"location":"tools/mount/#cpmv-case","text":"don't know","title":"cp/mv case"},{"location":"tools_docs/vi/Structs/","text":"Classes struct vi_struct_data Updated on 2022-12-15 at 14:20:17 +0100","title":"Classes"},{"location":"tools_docs/vi/Structs/#classes","text":"struct vi_struct_data Updated on 2022-12-15 at 14:20:17 +0100","title":"Classes"},{"location":"tools_docs/vi/index_classes/","text":"Classes struct vi_struct_data Updated on 2022-12-15 at 12:21:07 +0100","title":"Classes"},{"location":"tools_docs/vi/index_classes/#classes","text":"struct vi_struct_data Updated on 2022-12-15 at 12:21:07 +0100","title":"Classes"},{"location":"tools_docs/vi/index_examples/","text":"Examples example This strlen of a line Updated on 2022-12-15 at 14:20:18 +0100","title":"Examples"},{"location":"tools_docs/vi/index_examples/#examples","text":"example This strlen of a line Updated on 2022-12-15 at 14:20:18 +0100","title":"Examples"},{"location":"tools_docs/vi/index_files/","text":"Files dir /mnt/c/Users/plifp/OneDrive/oric/projets/orix-software/vi dir dir /commands file s dir /data dir /data/vi file s dir /Routines dir /Routines/subfunc dir /Routines/subfunc/vi file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s Updated on 2022-12-15 at 14:20:18 +0100","title":"Files"},{"location":"tools_docs/vi/index_files/#files","text":"dir /mnt/c/Users/plifp/OneDrive/oric/projets/orix-software/vi dir dir /commands file s dir /data dir /data/vi file s dir /Routines dir /Routines/subfunc dir /Routines/subfunc/vi file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s file s Updated on 2022-12-15 at 14:20:18 +0100","title":"Files"},{"location":"tools_docs/vi/index_groups/","text":"Modules Updated on 2022-12-15 at 14:20:17 +0100","title":"Modules"},{"location":"tools_docs/vi/index_groups/#modules","text":"Updated on 2022-12-15 at 14:20:17 +0100","title":"Modules"},{"location":"tools_docs/vi/index_namespaces/","text":"Namespaces Updated on 2022-12-15 at 14:20:17 +0100","title":"Namespaces"},{"location":"tools_docs/vi/index_namespaces/#namespaces","text":"Updated on 2022-12-15 at 14:20:17 +0100","title":"Namespaces"},{"location":"tools_docs/vi/index_pages/","text":"Pages page strlen Updated on 2022-12-15 at 14:20:18 +0100","title":"Pages"},{"location":"tools_docs/vi/index_pages/#pages","text":"page strlen Updated on 2022-12-15 at 14:20:18 +0100","title":"Pages"},{"location":"tools_docs/vi/Classes/structvi__struct__data/","text":"vi_struct_data Public Attributes Name char xpos_screen char ypos_screen char[2] pos_file_addr char[4] pos_file char posx_command_line char[VI_MAX_LENGTH_FILENAME] name_file_open int ptr_file_begin char[4] length_file char[2] pos_ptr_video_address char[4] file_number_of_line char[1] xpos_command_line char[39] command_line_buffer char[2] ptr_last_char_file char[2] line_id char[1] xpos_text char[1] ypos_text Public Attributes Documentation variable xpos_screen char xpos_screen ; position x of the cursor on the screen variable ypos_screen char ypos_screen ; position y of the cursor on the screen variable pos_file_addr char [ 2 ] pos_file_addr ; position on the file (address) variable pos_file char [ 4 ] pos_file ; position in the file variable posx_command_line char posx_command_line ; position on command line variable name_file_open char [ VI_MAX_LENGTH_FILENAME ] name_file_open ; variable int int ; adress of the beginning of the file variable ptr_file_begin ptr_file_begin ; variable length_file char [ 4 ] length_file ; Length of the file variable pos_ptr_video_address char [ 2 ] pos_ptr_video_address ; variable file_number_of_line char [ 4 ] file_number_of_line ; variable xpos_command_line char [ 1 ] xpos_command_line ; variable command_line_buffer char [ 39 ] command_line_buffer ; variable ptr_last_char_file char [ 2 ] ptr_last_char_file ; variable line_id char [ 2 ] line_id ; variable xpos_text char [ 1 ] xpos_text ; variable ypos_text char [ 1 ] ypos_text ; Updated on 2022-12-15 at 12:29:28 +0100","title":"vi_struct_data"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#vi_struct_data","text":"","title":"vi_struct_data"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#public-attributes","text":"Name char xpos_screen char ypos_screen char[2] pos_file_addr char[4] pos_file char posx_command_line char[VI_MAX_LENGTH_FILENAME] name_file_open int ptr_file_begin char[4] length_file char[2] pos_ptr_video_address char[4] file_number_of_line char[1] xpos_command_line char[39] command_line_buffer char[2] ptr_last_char_file char[2] line_id char[1] xpos_text char[1] ypos_text","title":"Public Attributes"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-xpos_screen","text":"char xpos_screen ; position x of the cursor on the screen","title":"variable xpos_screen"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-ypos_screen","text":"char ypos_screen ; position y of the cursor on the screen","title":"variable ypos_screen"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-pos_file_addr","text":"char [ 2 ] pos_file_addr ; position on the file (address)","title":"variable pos_file_addr"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-pos_file","text":"char [ 4 ] pos_file ; position in the file","title":"variable pos_file"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-posx_command_line","text":"char posx_command_line ; position on command line","title":"variable posx_command_line"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-name_file_open","text":"char [ VI_MAX_LENGTH_FILENAME ] name_file_open ;","title":"variable name_file_open"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-int","text":"int ; adress of the beginning of the file","title":"variable int"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-ptr_file_begin","text":"ptr_file_begin ;","title":"variable ptr_file_begin"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-length_file","text":"char [ 4 ] length_file ; Length of the file","title":"variable length_file"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-pos_ptr_video_address","text":"char [ 2 ] pos_ptr_video_address ;","title":"variable pos_ptr_video_address"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-file_number_of_line","text":"char [ 4 ] file_number_of_line ;","title":"variable file_number_of_line"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-xpos_command_line","text":"char [ 1 ] xpos_command_line ;","title":"variable xpos_command_line"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-command_line_buffer","text":"char [ 39 ] command_line_buffer ;","title":"variable command_line_buffer"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-ptr_last_char_file","text":"char [ 2 ] ptr_last_char_file ;","title":"variable ptr_last_char_file"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-line_id","text":"char [ 2 ] line_id ;","title":"variable line_id"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-xpos_text","text":"char [ 1 ] xpos_text ;","title":"variable xpos_text"},{"location":"tools_docs/vi/Classes/structvi__struct__data/#variable-ypos_text","text":"char [ 1 ] ypos_text ; Updated on 2022-12-15 at 12:29:28 +0100","title":"variable ypos_text"},{"location":"tools_docs/vi/Examples/This-example/","text":"This strlen of a line routine compute ... ``` Filename: This Updated on 2022-12-15 at 14:20:17 +0100","title":"This"},{"location":"tools_docs/vi/Examples/This-example/#this","text":"strlen of a line routine compute ... ``` Filename: This Updated on 2022-12-15 at 14:20:17 +0100","title":"This"},{"location":"tools_docs/vi/Files/__clrscr__vi_8s/","text":"/Routines/_clrscr_vi.s Routine Name _clrscr_vi Routine documentation Routine _clrscr_vi _clrscr_vi Source code .proc _clrscr_vi ; Switch to text mode BRK_TELEMON ( XTEXT ) lda # < SCREEN ; Get position screen ldy # > SCREEN sta RES sty RES + 1 ldy # < ( SCREEN + SCREEN_XSIZE * SCREEN_YSIZE ) ldx # > ( SCREEN + SCREEN_XSIZE * SCREEN_YSIZE ) lda # ' ' BRK_TELEMON XFILLM ; Calls XFILLM : it fills A value from RES address and size of X and Y value rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/_clrscr_vi.s"},{"location":"tools_docs/vi/Files/__clrscr__vi_8s/#routines_clrscr_vis","text":"","title":"/Routines/_clrscr_vi.s"},{"location":"tools_docs/vi/Files/__clrscr__vi_8s/#routine","text":"Name _clrscr_vi","title":"Routine"},{"location":"tools_docs/vi/Files/__clrscr__vi_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/__clrscr__vi_8s/#routine-_clrscr_vi","text":"_clrscr_vi","title":"Routine _clrscr_vi"},{"location":"tools_docs/vi/Files/__clrscr__vi_8s/#source-code","text":".proc _clrscr_vi ; Switch to text mode BRK_TELEMON ( XTEXT ) lda # < SCREEN ; Get position screen ldy # > SCREEN sta RES sty RES + 1 ldy # < ( SCREEN + SCREEN_XSIZE * SCREEN_YSIZE ) ldx # > ( SCREEN + SCREEN_XSIZE * SCREEN_YSIZE ) lda # ' ' BRK_TELEMON XFILLM ; Calls XFILLM : it fills A value from RES address and size of X and Y value rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/dir_2288eccfea1af74b995388678c757cc0/","text":"/Routines Directories Name /Routines/subfunc Files Name /Routines/_clrscr_vi.s /Routines/tables.s /Routines/vi_command_edition.s /Routines/vi_displays_info.s /Routines/vi_edition_keyboard.s /Routines/vi_editor_switch_off_cursor.s /Routines/vi_editor_switch_on_cursor.s /Routines/vi_fill_screen_with_empty_line.s /Routines/vi_put_char.s /Routines/vi_set_length_file.s /Routines/vi_struct.s /Routines/vi_switch_to_edition_mode.s Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines"},{"location":"tools_docs/vi/Files/dir_2288eccfea1af74b995388678c757cc0/#routines","text":"","title":"/Routines"},{"location":"tools_docs/vi/Files/dir_2288eccfea1af74b995388678c757cc0/#directories","text":"Name /Routines/subfunc","title":"Directories"},{"location":"tools_docs/vi/Files/dir_2288eccfea1af74b995388678c757cc0/#files","text":"Name /Routines/_clrscr_vi.s /Routines/tables.s /Routines/vi_command_edition.s /Routines/vi_displays_info.s /Routines/vi_edition_keyboard.s /Routines/vi_editor_switch_off_cursor.s /Routines/vi_editor_switch_on_cursor.s /Routines/vi_fill_screen_with_empty_line.s /Routines/vi_put_char.s /Routines/vi_set_length_file.s /Routines/vi_struct.s /Routines/vi_switch_to_edition_mode.s Updated on 2022-12-15 at 14:20:17 +0100","title":"Files"},{"location":"tools_docs/vi/Files/dir_6c260d28152e78a3ffcc2e06b7438967/","text":"Directories Name /commands /data /Routines Files Name /rom.s Updated on 2022-12-15 at 14:20:17 +0100","title":null},{"location":"tools_docs/vi/Files/dir_6c260d28152e78a3ffcc2e06b7438967/#_1","text":"","title":""},{"location":"tools_docs/vi/Files/dir_6c260d28152e78a3ffcc2e06b7438967/#directories","text":"Name /commands /data /Routines","title":"Directories"},{"location":"tools_docs/vi/Files/dir_6c260d28152e78a3ffcc2e06b7438967/#files","text":"Name /rom.s Updated on 2022-12-15 at 14:20:17 +0100","title":"Files"},{"location":"tools_docs/vi/Files/dir_834496eb029ed14441e8790c53896f5f/","text":"/data/vi Files Name /data/vi/strings.s Updated on 2022-12-15 at 14:20:17 +0100","title":"/data/vi"},{"location":"tools_docs/vi/Files/dir_834496eb029ed14441e8790c53896f5f/#datavi","text":"","title":"/data/vi"},{"location":"tools_docs/vi/Files/dir_834496eb029ed14441e8790c53896f5f/#files","text":"Name /data/vi/strings.s Updated on 2022-12-15 at 14:20:17 +0100","title":"Files"},{"location":"tools_docs/vi/Files/dir_8a0a2fbb0e248d2b08adec17bb698d4e/","text":"/Routines/subfunc Directories Name /Routines/subfunc/vi Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/subfunc"},{"location":"tools_docs/vi/Files/dir_8a0a2fbb0e248d2b08adec17bb698d4e/#routinessubfunc","text":"","title":"/Routines/subfunc"},{"location":"tools_docs/vi/Files/dir_8a0a2fbb0e248d2b08adec17bb698d4e/#directories","text":"Name /Routines/subfunc/vi Updated on 2022-12-15 at 14:20:17 +0100","title":"Directories"},{"location":"tools_docs/vi/Files/dir_a5544c2bf0b70f8d417c4d3bfea04409/","text":"/Routines/subfunc/vi Files Name vi_add_char_to_text.s vi_check_0A.s vi_check_beginning_of_file.s vi_check_eof.s vi_check_if_previous_line_was_truncated.s vi_check_inserted_char_overflow_the_max_column.s vi_clear_command_line.s vi_compute_last_text_line.s vi_compute_video_adress.s vi_copy_arg1_to_name_file_open.s vi_decal_text.s vi_display_char.s vi_display_file_opened.s vi_fill_last_line.s vi_init_vi_struct.s vi_key_del.s vi_key_down.s vi_key_enter.s vi_key_left.s vi_key_right.s vi_key_up.s vi_length_file_plus_plus.s vi_length_file_sub_sub.s vi_ptr_file_used_plus_plus.s vi_ptr_file_used_plus_plus_and_check_eof.s vi_ptr_file_used_sub_sub.s vi_ptr_last_char_add.s vi_ptr_last_char_plus_plus.s vi_ptr_last_char_sub_sub.s vi_scroll_from_left_to_right_full_line.s vi_scroll_to_left.s vi_search_next_line.s vi_search_previous_cr.s vi_search_previous_line_beginning.s vi_set_ptr_last_char.s vi_set_xpos_0.s vi_set_xpos_from_A.s vi_shift_file_from_memory_one_char.s vi_shift_line_left_to_right_editor.s vi_strlen_current_line.s vi_vi_ptr_file_used_plus_plus.s vi_xpos_screen_plus_plus.s vi_xpos_screen_sub_sub.s vi_ypos_screen_plus_plus.s vi_ypos_screen_sub_sub.s Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/subfunc/vi"},{"location":"tools_docs/vi/Files/dir_a5544c2bf0b70f8d417c4d3bfea04409/#routinessubfuncvi","text":"","title":"/Routines/subfunc/vi"},{"location":"tools_docs/vi/Files/dir_a5544c2bf0b70f8d417c4d3bfea04409/#files","text":"Name vi_add_char_to_text.s vi_check_0A.s vi_check_beginning_of_file.s vi_check_eof.s vi_check_if_previous_line_was_truncated.s vi_check_inserted_char_overflow_the_max_column.s vi_clear_command_line.s vi_compute_last_text_line.s vi_compute_video_adress.s vi_copy_arg1_to_name_file_open.s vi_decal_text.s vi_display_char.s vi_display_file_opened.s vi_fill_last_line.s vi_init_vi_struct.s vi_key_del.s vi_key_down.s vi_key_enter.s vi_key_left.s vi_key_right.s vi_key_up.s vi_length_file_plus_plus.s vi_length_file_sub_sub.s vi_ptr_file_used_plus_plus.s vi_ptr_file_used_plus_plus_and_check_eof.s vi_ptr_file_used_sub_sub.s vi_ptr_last_char_add.s vi_ptr_last_char_plus_plus.s vi_ptr_last_char_sub_sub.s vi_scroll_from_left_to_right_full_line.s vi_scroll_to_left.s vi_search_next_line.s vi_search_previous_cr.s vi_search_previous_line_beginning.s vi_set_ptr_last_char.s vi_set_xpos_0.s vi_set_xpos_from_A.s vi_shift_file_from_memory_one_char.s vi_shift_line_left_to_right_editor.s vi_strlen_current_line.s vi_vi_ptr_file_used_plus_plus.s vi_xpos_screen_plus_plus.s vi_xpos_screen_sub_sub.s vi_ypos_screen_plus_plus.s vi_ypos_screen_sub_sub.s Updated on 2022-12-15 at 14:20:17 +0100","title":"Files"},{"location":"tools_docs/vi/Files/dir_e1568de7a9ec0caf269f7729a27efb24/","text":"/commands Files Name /commands/vi.s Updated on 2022-12-15 at 14:20:17 +0100","title":"/commands"},{"location":"tools_docs/vi/Files/dir_e1568de7a9ec0caf269f7729a27efb24/#commands","text":"","title":"/commands"},{"location":"tools_docs/vi/Files/dir_e1568de7a9ec0caf269f7729a27efb24/#files","text":"Name /commands/vi.s Updated on 2022-12-15 at 14:20:17 +0100","title":"Files"},{"location":"tools_docs/vi/Files/dir_e433504a3e785b34aabb2c6185efc4a1/","text":"/mnt/c/Users/plifp/OneDrive/oric/projets/orix-software/vi Directories Name Updated on 2022-12-15 at 14:20:17 +0100","title":"/mnt/c/Users/plifp/OneDrive/oric/projets/orix-software/vi"},{"location":"tools_docs/vi/Files/dir_e433504a3e785b34aabb2c6185efc4a1/#mntcusersplifponedriveoricprojetsorix-softwarevi","text":"","title":"/mnt/c/Users/plifp/OneDrive/oric/projets/orix-software/vi"},{"location":"tools_docs/vi/Files/dir_e433504a3e785b34aabb2c6185efc4a1/#directories","text":"Name Updated on 2022-12-15 at 14:20:17 +0100","title":"Directories"},{"location":"tools_docs/vi/Files/dir_eb94e028ad508402029845f2921e79f7/","text":"/data Directories Name /data/vi Updated on 2022-12-15 at 14:20:17 +0100","title":"/data"},{"location":"tools_docs/vi/Files/dir_eb94e028ad508402029845f2921e79f7/#data","text":"","title":"/data"},{"location":"tools_docs/vi/Files/dir_eb94e028ad508402029845f2921e79f7/#directories","text":"Name /data/vi Updated on 2022-12-15 at 14:20:17 +0100","title":"Directories"},{"location":"tools_docs/vi/Files/rom_8s/","text":"/rom.s Attributes Name const char userzp const char NULL const char[3] list_of_commands_bank int addr_commands const char[10] signature char[$FFF0- *] end_rom char[2] parse_vector unsigned int signature_adress_commands unsigned int list_commands char number_of_commands int copyright int NMI int RESET int BRK_IRQ Attributes Documentation variable userzp const char userzp = $80 ; variable NULL const char NULL = 0 ; variable list_of_commands_bank const char [ 3 ] list_of_commands_bank = \"vi\" ; variable addr_commands int addr_commands ; variable signature const char [ 10 ] signature = \"vi 2022.4\" ; variable end_rom char [ $FFF0 - * ] end_rom ; variable parse_vector char [ 2 ] parse_vector ; variable signature_adress_commands unsigned int signature_adress_commands ; variable list_commands unsigned int list_commands ; variable number_of_commands char number_of_commands ; variable copyright int copyright ; variable NMI int NMI ; variable RESET int RESET ; variable BRK_IRQ int BRK_IRQ ; Source code ;---------------------------------------------------------------------- ; cc65 includes ;---------------------------------------------------------------------- .include \"telestrat.inc\" ; from cc65 .include \"fcntl.inc\" ; from cc65 .include \"errno.inc\" ; from cc65 .include \"cpu.mac\" ; from cc65 ;---------------------------------------------------------------------- ; Orix SDK includes ;---------------------------------------------------------------------- .include \"../dependencies/orix-sdk/macros/SDK.mac\" .include \"../dependencies/orix-sdk/include/SDK.inc\" .include \"../dependencies/orix-sdk/include/keyboard.inc\" ;---------------------------------------------------------------------- ; Zero Page ;---------------------------------------------------------------------- userzp : = $80 NULL = 0 ;---------------------------------------------------------------------- ; Shell ;---------------------------------------------------------------------- .org $C000 .code start: rts .include \"commands/vi.s\" list_of_commands_bank: .asciiz \"vi\" addr_commands: .word _vi signature: .asciiz \"vi 2022.4\" end_rom: ;---------------------------------------------------------------------- ; ;---------------------------------------------------------------------- .out .sprintf ( \"Size of ROM : %d bytes\" , end_rom - $c000 ) .res $FFF0 -* .org $FFF0 .byt 1 ; Command ROM ; $fff1 parse_vector: .byt $00 , $00 ; fff3 signature_adress_commands: .addr addr_commands ; fff5-fff6 list_commands: .addr list_of_commands_bank ; fff7 number_of_commands: .byt 1 ; fff8-fff9 copyright: .word signature ; fffa-fffb NMI: .word start ; fffc-fffd RESET: .word start ; fffe-ffff BRK_IRQ: .word IRQVECTOR Updated on 2022-12-15 at 14:20:17 +0100","title":"/rom.s"},{"location":"tools_docs/vi/Files/rom_8s/#roms","text":"","title":"/rom.s"},{"location":"tools_docs/vi/Files/rom_8s/#attributes","text":"Name const char userzp const char NULL const char[3] list_of_commands_bank int addr_commands const char[10] signature char[$FFF0- *] end_rom char[2] parse_vector unsigned int signature_adress_commands unsigned int list_commands char number_of_commands int copyright int NMI int RESET int BRK_IRQ","title":"Attributes"},{"location":"tools_docs/vi/Files/rom_8s/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"tools_docs/vi/Files/rom_8s/#variable-userzp","text":"const char userzp = $80 ;","title":"variable userzp"},{"location":"tools_docs/vi/Files/rom_8s/#variable-null","text":"const char NULL = 0 ;","title":"variable NULL"},{"location":"tools_docs/vi/Files/rom_8s/#variable-list_of_commands_bank","text":"const char [ 3 ] list_of_commands_bank = \"vi\" ;","title":"variable list_of_commands_bank"},{"location":"tools_docs/vi/Files/rom_8s/#variable-addr_commands","text":"int addr_commands ;","title":"variable addr_commands"},{"location":"tools_docs/vi/Files/rom_8s/#variable-signature","text":"const char [ 10 ] signature = \"vi 2022.4\" ;","title":"variable signature"},{"location":"tools_docs/vi/Files/rom_8s/#variable-end_rom","text":"char [ $FFF0 - * ] end_rom ;","title":"variable end_rom"},{"location":"tools_docs/vi/Files/rom_8s/#variable-parse_vector","text":"char [ 2 ] parse_vector ;","title":"variable parse_vector"},{"location":"tools_docs/vi/Files/rom_8s/#variable-signature_adress_commands","text":"unsigned int signature_adress_commands ;","title":"variable signature_adress_commands"},{"location":"tools_docs/vi/Files/rom_8s/#variable-list_commands","text":"unsigned int list_commands ;","title":"variable list_commands"},{"location":"tools_docs/vi/Files/rom_8s/#variable-number_of_commands","text":"char number_of_commands ;","title":"variable number_of_commands"},{"location":"tools_docs/vi/Files/rom_8s/#variable-copyright","text":"int copyright ;","title":"variable copyright"},{"location":"tools_docs/vi/Files/rom_8s/#variable-nmi","text":"int NMI ;","title":"variable NMI"},{"location":"tools_docs/vi/Files/rom_8s/#variable-reset","text":"int RESET ;","title":"variable RESET"},{"location":"tools_docs/vi/Files/rom_8s/#variable-brk_irq","text":"int BRK_IRQ ;","title":"variable BRK_IRQ"},{"location":"tools_docs/vi/Files/rom_8s/#source-code","text":";---------------------------------------------------------------------- ; cc65 includes ;---------------------------------------------------------------------- .include \"telestrat.inc\" ; from cc65 .include \"fcntl.inc\" ; from cc65 .include \"errno.inc\" ; from cc65 .include \"cpu.mac\" ; from cc65 ;---------------------------------------------------------------------- ; Orix SDK includes ;---------------------------------------------------------------------- .include \"../dependencies/orix-sdk/macros/SDK.mac\" .include \"../dependencies/orix-sdk/include/SDK.inc\" .include \"../dependencies/orix-sdk/include/keyboard.inc\" ;---------------------------------------------------------------------- ; Zero Page ;---------------------------------------------------------------------- userzp : = $80 NULL = 0 ;---------------------------------------------------------------------- ; Shell ;---------------------------------------------------------------------- .org $C000 .code start: rts .include \"commands/vi.s\" list_of_commands_bank: .asciiz \"vi\" addr_commands: .word _vi signature: .asciiz \"vi 2022.4\" end_rom: ;---------------------------------------------------------------------- ; ;---------------------------------------------------------------------- .out .sprintf ( \"Size of ROM : %d bytes\" , end_rom - $c000 ) .res $FFF0 -* .org $FFF0 .byt 1 ; Command ROM ; $fff1 parse_vector: .byt $00 , $00 ; fff3 signature_adress_commands: .addr addr_commands ; fff5-fff6 list_commands: .addr list_of_commands_bank ; fff7 number_of_commands: .byt 1 ; fff8-fff9 copyright: .word signature ; fffa-fffb NMI: .word start ; fffc-fffd RESET: .word start ; fffe-ffff BRK_IRQ: .word IRQVECTOR Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/strings_8s/","text":"/data/vi/strings.s Attributes Name const char[13] msg_insert const char[11] msg_nofile char[2] msg_nofilename char[2] msg_impossibletowrite const char[8] msg_written Attributes Documentation variable msg_insert const char [ 13 ] msg_insert = \"-- INSERT --\" ; variable msg_nofile const char [ 11 ] msg_nofile = \"[New File]\" ; variable msg_nofilename char [ 2 ] msg_nofilename ; variable msg_impossibletowrite char [ 2 ] msg_impossibletowrite ; variable msg_written const char [ 8 ] msg_written = \"written\" ; Source code msg_insert: .asciiz \"-- INSERT --\" msg_nofile: .asciiz \"[New File]\" msg_nofilename: .byte 17 , \"E32: No file name\" , 16 , 0 msg_impossibletowrite: .byte 17 , \"E99: Impossible to write\" , 16 , 0 msg_written: .asciiz \"written\" Updated on 2022-12-15 at 14:20:17 +0100","title":"/data/vi/strings.s"},{"location":"tools_docs/vi/Files/strings_8s/#datavistringss","text":"","title":"/data/vi/strings.s"},{"location":"tools_docs/vi/Files/strings_8s/#attributes","text":"Name const char[13] msg_insert const char[11] msg_nofile char[2] msg_nofilename char[2] msg_impossibletowrite const char[8] msg_written","title":"Attributes"},{"location":"tools_docs/vi/Files/strings_8s/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"tools_docs/vi/Files/strings_8s/#variable-msg_insert","text":"const char [ 13 ] msg_insert = \"-- INSERT --\" ;","title":"variable msg_insert"},{"location":"tools_docs/vi/Files/strings_8s/#variable-msg_nofile","text":"const char [ 11 ] msg_nofile = \"[New File]\" ;","title":"variable msg_nofile"},{"location":"tools_docs/vi/Files/strings_8s/#variable-msg_nofilename","text":"char [ 2 ] msg_nofilename ;","title":"variable msg_nofilename"},{"location":"tools_docs/vi/Files/strings_8s/#variable-msg_impossibletowrite","text":"char [ 2 ] msg_impossibletowrite ;","title":"variable msg_impossibletowrite"},{"location":"tools_docs/vi/Files/strings_8s/#variable-msg_written","text":"const char [ 8 ] msg_written = \"written\" ;","title":"variable msg_written"},{"location":"tools_docs/vi/Files/strings_8s/#source-code","text":"msg_insert: .asciiz \"-- INSERT --\" msg_nofile: .asciiz \"[New File]\" msg_nofilename: .byte 17 , \"E32: No file name\" , 16 , 0 msg_impossibletowrite: .byte 17 , \"E99: Impossible to write\" , 16 , 0 msg_written: .asciiz \"written\" Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/tables_8s/","text":"/Routines/tables.s Attributes Name char TABLE_LOW_TEXT char TABLE_HIGH_TEXT Attributes Documentation variable TABLE_LOW_TEXT char TABLE_LOW_TEXT ; variable TABLE_HIGH_TEXT char TABLE_HIGH_TEXT ; Source code TABLE_LOW_TEXT: ;0 .byt < ( $bb80 ) .byt < ( $bb80 + 40 ) .byt < ( $bb80 + 80 ) .byt < ( $bb80 + 120 ) .byt < ( $bb80 + 160 ) .byt < ( $bb80 + 200 ) .byt < ( $bb80 + 240 ) .byt < ( $bb80 + 280 ) .byt < ( $bb80 + 320 ) .byt < ( $bb80 + 360 ) .byt < ( $bb80 + 400 ) .byt < ( $bb80 + 440 ) .byt < ( $bb80 + 480 ) .byt < ( $bb80 + 520 ) .byt < ( $bb80 + 560 ) .byt < ( $bb80 + 600 ) .byt < ( $bb80 + 640 ) .byt < ( $bb80 + 680 ) .byt < ( $bb80 + 720 ) .byt < ( $bb80 + 760 ) .byt < ( $bb80 + 800 ) .byt < ( $bb80 + 840 ) .byt < ( $bb80 + 880 ) .byt < ( $bb80 + 920 ) .byt < ( $bb80 + 960 ) .byt < ( $bb80 + 1000 ) .byt < ( $bb80 + 1040 ) .byt < ( $bb80 + 1080 ) TABLE_HIGH_TEXT: .byt > ( $bb80 ) .byt > ( $bb80 + 40 ) .byt > ( $bb80 + 80 ) .byt > ( $bb80 + 120 ) .byt > ( $bb80 + 160 ) ;5 .byt > ( $bb80 + 200 ) .byt > ( $bb80 + 240 ) .byt > ( $bb80 + 280 ) .byt > ( $bb80 + 320 ) .byt > ( $bb80 + 360 ) ;10 .byt > ( $bb80 + 400 ) .byt > ( $bb80 + 440 ) .byt > ( $bb80 + 480 ) .byt > ( $bb80 + 520 ) .byt > ( $bb80 + 560 ) ;15 .byt > ( $bb80 + 600 ) .byt > ( $bb80 + 640 ) .byt > ( $bb80 + 680 ) .byt > ( $bb80 + 720 ) .byt > ( $bb80 + 760 ) ;20 .byt > ( $bb80 + 800 ) .byt > ( $bb80 + 840 ) .byt > ( $bb80 + 880 ) .byt > ( $bb80 + 920 ) .byt > ( $bb80 + 960 ) ;25 .byt > ( $bb80 + 1000 ) ; 26 .byt > ( $bb80 + 1040 ) ; 27 .byt > ( $bb80 + 1080 ) Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/tables.s"},{"location":"tools_docs/vi/Files/tables_8s/#routinestabless","text":"","title":"/Routines/tables.s"},{"location":"tools_docs/vi/Files/tables_8s/#attributes","text":"Name char TABLE_LOW_TEXT char TABLE_HIGH_TEXT","title":"Attributes"},{"location":"tools_docs/vi/Files/tables_8s/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"tools_docs/vi/Files/tables_8s/#variable-table_low_text","text":"char TABLE_LOW_TEXT ;","title":"variable TABLE_LOW_TEXT"},{"location":"tools_docs/vi/Files/tables_8s/#variable-table_high_text","text":"char TABLE_HIGH_TEXT ;","title":"variable TABLE_HIGH_TEXT"},{"location":"tools_docs/vi/Files/tables_8s/#source-code","text":"TABLE_LOW_TEXT: ;0 .byt < ( $bb80 ) .byt < ( $bb80 + 40 ) .byt < ( $bb80 + 80 ) .byt < ( $bb80 + 120 ) .byt < ( $bb80 + 160 ) .byt < ( $bb80 + 200 ) .byt < ( $bb80 + 240 ) .byt < ( $bb80 + 280 ) .byt < ( $bb80 + 320 ) .byt < ( $bb80 + 360 ) .byt < ( $bb80 + 400 ) .byt < ( $bb80 + 440 ) .byt < ( $bb80 + 480 ) .byt < ( $bb80 + 520 ) .byt < ( $bb80 + 560 ) .byt < ( $bb80 + 600 ) .byt < ( $bb80 + 640 ) .byt < ( $bb80 + 680 ) .byt < ( $bb80 + 720 ) .byt < ( $bb80 + 760 ) .byt < ( $bb80 + 800 ) .byt < ( $bb80 + 840 ) .byt < ( $bb80 + 880 ) .byt < ( $bb80 + 920 ) .byt < ( $bb80 + 960 ) .byt < ( $bb80 + 1000 ) .byt < ( $bb80 + 1040 ) .byt < ( $bb80 + 1080 ) TABLE_HIGH_TEXT: .byt > ( $bb80 ) .byt > ( $bb80 + 40 ) .byt > ( $bb80 + 80 ) .byt > ( $bb80 + 120 ) .byt > ( $bb80 + 160 ) ;5 .byt > ( $bb80 + 200 ) .byt > ( $bb80 + 240 ) .byt > ( $bb80 + 280 ) .byt > ( $bb80 + 320 ) .byt > ( $bb80 + 360 ) ;10 .byt > ( $bb80 + 400 ) .byt > ( $bb80 + 440 ) .byt > ( $bb80 + 480 ) .byt > ( $bb80 + 520 ) .byt > ( $bb80 + 560 ) ;15 .byt > ( $bb80 + 600 ) .byt > ( $bb80 + 640 ) .byt > ( $bb80 + 680 ) .byt > ( $bb80 + 720 ) .byt > ( $bb80 + 760 ) ;20 .byt > ( $bb80 + 800 ) .byt > ( $bb80 + 840 ) .byt > ( $bb80 + 880 ) .byt > ( $bb80 + 920 ) .byt > ( $bb80 + 960 ) ;25 .byt > ( $bb80 + 1000 ) ; 26 .byt > ( $bb80 + 1040 ) ; 27 .byt > ( $bb80 + 1080 ) Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi_8s/","text":"/commands/vi.s Routine Name _vi Attributes Name const char CR const char LF const char IS_EOF const char IS_BEGINNING_OF_THE_FILE const char IS_LAST_LINE_OF_SCREEN_TEXT const char IS_BEGINNING_OF_THE_LINE const char VI_LAST_LINE_EDITOR Last line used by the editor. const char VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE const char VI_COMMANDLINE_MAX_CHAR const char VI_MAX_LENGTH_FILE const char VI_EDITOR_CHAR_LIMITS_EMPTY const char VI_COMMANDLINE_VIDEO_ADRESS const char VI_EDITION_LAST_VIDEO_ADRESS const char VI_EDITION_VIDEO_ADRESS const char VI_EDITOR_MAX_LENGTH_OF_A_LINE const char VI_EDITOR_MAX_COLUMN const char vi_struct 2 bytes const char vi_ptr1 2 bytes const char vi_argv 2 bytes const char vi_argc 1 bytes const char vi_arg1 2 bytes const char vi_fp 2 bytes const char vi_ptr_file 2 bytes const char vi_tmp2 const char vi_ptr_screen 2 bytes const char vi_length_file 2 bytes const char vi_length_file_compute 2 bytes const char vi_tmp1 const char vi_fileopened const char vi_ptr_file_used 2 bytes const char tmp0_16 const char vi_no_opened_file const char vi_pos_debug const char vi_ptr2 2 bytes const char vi_savex 2 bytes const char vi_ptr3 2 bytes const char vi_tmp3 2 bytes Defines Name vi_dec16_zp (addr) Routine documentation Routine _vi _vi Attributes Documentation variable CR const char CR = $0D ; variable LF const char LF = $0A ; variable IS_EOF const char IS_EOF = $00 ; variable IS_BEGINNING_OF_THE_FILE const char IS_BEGINNING_OF_THE_FILE = $00 ; variable IS_LAST_LINE_OF_SCREEN_TEXT const char IS_LAST_LINE_OF_SCREEN_TEXT = $01 ; variable IS_BEGINNING_OF_THE_LINE const char IS_BEGINNING_OF_THE_LINE = $00 ; variable VI_LAST_LINE_EDITOR const char VI_LAST_LINE_EDITOR = 26 ; Last line used by the editor. variable VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE const char VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE = 0 ; variable VI_COMMANDLINE_MAX_CHAR const char VI_COMMANDLINE_MAX_CHAR = 8 ; variable VI_MAX_LENGTH_FILE const char VI_MAX_LENGTH_FILE = 2000 ; variable VI_EDITOR_CHAR_LIMITS_EMPTY const char VI_EDITOR_CHAR_LIMITS_EMPTY = '~' ; variable VI_COMMANDLINE_VIDEO_ADRESS const char VI_COMMANDLINE_VIDEO_ADRESS = $bb80 + 40 * 27 ; variable VI_EDITION_LAST_VIDEO_ADRESS const char VI_EDITION_LAST_VIDEO_ADRESS = $bb80 + 40 * 26 ; variable VI_EDITION_VIDEO_ADRESS const char VI_EDITION_VIDEO_ADRESS = $bb80 ; variable VI_EDITOR_MAX_LENGTH_OF_A_LINE const char VI_EDITOR_MAX_LENGTH_OF_A_LINE = 255 ; variable VI_EDITOR_MAX_COLUMN const char VI_EDITOR_MAX_COLUMN = 39 ; variable vi_struct const char vi_struct = userzp ; 2 bytes variable vi_ptr1 const char vi_ptr1 = userzp + 2 ; 2 bytes variable vi_argv const char vi_argv = userzp + 4 ; 2 bytes variable vi_argc const char vi_argc = userzp + 6 ; 1 bytes variable vi_arg1 const char vi_arg1 = userzp + 7 ; 2 bytes variable vi_fp const char vi_fp = userzp + 9 ; 2 bytes variable vi_ptr_file const char vi_ptr_file = userzp + 11 ; 2 bytes variable vi_tmp2 const char vi_tmp2 = userzp + 13 ; variable vi_ptr_screen const char vi_ptr_screen = userzp + 14 ; 2 bytes variable vi_length_file const char vi_length_file = userzp + 16 ; 2 bytes variable vi_length_file_compute const char vi_length_file_compute = userzp + 18 ; 2 bytes variable vi_tmp1 const char vi_tmp1 = userzp + 20 ; variable vi_fileopened const char vi_fileopened = userzp + 22 ; variable vi_ptr_file_used const char vi_ptr_file_used = userzp + 24 ; 2 bytes variable tmp0_16 const char tmp0_16 = userzp + 26 ; variable vi_no_opened_file const char vi_no_opened_file = userzp + 28 ; variable vi_pos_debug const char vi_pos_debug = userzp + 30 ; variable vi_ptr2 const char vi_ptr2 = userzp + 32 ; 2 bytes variable vi_savex const char vi_savex = userzp + 34 ; 2 bytes variable vi_ptr3 const char vi_ptr3 = userzp + 36 ; 2 bytes variable vi_tmp3 const char vi_tmp3 = userzp + 38 ; 2 bytes Macros Documentation define vi_dec16_zp # define vi_dec16_zp ( addr ) Source code ; Limits max line : 256 bytes ; Max file : VI_MAX_LENGTH_FILE (2000 bytes) ; max edit char per line : 39 ; Max 2KB pour un fichier (arbitraire) ; Pas de possibilit\u00e9 d'\u00e9diter une ligne de plus de 39 chars (donc pas de gestion de retour \u00e0 la ligne quand une ligne fait plus de 40 chars ; Quand on remonte ou quand on descend le curseur, il revient toujours \u00e0 la position X=0 m\u00eame si on \u00e9tait en milieu de ligne ; Pas de gestion du mode \u00e9crasement ; Pas de possibilit\u00e9 d'avoir une touche pour aller en fin de ligne ; g\u00e8re le mode windows pour les retours \u00e0 la ligne, et ne marchera pas en retour chariot unix .macro vi_dec16_zp addr lda addr ; 98 bne *+ 2 ; go to label dec addr + 1 ;label: dec addr .endmacro CR = $0D LF = $0A IS_EOF = $00 IS_BEGINNING_OF_THE_FILE = $00 IS_LAST_LINE_OF_SCREEN_TEXT = $01 IS_BEGINNING_OF_THE_LINE = $00 VI_LAST_LINE_EDITOR = 26 ; Last line used by the editor VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE = 0 VI_COMMANDLINE_MAX_CHAR = 8 VI_MAX_LENGTH_FILE = 2000 VI_EDITOR_CHAR_LIMITS_EMPTY = '~' VI_COMMANDLINE_VIDEO_ADRESS : = $bb80 + 40 * 27 VI_EDITION_LAST_VIDEO_ADRESS : = $bb80 + 40 * 26 VI_EDITION_VIDEO_ADRESS : = $bb80 VI_EDITOR_MAX_LENGTH_OF_A_LINE = 255 VI_EDITOR_MAX_COLUMN = 39 ;* labels prefixed with _ are populated from C*/ vi_struct : = userzp ; 2 bytes vi_ptr1 : = userzp + 2 ; 2 bytes vi_argv : = userzp + 4 ; 2 bytes vi_argc : = userzp + 6 ; 1 bytes vi_arg1 : = userzp + 7 ; 2 bytes vi_fp : = userzp + 9 ; 2 bytes vi_ptr_file : = userzp + 11 ; 2 bytes vi_tmp2 : = userzp + 13 vi_ptr_screen : = userzp + 14 ; 2 bytes vi_length_file : = userzp + 16 ; 2 bytes vi_length_file_compute : = userzp + 18 ; 2 bytes vi_tmp1 : = userzp + 20 vi_fileopened : = userzp + 22 vi_ptr_file_used : = userzp + 24 ; 2 bytes tmp0_16 : = userzp + 26 vi_no_opened_file : = userzp + 28 vi_pos_debug : = userzp + 30 vi_ptr2 : = userzp + 32 ; 2 bytes vi_savex : = userzp + 34 ; 2 bytes vi_ptr3 : = userzp + 36 ; 2 bytes vi_tmp3 : = userzp + 38 ; 2 bytes .include \"data/vi/strings.s\" .include \"Routines/vi_fill_screen_with_empty_line.s\" .include \"Routines/vi_struct.s\" .include \"Routines/vi_displays_info.s\" .include \"Routines/subfunc/vi/vi_init_vi_struct.s\" .include \"Routines/subfunc/vi/vi_ptr_last_char_plus_plus.s\" .include \"Routines/subfunc/vi/vi_ptr_last_char_sub_sub.s\" .include \"Routines/subfunc/vi/vi_set_ptr_last_char.s\" .include \"Routines/subfunc/vi/vi_ptr_last_char_add.s\" .include \"Routines/subfunc/vi/vi_vi_ptr_file_used_plus_plus.s\" .include \"Routines/subfunc/vi/vi_xpos_screen_plus_plus.s\" .include \"Routines/subfunc/vi/vi_xpos_screen_sub_sub.s\" .include \"Routines/subfunc/vi/vi_ypos_screen_sub_sub.s\" .include \"Routines/subfunc/vi/vi_ypos_screen_plus_plus.s\" .include \"Routines/subfunc/vi/vi_ptr_file_used_plus_plus.s\" .include \"Routines/subfunc/vi/vi_length_file_sub_sub.s\" .include \"Routines/subfunc/vi/vi_display_char.s\" .include \"Routines/subfunc/vi/vi_check_beginning_of_file.s\" .include \"Routines/subfunc/vi/vi_fill_last_line.s\" .include \"Routines/subfunc/vi/vi_copy_arg1_to_name_file_open.s\" .include \"Routines/subfunc/vi/vi_length_file_plus_plus.s\" .include \"Routines/subfunc/vi/vi_compute_video_adress.s\" .include \"Routines/subfunc/vi/vi_ptr_file_used_sub_sub.s\" .include \"Routines/subfunc/vi/vi_display_file_opened.s\" .include \"Routines/subfunc/vi/vi_check_0A.s\" .include \"Routines/subfunc/vi/vi_set_xpos_0.s\" .include \"Routines/subfunc/vi/vi_ptr_file_used_plus_plus_and_check_eof.s\" .include \"Routines/subfunc/vi/vi_search_next_line.s\" .include \"Routines/subfunc/vi/vi_shift_file_from_memory_one_char.s\" .include \"Routines/subfunc/vi/vi_check_inserted_char_overflow_the_max_column.s\" .include \"Routines/subfunc/vi/vi_scroll_from_left_to_right_full_line.s\" .include \"Routines/subfunc/vi/vi_shift_line_left_to_right_editor.s\" .include \"Routines/subfunc/vi/vi_search_previous_line_beginning.s\" .include \"Routines/subfunc/vi/vi_set_xpos_from_A.s\" .include \"Routines/subfunc/vi/vi_scroll_to_left.s\" .include \"Routines/subfunc/vi/vi_check_if_previous_line_was_truncated.s\" .include \"Routines/subfunc/vi/vi_search_previous_cr.s\" .include \"Routines/subfunc/vi/vi_add_char_to_text.s\" .include \"Routines/subfunc/vi/vi_strlen_current_line.s\" .include \"Routines/subfunc/vi/vi_compute_last_text_line.s\" .include \"Routines/subfunc/vi/vi_clear_command_line.s\" .include \"Routines/subfunc/vi/vi_key_down.s\" .include \"Routines/subfunc/vi/vi_key_enter.s\" .include \"Routines/subfunc/vi/vi_key_del.s\" .include \"Routines/subfunc/vi/vi_key_up.s\" .include \"Routines/subfunc/vi/vi_key_right.s\" .include \"Routines/subfunc/vi/vi_key_left.s\" .include \"Routines/subfunc/vi/vi_check_eof.s\" .include \"Routines/vi_put_char.s\" .include \"Routines/vi_command_edition.s\" .include \"Routines/vi_editor_switch_on_cursor.s\" .include \"Routines/vi_editor_switch_off_cursor.s\" .include \"Routines/vi_edition_keyboard.s\" .include \"Routines/vi_switch_to_edition_mode.s\" .include \"Routines/tables.s\" .include \"Routines/_clrscr_vi.s\" .proc _vi XMAINARGS = $2C XGETARGV = $2E argv : = userzp ; 2 bytes argc : = userzp + 2 ; 1 byte lda # $00 sta vi_no_opened_file lda # < $bb80 sta vi_ptr_screen lda # > $bb80 sta vi_ptr_screen + 1 lda # $00 sta vi_fileopened malloc .sizeof ( vi_struct_data ) cmp # NULL bne @not_oom2 cpy # NULL bne @not_oom2 print str_OOM ; oom rts @not_oom2: sta vi_struct sty vi_struct + 1 jsr vi_init_vi_struct initmainargs vi_argv , vi_argc , 0 lda vi_argc ; Do we have a file on the command line cmp # $01 beq not_opened_file getmainarg # 1 , ( vi_argv ) , vi_arg1 ; Checking if vi_arg1 is not empty ; when we type \"vi [space]\" on command line, initmainargs returns argv=2 but the arg is empty ; This is a fix to avoid this ldy # $00 @check_arg: lda ( vi_arg1 ), y beq not_opened_file @check_filename: fopen ( vi_arg1 ), O_RDONLY ,, vi_fp cpx # $FF bne opened_file cmp # $FF bne opened_file beq not_opened_file opened_file: lda # $01 sta vi_fileopened ; copy into name_file_open of the struct jsr vi_copy_arg1_to_name_file_open not_opened_file: cursor OFF jsr _clrscr_vi malloc # VI_MAX_LENGTH_FILE , vi_ptr_file ; $376B lda vi_ptr_file ; $3769 bne @ptr_file_continue lda vi_ptr_file + 1 bne @ptr_file_continue print str_OOM rts @ptr_file_continue: ; Set last char of the file ptr lda vi_ptr_file ldx vi_ptr_file + 1 jsr vi_set_ptr_last_char lda vi_ptr_file ; Contains the ptr $376B sta vi_ptr_file_used lda vi_ptr_file + 1 sta vi_ptr_file_used + 1 lda vi_fileopened beq @skip_loading ; Now load the file fread ( vi_ptr_file_used ), # VI_MAX_LENGTH_FILE , 1 , vi_fp ; myptr is from a malloc for example sta vi_length_file sta vi_length_file_compute stx vi_length_file + 1 stx vi_length_file_compute + 1 fclose ( vi_fp ) lda vi_ptr_file sta vi_ptr1 sta vi_ptr_file_used lda vi_ptr_file + 1 sta vi_ptr1 + 1 sta vi_ptr_file_used + 1 ; now set vi_ptr_last_char with the length of the file lda vi_length_file ldx vi_length_file + 1 jsr vi_ptr_last_char_add ; Check eof ; Dans le cas o\u00f9 on a charg\u00e9 avant un fichier, comme on ne s'arrete pas \u00e0 l'eof du fichier courant, cela va continuer a s'afficher alors m\u00eame qu'on est \u00e0 la fin du fichier ; Cela va afficher l'ancien fichier charg\u00e9. On compare donc pour s'arreter. jsr vi_display_file_opened @skip_fill_last_line: ldx # $01 ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y beq @no_compute ; First line ? Then X=1 in order to display ~ on the second line cmp # VI_LAST_LINE_EDITOR beq @no_empty_line_begin tax inx @no_compute: ldy # $01 jmp @display_empty_line_begin @skip_loading: ldy # $01 ; For a new_file ldx # $01 @display_empty_line_begin: jsr vi_fill_screen_with_empty_line @no_empty_line_begin: ; Set cursor position to 0,0 ldy # vi_struct_data: : ypos_screen lda # $00 sta ( vi_struct ), y ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y lda vi_ptr_file ; Contains the ptr sta vi_ptr_file_used lda vi_ptr_file + 1 sta vi_ptr_file_used + 1 @loop_until_esc_is_pressed: jsr vi_edition_keyboard cmp # $01 beq @final_exit jmp @loop_until_esc_is_pressed @final_exit: rts ; ********************************** str_OOM: .asciiz \"OOM\" ; FIXME import from general lib str_not_found: .asciiz \"File not found\" .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/commands/vi.s"},{"location":"tools_docs/vi/Files/vi_8s/#commandsvis","text":"","title":"/commands/vi.s"},{"location":"tools_docs/vi/Files/vi_8s/#routine","text":"Name _vi","title":"Routine"},{"location":"tools_docs/vi/Files/vi_8s/#attributes","text":"Name const char CR const char LF const char IS_EOF const char IS_BEGINNING_OF_THE_FILE const char IS_LAST_LINE_OF_SCREEN_TEXT const char IS_BEGINNING_OF_THE_LINE const char VI_LAST_LINE_EDITOR Last line used by the editor. const char VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE const char VI_COMMANDLINE_MAX_CHAR const char VI_MAX_LENGTH_FILE const char VI_EDITOR_CHAR_LIMITS_EMPTY const char VI_COMMANDLINE_VIDEO_ADRESS const char VI_EDITION_LAST_VIDEO_ADRESS const char VI_EDITION_VIDEO_ADRESS const char VI_EDITOR_MAX_LENGTH_OF_A_LINE const char VI_EDITOR_MAX_COLUMN const char vi_struct 2 bytes const char vi_ptr1 2 bytes const char vi_argv 2 bytes const char vi_argc 1 bytes const char vi_arg1 2 bytes const char vi_fp 2 bytes const char vi_ptr_file 2 bytes const char vi_tmp2 const char vi_ptr_screen 2 bytes const char vi_length_file 2 bytes const char vi_length_file_compute 2 bytes const char vi_tmp1 const char vi_fileopened const char vi_ptr_file_used 2 bytes const char tmp0_16 const char vi_no_opened_file const char vi_pos_debug const char vi_ptr2 2 bytes const char vi_savex 2 bytes const char vi_ptr3 2 bytes const char vi_tmp3 2 bytes","title":"Attributes"},{"location":"tools_docs/vi/Files/vi_8s/#defines","text":"Name vi_dec16_zp (addr)","title":"Defines"},{"location":"tools_docs/vi/Files/vi_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi_8s/#routine-_vi","text":"_vi","title":"Routine _vi"},{"location":"tools_docs/vi/Files/vi_8s/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"tools_docs/vi/Files/vi_8s/#variable-cr","text":"const char CR = $0D ;","title":"variable CR"},{"location":"tools_docs/vi/Files/vi_8s/#variable-lf","text":"const char LF = $0A ;","title":"variable LF"},{"location":"tools_docs/vi/Files/vi_8s/#variable-is_eof","text":"const char IS_EOF = $00 ;","title":"variable IS_EOF"},{"location":"tools_docs/vi/Files/vi_8s/#variable-is_beginning_of_the_file","text":"const char IS_BEGINNING_OF_THE_FILE = $00 ;","title":"variable IS_BEGINNING_OF_THE_FILE"},{"location":"tools_docs/vi/Files/vi_8s/#variable-is_last_line_of_screen_text","text":"const char IS_LAST_LINE_OF_SCREEN_TEXT = $01 ;","title":"variable IS_LAST_LINE_OF_SCREEN_TEXT"},{"location":"tools_docs/vi/Files/vi_8s/#variable-is_beginning_of_the_line","text":"const char IS_BEGINNING_OF_THE_LINE = $00 ;","title":"variable IS_BEGINNING_OF_THE_LINE"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_last_line_editor","text":"const char VI_LAST_LINE_EDITOR = 26 ; Last line used by the editor.","title":"variable VI_LAST_LINE_EDITOR"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_fill_screen_mode_stop_at_the_end_of_last_line","text":"const char VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE = 0 ;","title":"variable VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_commandline_max_char","text":"const char VI_COMMANDLINE_MAX_CHAR = 8 ;","title":"variable VI_COMMANDLINE_MAX_CHAR"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_max_length_file","text":"const char VI_MAX_LENGTH_FILE = 2000 ;","title":"variable VI_MAX_LENGTH_FILE"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_editor_char_limits_empty","text":"const char VI_EDITOR_CHAR_LIMITS_EMPTY = '~' ;","title":"variable VI_EDITOR_CHAR_LIMITS_EMPTY"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_commandline_video_adress","text":"const char VI_COMMANDLINE_VIDEO_ADRESS = $bb80 + 40 * 27 ;","title":"variable VI_COMMANDLINE_VIDEO_ADRESS"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_edition_last_video_adress","text":"const char VI_EDITION_LAST_VIDEO_ADRESS = $bb80 + 40 * 26 ;","title":"variable VI_EDITION_LAST_VIDEO_ADRESS"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_edition_video_adress","text":"const char VI_EDITION_VIDEO_ADRESS = $bb80 ;","title":"variable VI_EDITION_VIDEO_ADRESS"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_editor_max_length_of_a_line","text":"const char VI_EDITOR_MAX_LENGTH_OF_A_LINE = 255 ;","title":"variable VI_EDITOR_MAX_LENGTH_OF_A_LINE"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_editor_max_column","text":"const char VI_EDITOR_MAX_COLUMN = 39 ;","title":"variable VI_EDITOR_MAX_COLUMN"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_struct","text":"const char vi_struct = userzp ; 2 bytes","title":"variable vi_struct"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_ptr1","text":"const char vi_ptr1 = userzp + 2 ; 2 bytes","title":"variable vi_ptr1"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_argv","text":"const char vi_argv = userzp + 4 ; 2 bytes","title":"variable vi_argv"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_argc","text":"const char vi_argc = userzp + 6 ; 1 bytes","title":"variable vi_argc"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_arg1","text":"const char vi_arg1 = userzp + 7 ; 2 bytes","title":"variable vi_arg1"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_fp","text":"const char vi_fp = userzp + 9 ; 2 bytes","title":"variable vi_fp"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_ptr_file","text":"const char vi_ptr_file = userzp + 11 ; 2 bytes","title":"variable vi_ptr_file"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_tmp2","text":"const char vi_tmp2 = userzp + 13 ;","title":"variable vi_tmp2"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_ptr_screen","text":"const char vi_ptr_screen = userzp + 14 ; 2 bytes","title":"variable vi_ptr_screen"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_length_file","text":"const char vi_length_file = userzp + 16 ; 2 bytes","title":"variable vi_length_file"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_length_file_compute","text":"const char vi_length_file_compute = userzp + 18 ; 2 bytes","title":"variable vi_length_file_compute"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_tmp1","text":"const char vi_tmp1 = userzp + 20 ;","title":"variable vi_tmp1"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_fileopened","text":"const char vi_fileopened = userzp + 22 ;","title":"variable vi_fileopened"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_ptr_file_used","text":"const char vi_ptr_file_used = userzp + 24 ; 2 bytes","title":"variable vi_ptr_file_used"},{"location":"tools_docs/vi/Files/vi_8s/#variable-tmp0_16","text":"const char tmp0_16 = userzp + 26 ;","title":"variable tmp0_16"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_no_opened_file","text":"const char vi_no_opened_file = userzp + 28 ;","title":"variable vi_no_opened_file"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_pos_debug","text":"const char vi_pos_debug = userzp + 30 ;","title":"variable vi_pos_debug"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_ptr2","text":"const char vi_ptr2 = userzp + 32 ; 2 bytes","title":"variable vi_ptr2"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_savex","text":"const char vi_savex = userzp + 34 ; 2 bytes","title":"variable vi_savex"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_ptr3","text":"const char vi_ptr3 = userzp + 36 ; 2 bytes","title":"variable vi_ptr3"},{"location":"tools_docs/vi/Files/vi_8s/#variable-vi_tmp3","text":"const char vi_tmp3 = userzp + 38 ; 2 bytes","title":"variable vi_tmp3"},{"location":"tools_docs/vi/Files/vi_8s/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"tools_docs/vi/Files/vi_8s/#define-vi_dec16_zp","text":"# define vi_dec16_zp ( addr )","title":"define vi_dec16_zp"},{"location":"tools_docs/vi/Files/vi_8s/#source-code","text":"; Limits max line : 256 bytes ; Max file : VI_MAX_LENGTH_FILE (2000 bytes) ; max edit char per line : 39 ; Max 2KB pour un fichier (arbitraire) ; Pas de possibilit\u00e9 d'\u00e9diter une ligne de plus de 39 chars (donc pas de gestion de retour \u00e0 la ligne quand une ligne fait plus de 40 chars ; Quand on remonte ou quand on descend le curseur, il revient toujours \u00e0 la position X=0 m\u00eame si on \u00e9tait en milieu de ligne ; Pas de gestion du mode \u00e9crasement ; Pas de possibilit\u00e9 d'avoir une touche pour aller en fin de ligne ; g\u00e8re le mode windows pour les retours \u00e0 la ligne, et ne marchera pas en retour chariot unix .macro vi_dec16_zp addr lda addr ; 98 bne *+ 2 ; go to label dec addr + 1 ;label: dec addr .endmacro CR = $0D LF = $0A IS_EOF = $00 IS_BEGINNING_OF_THE_FILE = $00 IS_LAST_LINE_OF_SCREEN_TEXT = $01 IS_BEGINNING_OF_THE_LINE = $00 VI_LAST_LINE_EDITOR = 26 ; Last line used by the editor VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE = 0 VI_COMMANDLINE_MAX_CHAR = 8 VI_MAX_LENGTH_FILE = 2000 VI_EDITOR_CHAR_LIMITS_EMPTY = '~' VI_COMMANDLINE_VIDEO_ADRESS : = $bb80 + 40 * 27 VI_EDITION_LAST_VIDEO_ADRESS : = $bb80 + 40 * 26 VI_EDITION_VIDEO_ADRESS : = $bb80 VI_EDITOR_MAX_LENGTH_OF_A_LINE = 255 VI_EDITOR_MAX_COLUMN = 39 ;* labels prefixed with _ are populated from C*/ vi_struct : = userzp ; 2 bytes vi_ptr1 : = userzp + 2 ; 2 bytes vi_argv : = userzp + 4 ; 2 bytes vi_argc : = userzp + 6 ; 1 bytes vi_arg1 : = userzp + 7 ; 2 bytes vi_fp : = userzp + 9 ; 2 bytes vi_ptr_file : = userzp + 11 ; 2 bytes vi_tmp2 : = userzp + 13 vi_ptr_screen : = userzp + 14 ; 2 bytes vi_length_file : = userzp + 16 ; 2 bytes vi_length_file_compute : = userzp + 18 ; 2 bytes vi_tmp1 : = userzp + 20 vi_fileopened : = userzp + 22 vi_ptr_file_used : = userzp + 24 ; 2 bytes tmp0_16 : = userzp + 26 vi_no_opened_file : = userzp + 28 vi_pos_debug : = userzp + 30 vi_ptr2 : = userzp + 32 ; 2 bytes vi_savex : = userzp + 34 ; 2 bytes vi_ptr3 : = userzp + 36 ; 2 bytes vi_tmp3 : = userzp + 38 ; 2 bytes .include \"data/vi/strings.s\" .include \"Routines/vi_fill_screen_with_empty_line.s\" .include \"Routines/vi_struct.s\" .include \"Routines/vi_displays_info.s\" .include \"Routines/subfunc/vi/vi_init_vi_struct.s\" .include \"Routines/subfunc/vi/vi_ptr_last_char_plus_plus.s\" .include \"Routines/subfunc/vi/vi_ptr_last_char_sub_sub.s\" .include \"Routines/subfunc/vi/vi_set_ptr_last_char.s\" .include \"Routines/subfunc/vi/vi_ptr_last_char_add.s\" .include \"Routines/subfunc/vi/vi_vi_ptr_file_used_plus_plus.s\" .include \"Routines/subfunc/vi/vi_xpos_screen_plus_plus.s\" .include \"Routines/subfunc/vi/vi_xpos_screen_sub_sub.s\" .include \"Routines/subfunc/vi/vi_ypos_screen_sub_sub.s\" .include \"Routines/subfunc/vi/vi_ypos_screen_plus_plus.s\" .include \"Routines/subfunc/vi/vi_ptr_file_used_plus_plus.s\" .include \"Routines/subfunc/vi/vi_length_file_sub_sub.s\" .include \"Routines/subfunc/vi/vi_display_char.s\" .include \"Routines/subfunc/vi/vi_check_beginning_of_file.s\" .include \"Routines/subfunc/vi/vi_fill_last_line.s\" .include \"Routines/subfunc/vi/vi_copy_arg1_to_name_file_open.s\" .include \"Routines/subfunc/vi/vi_length_file_plus_plus.s\" .include \"Routines/subfunc/vi/vi_compute_video_adress.s\" .include \"Routines/subfunc/vi/vi_ptr_file_used_sub_sub.s\" .include \"Routines/subfunc/vi/vi_display_file_opened.s\" .include \"Routines/subfunc/vi/vi_check_0A.s\" .include \"Routines/subfunc/vi/vi_set_xpos_0.s\" .include \"Routines/subfunc/vi/vi_ptr_file_used_plus_plus_and_check_eof.s\" .include \"Routines/subfunc/vi/vi_search_next_line.s\" .include \"Routines/subfunc/vi/vi_shift_file_from_memory_one_char.s\" .include \"Routines/subfunc/vi/vi_check_inserted_char_overflow_the_max_column.s\" .include \"Routines/subfunc/vi/vi_scroll_from_left_to_right_full_line.s\" .include \"Routines/subfunc/vi/vi_shift_line_left_to_right_editor.s\" .include \"Routines/subfunc/vi/vi_search_previous_line_beginning.s\" .include \"Routines/subfunc/vi/vi_set_xpos_from_A.s\" .include \"Routines/subfunc/vi/vi_scroll_to_left.s\" .include \"Routines/subfunc/vi/vi_check_if_previous_line_was_truncated.s\" .include \"Routines/subfunc/vi/vi_search_previous_cr.s\" .include \"Routines/subfunc/vi/vi_add_char_to_text.s\" .include \"Routines/subfunc/vi/vi_strlen_current_line.s\" .include \"Routines/subfunc/vi/vi_compute_last_text_line.s\" .include \"Routines/subfunc/vi/vi_clear_command_line.s\" .include \"Routines/subfunc/vi/vi_key_down.s\" .include \"Routines/subfunc/vi/vi_key_enter.s\" .include \"Routines/subfunc/vi/vi_key_del.s\" .include \"Routines/subfunc/vi/vi_key_up.s\" .include \"Routines/subfunc/vi/vi_key_right.s\" .include \"Routines/subfunc/vi/vi_key_left.s\" .include \"Routines/subfunc/vi/vi_check_eof.s\" .include \"Routines/vi_put_char.s\" .include \"Routines/vi_command_edition.s\" .include \"Routines/vi_editor_switch_on_cursor.s\" .include \"Routines/vi_editor_switch_off_cursor.s\" .include \"Routines/vi_edition_keyboard.s\" .include \"Routines/vi_switch_to_edition_mode.s\" .include \"Routines/tables.s\" .include \"Routines/_clrscr_vi.s\" .proc _vi XMAINARGS = $2C XGETARGV = $2E argv : = userzp ; 2 bytes argc : = userzp + 2 ; 1 byte lda # $00 sta vi_no_opened_file lda # < $bb80 sta vi_ptr_screen lda # > $bb80 sta vi_ptr_screen + 1 lda # $00 sta vi_fileopened malloc .sizeof ( vi_struct_data ) cmp # NULL bne @not_oom2 cpy # NULL bne @not_oom2 print str_OOM ; oom rts @not_oom2: sta vi_struct sty vi_struct + 1 jsr vi_init_vi_struct initmainargs vi_argv , vi_argc , 0 lda vi_argc ; Do we have a file on the command line cmp # $01 beq not_opened_file getmainarg # 1 , ( vi_argv ) , vi_arg1 ; Checking if vi_arg1 is not empty ; when we type \"vi [space]\" on command line, initmainargs returns argv=2 but the arg is empty ; This is a fix to avoid this ldy # $00 @check_arg: lda ( vi_arg1 ), y beq not_opened_file @check_filename: fopen ( vi_arg1 ), O_RDONLY ,, vi_fp cpx # $FF bne opened_file cmp # $FF bne opened_file beq not_opened_file opened_file: lda # $01 sta vi_fileopened ; copy into name_file_open of the struct jsr vi_copy_arg1_to_name_file_open not_opened_file: cursor OFF jsr _clrscr_vi malloc # VI_MAX_LENGTH_FILE , vi_ptr_file ; $376B lda vi_ptr_file ; $3769 bne @ptr_file_continue lda vi_ptr_file + 1 bne @ptr_file_continue print str_OOM rts @ptr_file_continue: ; Set last char of the file ptr lda vi_ptr_file ldx vi_ptr_file + 1 jsr vi_set_ptr_last_char lda vi_ptr_file ; Contains the ptr $376B sta vi_ptr_file_used lda vi_ptr_file + 1 sta vi_ptr_file_used + 1 lda vi_fileopened beq @skip_loading ; Now load the file fread ( vi_ptr_file_used ), # VI_MAX_LENGTH_FILE , 1 , vi_fp ; myptr is from a malloc for example sta vi_length_file sta vi_length_file_compute stx vi_length_file + 1 stx vi_length_file_compute + 1 fclose ( vi_fp ) lda vi_ptr_file sta vi_ptr1 sta vi_ptr_file_used lda vi_ptr_file + 1 sta vi_ptr1 + 1 sta vi_ptr_file_used + 1 ; now set vi_ptr_last_char with the length of the file lda vi_length_file ldx vi_length_file + 1 jsr vi_ptr_last_char_add ; Check eof ; Dans le cas o\u00f9 on a charg\u00e9 avant un fichier, comme on ne s'arrete pas \u00e0 l'eof du fichier courant, cela va continuer a s'afficher alors m\u00eame qu'on est \u00e0 la fin du fichier ; Cela va afficher l'ancien fichier charg\u00e9. On compare donc pour s'arreter. jsr vi_display_file_opened @skip_fill_last_line: ldx # $01 ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y beq @no_compute ; First line ? Then X=1 in order to display ~ on the second line cmp # VI_LAST_LINE_EDITOR beq @no_empty_line_begin tax inx @no_compute: ldy # $01 jmp @display_empty_line_begin @skip_loading: ldy # $01 ; For a new_file ldx # $01 @display_empty_line_begin: jsr vi_fill_screen_with_empty_line @no_empty_line_begin: ; Set cursor position to 0,0 ldy # vi_struct_data: : ypos_screen lda # $00 sta ( vi_struct ), y ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y lda vi_ptr_file ; Contains the ptr sta vi_ptr_file_used lda vi_ptr_file + 1 sta vi_ptr_file_used + 1 @loop_until_esc_is_pressed: jsr vi_edition_keyboard cmp # $01 beq @final_exit jmp @loop_until_esc_is_pressed @final_exit: rts ; ********************************** str_OOM: .asciiz \"OOM\" ; FIXME import from general lib str_not_found: .asciiz \"File not found\" .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__add__char__to__text_8s/","text":"vi_add_char_to_text.s Routine Name vi_add_char_to_text Routine documentation Routine vi_add_char_to_text vi_add_char_to_text Source code .proc vi_add_char_to_text ; Ajoute un caract\u00e8re dans le texte pha jsr vi_ptr_last_char_plus_plus jsr vi_shift_file_from_memory_one_char ; shift one char the text file in the memory ldy # $00 pla sta ( vi_ptr_file_used ), y ; store \\n jsr vi_ptr_file_used_plus_plus jsr vi_length_file_plus_plus rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_add_char_to_text.s"},{"location":"tools_docs/vi/Files/vi__add__char__to__text_8s/#vi_add_char_to_texts","text":"","title":"vi_add_char_to_text.s"},{"location":"tools_docs/vi/Files/vi__add__char__to__text_8s/#routine","text":"Name vi_add_char_to_text","title":"Routine"},{"location":"tools_docs/vi/Files/vi__add__char__to__text_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__add__char__to__text_8s/#routine-vi_add_char_to_text","text":"vi_add_char_to_text","title":"Routine vi_add_char_to_text"},{"location":"tools_docs/vi/Files/vi__add__char__to__text_8s/#source-code","text":".proc vi_add_char_to_text ; Ajoute un caract\u00e8re dans le texte pha jsr vi_ptr_last_char_plus_plus jsr vi_shift_file_from_memory_one_char ; shift one char the text file in the memory ldy # $00 pla sta ( vi_ptr_file_used ), y ; store \\n jsr vi_ptr_file_used_plus_plus jsr vi_length_file_plus_plus rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__check__0A_8s/","text":"vi_check_0A.s Routine Name vi_check_0A Routine documentation Routine vi_check_0A vi_check_0A Source code .proc vi_check_0A ; jmp vi_check_0A ; $c398 lda ( vi_ptr_file_used ), y cmp # $0A beq @exit_advance_after_LF rts @exit_advance_after_LF: jsr vi_vi_ptr_file_used_plus_plus rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_check_0A.s"},{"location":"tools_docs/vi/Files/vi__check__0A_8s/#vi_check_0as","text":"","title":"vi_check_0A.s"},{"location":"tools_docs/vi/Files/vi__check__0A_8s/#routine","text":"Name vi_check_0A","title":"Routine"},{"location":"tools_docs/vi/Files/vi__check__0A_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__check__0A_8s/#routine-vi_check_0a","text":"vi_check_0A","title":"Routine vi_check_0A"},{"location":"tools_docs/vi/Files/vi__check__0A_8s/#source-code","text":".proc vi_check_0A ; jmp vi_check_0A ; $c398 lda ( vi_ptr_file_used ), y cmp # $0A beq @exit_advance_after_LF rts @exit_advance_after_LF: jsr vi_vi_ptr_file_used_plus_plus rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__check__beginning__of__file_8s/","text":"vi_check_beginning_of_file.s Routine Name vi_check_beginning_of_file Routine documentation Routine vi_check_beginning_of_file vi_check_beginning_of_file Source code ; A returns 00 if beginning of the file, 01 if not .proc vi_check_beginning_of_file lda vi_ptr_file_used cmp vi_ptr_file bne @not_beginning lda vi_ptr_file_used + 1 cmp vi_ptr_file + 1 bne @not_beginning lda # IS_BEGINNING_OF_THE_FILE ; Beginninng of the file rts @not_beginning: lda # $01 ; Not the Beginninng of the file rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_check_beginning_of_file.s"},{"location":"tools_docs/vi/Files/vi__check__beginning__of__file_8s/#vi_check_beginning_of_files","text":"","title":"vi_check_beginning_of_file.s"},{"location":"tools_docs/vi/Files/vi__check__beginning__of__file_8s/#routine","text":"Name vi_check_beginning_of_file","title":"Routine"},{"location":"tools_docs/vi/Files/vi__check__beginning__of__file_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__check__beginning__of__file_8s/#routine-vi_check_beginning_of_file","text":"vi_check_beginning_of_file","title":"Routine vi_check_beginning_of_file"},{"location":"tools_docs/vi/Files/vi__check__beginning__of__file_8s/#source-code","text":"; A returns 00 if beginning of the file, 01 if not .proc vi_check_beginning_of_file lda vi_ptr_file_used cmp vi_ptr_file bne @not_beginning lda vi_ptr_file_used + 1 cmp vi_ptr_file + 1 bne @not_beginning lda # IS_BEGINNING_OF_THE_FILE ; Beginninng of the file rts @not_beginning: lda # $01 ; Not the Beginninng of the file rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__check__eof_8s/","text":"vi_check_eof.s Routine Name vi_check_eof Routine documentation Routine vi_check_eof vi_check_eof Source code .proc vi_check_eof ; return in A 00 if eof ; returns in A 01 if not eof ; Do we reached eof ? ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr_file_used cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr_file_used + 1 cmp vi_tmp1 bne @not_eof @is_eof: lda # IS_EOF ; EOF rts @is_eof_before: jsr vi_ptr_file_used_plus_plus jmp @is_eof @not_eof: @not_last_line: lda # $01 ; Not eof rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_check_eof.s"},{"location":"tools_docs/vi/Files/vi__check__eof_8s/#vi_check_eofs","text":"","title":"vi_check_eof.s"},{"location":"tools_docs/vi/Files/vi__check__eof_8s/#routine","text":"Name vi_check_eof","title":"Routine"},{"location":"tools_docs/vi/Files/vi__check__eof_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__check__eof_8s/#routine-vi_check_eof","text":"vi_check_eof","title":"Routine vi_check_eof"},{"location":"tools_docs/vi/Files/vi__check__eof_8s/#source-code","text":".proc vi_check_eof ; return in A 00 if eof ; returns in A 01 if not eof ; Do we reached eof ? ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr_file_used cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr_file_used + 1 cmp vi_tmp1 bne @not_eof @is_eof: lda # IS_EOF ; EOF rts @is_eof_before: jsr vi_ptr_file_used_plus_plus jmp @is_eof @not_eof: @not_last_line: lda # $01 ; Not eof rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__check__if__previous__line__was__truncated_8s/","text":"vi_check_if_previous_line_was_truncated.s Routine Name vi_check_if_previous_line_was_truncated Routine documentation Routine vi_check_if_previous_line_was_truncated vi_check_if_previous_line_was_truncated Source code .proc vi_check_if_previous_line_was_truncated lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 ;vi_dec16_zp vi_ptr1 lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 ldy # $00 lda ( vi_ptr1 ), y cmp # $0A beq @exit jsr vi_ptr_file_used_plus_plus @exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_check_if_previous_line_was_truncated.s"},{"location":"tools_docs/vi/Files/vi__check__if__previous__line__was__truncated_8s/#vi_check_if_previous_line_was_truncateds","text":"","title":"vi_check_if_previous_line_was_truncated.s"},{"location":"tools_docs/vi/Files/vi__check__if__previous__line__was__truncated_8s/#routine","text":"Name vi_check_if_previous_line_was_truncated","title":"Routine"},{"location":"tools_docs/vi/Files/vi__check__if__previous__line__was__truncated_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__check__if__previous__line__was__truncated_8s/#routine-vi_check_if_previous_line_was_truncated","text":"vi_check_if_previous_line_was_truncated","title":"Routine vi_check_if_previous_line_was_truncated"},{"location":"tools_docs/vi/Files/vi__check__if__previous__line__was__truncated_8s/#source-code","text":".proc vi_check_if_previous_line_was_truncated lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 ;vi_dec16_zp vi_ptr1 lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 ldy # $00 lda ( vi_ptr1 ), y cmp # $0A beq @exit jsr vi_ptr_file_used_plus_plus @exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__check__inserted__char__overflow__the__max__column_8s/","text":"vi_check_inserted_char_overflow_the_max_column.s Routine Name vi_check_inserted_char_overflow_the_max_column Routine documentation Routine vi_check_inserted_char_overflow_the_max_column vi_check_inserted_char_overflow_the_max_column Source code .proc vi_check_inserted_char_overflow_the_max_column ; Pas d'arg en entr\u00e9e ; Cette routine renvoie dans ; A=0 si on a un texte qui ne d\u00e9passe pas 40 colonnes ; A=1 si on a une ligne texte qui d\u00e9passe la ligne de 40 colonnes et X contient le nb de lignes sur l'\u00e9diteur de cette ligne texte ; A=2 si on a une ligne de plus de 256 chars : overflow ; A=3 si cela la ligne fait exactement 1 ligne, il faudra donc scroller lda # $00 sta vi_tmp1 lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tax dex stx vi_tmp3 ldy # $00 @L1: lda ( vi_ptr1 ), y cmp # CR beq @exit inx cpx # VI_EDITOR_MAX_COLUMN + 1 bne @continue inc vi_tmp1 ldx # $00 @continue: inc vi_tmp3 iny bne @L1 lda # $02 ; Overflow rts @exit: lda vi_tmp3 cmp # VI_EDITOR_MAX_COLUMN + 1 beq @exactly_a_new_line ldx vi_tmp1 beq @no_line_editor_overflow lda # $01 rts @no_line_editor_overflow: lda # $00 rts @exactly_a_new_line: lda # $03 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_check_inserted_char_overflow_the_max_column.s"},{"location":"tools_docs/vi/Files/vi__check__inserted__char__overflow__the__max__column_8s/#vi_check_inserted_char_overflow_the_max_columns","text":"","title":"vi_check_inserted_char_overflow_the_max_column.s"},{"location":"tools_docs/vi/Files/vi__check__inserted__char__overflow__the__max__column_8s/#routine","text":"Name vi_check_inserted_char_overflow_the_max_column","title":"Routine"},{"location":"tools_docs/vi/Files/vi__check__inserted__char__overflow__the__max__column_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__check__inserted__char__overflow__the__max__column_8s/#routine-vi_check_inserted_char_overflow_the_max_column","text":"vi_check_inserted_char_overflow_the_max_column","title":"Routine vi_check_inserted_char_overflow_the_max_column"},{"location":"tools_docs/vi/Files/vi__check__inserted__char__overflow__the__max__column_8s/#source-code","text":".proc vi_check_inserted_char_overflow_the_max_column ; Pas d'arg en entr\u00e9e ; Cette routine renvoie dans ; A=0 si on a un texte qui ne d\u00e9passe pas 40 colonnes ; A=1 si on a une ligne texte qui d\u00e9passe la ligne de 40 colonnes et X contient le nb de lignes sur l'\u00e9diteur de cette ligne texte ; A=2 si on a une ligne de plus de 256 chars : overflow ; A=3 si cela la ligne fait exactement 1 ligne, il faudra donc scroller lda # $00 sta vi_tmp1 lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tax dex stx vi_tmp3 ldy # $00 @L1: lda ( vi_ptr1 ), y cmp # CR beq @exit inx cpx # VI_EDITOR_MAX_COLUMN + 1 bne @continue inc vi_tmp1 ldx # $00 @continue: inc vi_tmp3 iny bne @L1 lda # $02 ; Overflow rts @exit: lda vi_tmp3 cmp # VI_EDITOR_MAX_COLUMN + 1 beq @exactly_a_new_line ldx vi_tmp1 beq @no_line_editor_overflow lda # $01 rts @no_line_editor_overflow: lda # $00 rts @exactly_a_new_line: lda # $03 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__clear__command__line_8s/","text":"vi_clear_command_line.s Routine Name vi_clear_command_line Routine documentation Routine vi_clear_command_line vi_clear_command_line Source code .proc vi_clear_command_line ldx # 40 lda # $00 ; Set command line with 0 @loop: sta VI_COMMANDLINE_VIDEO_ADRESS , x dex bpl @loop rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_clear_command_line.s"},{"location":"tools_docs/vi/Files/vi__clear__command__line_8s/#vi_clear_command_lines","text":"","title":"vi_clear_command_line.s"},{"location":"tools_docs/vi/Files/vi__clear__command__line_8s/#routine","text":"Name vi_clear_command_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__clear__command__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__clear__command__line_8s/#routine-vi_clear_command_line","text":"vi_clear_command_line","title":"Routine vi_clear_command_line"},{"location":"tools_docs/vi/Files/vi__clear__command__line_8s/#source-code","text":".proc vi_clear_command_line ldx # 40 lda # $00 ; Set command line with 0 @loop: sta VI_COMMANDLINE_VIDEO_ADRESS , x dex bpl @loop rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__command__edition_8s/","text":"/Routines/vi_command_edition.s Routine Name vi_command_edition Routine documentation Routine vi_command_edition vi_command_edition Source code .proc vi_command_edition jsr vi_clear_command_line ldy # vi_struct_data: : xpos_command_line lda # $01 sta ( vi_struct ), y lda # ':' sta VI_COMMANDLINE_VIDEO_ADRESS ldy # vi_struct_data: : command_line_buffer sta ( vi_struct ), y ; Insert : @read_keyboard: cgetc cmp # KEY_RIGHT beq @read_keyboard cmp # KEY_LEFT beq @read_keyboard cmp # KEY_UP beq @read_keyboard cmp # KEY_DOWN beq @read_keyboard cmp # KEY_ESC beq @exit cmp # KEY_DEL beq @del cmp # KEY_RETURN beq @execute_command_line sta vi_tmp1 ldy # vi_struct_data: : xpos_command_line lda ( vi_struct ), y cmp # 39 ; End of line ? beq @read_keyboard tay lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny tya ldy # vi_struct_data: : xpos_command_line sta ( vi_struct ), y jmp @read_keyboard @exit: jsr vi_clear_command_line lda # $00 rts @del: ldy # vi_struct_data: : xpos_command_line lda ( vi_struct ), y cmp # $01 beq @erase_char_and_exit ; Erase char on screen pha tay lda # ' ' dey sta VI_COMMANDLINE_VIDEO_ADRESS , y pla ; Erase char into command_line_buffer pha clc adc # vi_struct_data: : command_line_buffer tay lda # $00 ; EOS sta ( vi_struct ), y ; Insert : pla ; dec pos tay dey tya ldy # vi_struct_data: : xpos_command_line sta ( vi_struct ), y jmp @read_keyboard @erase_char_and_exit: lda # ' ' sta VI_COMMANDLINE_VIDEO_ADRESS lda # $00 rts @execute_command_line: ldy # $01 @read_commandline: sty vi_tmp2 lda VI_COMMANDLINE_VIDEO_ADRESS , y cmp # 'q' beq @exit_vi cmp # 'w' beq @write_file cmp # KEY_ESC beq @key_esc lda # $00 rts @key_esc: jsr vi_clear_command_line lda # $00 rts @exit_vi: lda # $01 rts @write_file: sty vi_tmp2 ; Check if we have an arg (filename) iny lda VI_COMMANDLINE_VIDEO_ADRESS , y cmp # ' ' ; If it's a space after w, then there is an arg beq @filename_in_argument @file_inserted: dey lda vi_fileopened beq @display_missing_filename ; lda vi_struct+1 ; sta vi_arg1+1 ; lda #vi_struct_data::name_file_open ; clc ; adc vi_struct ; bcc @no_inc_arg1 ; inc vi_arg1+1 ; @no_inc_arg1: ; sta vi_arg1 jsr @vi_open_and_write_file ; Clear jsr vi_clear_command_line ldy # $00 @loop_written: lda msg_written , y beq @out sta VI_COMMANDLINE_VIDEO_ADRESS , y iny jmp @loop_written @out: ldy vi_tmp2 iny jmp @read_commandline @filename_in_argument: iny ; skip space tya tax lda # $01 sta vi_fileopened ldy # vi_struct_data: : name_file_open @loop_copy_filename: lda VI_COMMANDLINE_VIDEO_ADRESS , x beq @exit_copy_filename cmp # ' ' beq @exit_copy_filename sta ( vi_struct ), y inx iny cpy # VI_MAX_LENGTH_FILENAME + vi_struct_data: : name_file_open bne @loop_copy_filename @exit_copy_filename: lda # $00 ; EOS if overflow sta ( vi_struct ), y txa tay jmp @file_inserted @display_missing_filename: ldy # $00 @loop_written2: lda msg_nofilename , y beq @out2 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny jmp @loop_written2 @out2: rts @vi_open_and_write_file: lda vi_struct + 1 sta vi_ptr1 + 1 lda # vi_struct_data: : name_file_open clc adc vi_struct bcc @no_inc_vi_ptr1 inc vi_ptr1 + 1 @no_inc_vi_ptr1: sta vi_ptr1 fopen ( vi_ptr1 ), O_CREAT | O_WRONLY ,, vi_fp cpx # $FF bne @opened_file cmp # $FF bne @opened_file beq @error_writing_file @opened_file: ; get length file ; ldy #vi_struct_data::length_file ; lda (vi_struct),y ;sta vi_length_file ;iny ;lda (vi_struct),y ;sta vi_length_file+1 ;dec vi_length_file ; @me: ; jmp @me fwrite ( vi_ptr_file ), ( vi_length_file ), 1 , vi_fp ; myptr is from a malloc for example fclose ( vi_fp ) rts @error_writing_file: print str_error jmp @error_writing_file rts str_error: .asciiz \"Error\" .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_command_edition.s"},{"location":"tools_docs/vi/Files/vi__command__edition_8s/#routinesvi_command_editions","text":"","title":"/Routines/vi_command_edition.s"},{"location":"tools_docs/vi/Files/vi__command__edition_8s/#routine","text":"Name vi_command_edition","title":"Routine"},{"location":"tools_docs/vi/Files/vi__command__edition_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__command__edition_8s/#routine-vi_command_edition","text":"vi_command_edition","title":"Routine vi_command_edition"},{"location":"tools_docs/vi/Files/vi__command__edition_8s/#source-code","text":".proc vi_command_edition jsr vi_clear_command_line ldy # vi_struct_data: : xpos_command_line lda # $01 sta ( vi_struct ), y lda # ':' sta VI_COMMANDLINE_VIDEO_ADRESS ldy # vi_struct_data: : command_line_buffer sta ( vi_struct ), y ; Insert : @read_keyboard: cgetc cmp # KEY_RIGHT beq @read_keyboard cmp # KEY_LEFT beq @read_keyboard cmp # KEY_UP beq @read_keyboard cmp # KEY_DOWN beq @read_keyboard cmp # KEY_ESC beq @exit cmp # KEY_DEL beq @del cmp # KEY_RETURN beq @execute_command_line sta vi_tmp1 ldy # vi_struct_data: : xpos_command_line lda ( vi_struct ), y cmp # 39 ; End of line ? beq @read_keyboard tay lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny tya ldy # vi_struct_data: : xpos_command_line sta ( vi_struct ), y jmp @read_keyboard @exit: jsr vi_clear_command_line lda # $00 rts @del: ldy # vi_struct_data: : xpos_command_line lda ( vi_struct ), y cmp # $01 beq @erase_char_and_exit ; Erase char on screen pha tay lda # ' ' dey sta VI_COMMANDLINE_VIDEO_ADRESS , y pla ; Erase char into command_line_buffer pha clc adc # vi_struct_data: : command_line_buffer tay lda # $00 ; EOS sta ( vi_struct ), y ; Insert : pla ; dec pos tay dey tya ldy # vi_struct_data: : xpos_command_line sta ( vi_struct ), y jmp @read_keyboard @erase_char_and_exit: lda # ' ' sta VI_COMMANDLINE_VIDEO_ADRESS lda # $00 rts @execute_command_line: ldy # $01 @read_commandline: sty vi_tmp2 lda VI_COMMANDLINE_VIDEO_ADRESS , y cmp # 'q' beq @exit_vi cmp # 'w' beq @write_file cmp # KEY_ESC beq @key_esc lda # $00 rts @key_esc: jsr vi_clear_command_line lda # $00 rts @exit_vi: lda # $01 rts @write_file: sty vi_tmp2 ; Check if we have an arg (filename) iny lda VI_COMMANDLINE_VIDEO_ADRESS , y cmp # ' ' ; If it's a space after w, then there is an arg beq @filename_in_argument @file_inserted: dey lda vi_fileopened beq @display_missing_filename ; lda vi_struct+1 ; sta vi_arg1+1 ; lda #vi_struct_data::name_file_open ; clc ; adc vi_struct ; bcc @no_inc_arg1 ; inc vi_arg1+1 ; @no_inc_arg1: ; sta vi_arg1 jsr @vi_open_and_write_file ; Clear jsr vi_clear_command_line ldy # $00 @loop_written: lda msg_written , y beq @out sta VI_COMMANDLINE_VIDEO_ADRESS , y iny jmp @loop_written @out: ldy vi_tmp2 iny jmp @read_commandline @filename_in_argument: iny ; skip space tya tax lda # $01 sta vi_fileopened ldy # vi_struct_data: : name_file_open @loop_copy_filename: lda VI_COMMANDLINE_VIDEO_ADRESS , x beq @exit_copy_filename cmp # ' ' beq @exit_copy_filename sta ( vi_struct ), y inx iny cpy # VI_MAX_LENGTH_FILENAME + vi_struct_data: : name_file_open bne @loop_copy_filename @exit_copy_filename: lda # $00 ; EOS if overflow sta ( vi_struct ), y txa tay jmp @file_inserted @display_missing_filename: ldy # $00 @loop_written2: lda msg_nofilename , y beq @out2 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny jmp @loop_written2 @out2: rts @vi_open_and_write_file: lda vi_struct + 1 sta vi_ptr1 + 1 lda # vi_struct_data: : name_file_open clc adc vi_struct bcc @no_inc_vi_ptr1 inc vi_ptr1 + 1 @no_inc_vi_ptr1: sta vi_ptr1 fopen ( vi_ptr1 ), O_CREAT | O_WRONLY ,, vi_fp cpx # $FF bne @opened_file cmp # $FF bne @opened_file beq @error_writing_file @opened_file: ; get length file ; ldy #vi_struct_data::length_file ; lda (vi_struct),y ;sta vi_length_file ;iny ;lda (vi_struct),y ;sta vi_length_file+1 ;dec vi_length_file ; @me: ; jmp @me fwrite ( vi_ptr_file ), ( vi_length_file ), 1 , vi_fp ; myptr is from a malloc for example fclose ( vi_fp ) rts @error_writing_file: print str_error jmp @error_writing_file rts str_error: .asciiz \"Error\" .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__compute__last__text__line_8s/","text":"vi_compute_last_text_line.s Routine Name vi_compute_last_text_line Routine documentation Routine vi_compute_last_text_line vi_compute_last_text_line Source code .proc vi_compute_last_text_line ; A & Y the current ptr ; X the id of the text line ? sta vi_ptr2 sty vi_ptr2 + 1 stx vi_tmp2 lda # VI_LAST_LINE_EDITOR sec sbc vi_tmp2 sta vi_tmp2 @L1: jsr check_eof_vi_ptr2 cmp # IS_EOF beq @exit ldy # $00 lda ( vi_ptr2 ), y cmp # CR beq @found @continue: inc vi_ptr2 bne @out_compare inc vi_ptr2 + 1 @out_compare: jmp @L1 @found: inc vi_ptr2 bne @out_compare2 inc vi_ptr2 + 1 @out_compare2: jsr check_eof_vi_ptr2 cmp # IS_EOF beq @exit lda ( vi_ptr2 ), y cmp # LF bne @S1 inc vi_ptr2 bne @out_compare3 inc vi_ptr2 + 1 @out_compare3: jsr check_eof_vi_ptr2 cmp # IS_EOF beq @exit @S1: dec vi_tmp2 bne @continue @exit: lda vi_ptr2 ldy vi_ptr2 + 1 rts check_eof_vi_ptr2: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr2 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr2 + 1 cmp vi_tmp1 bne @not_eof lda # IS_EOF rts @not_eof: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_compute_last_text_line.s"},{"location":"tools_docs/vi/Files/vi__compute__last__text__line_8s/#vi_compute_last_text_lines","text":"","title":"vi_compute_last_text_line.s"},{"location":"tools_docs/vi/Files/vi__compute__last__text__line_8s/#routine","text":"Name vi_compute_last_text_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__compute__last__text__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__compute__last__text__line_8s/#routine-vi_compute_last_text_line","text":"vi_compute_last_text_line","title":"Routine vi_compute_last_text_line"},{"location":"tools_docs/vi/Files/vi__compute__last__text__line_8s/#source-code","text":".proc vi_compute_last_text_line ; A & Y the current ptr ; X the id of the text line ? sta vi_ptr2 sty vi_ptr2 + 1 stx vi_tmp2 lda # VI_LAST_LINE_EDITOR sec sbc vi_tmp2 sta vi_tmp2 @L1: jsr check_eof_vi_ptr2 cmp # IS_EOF beq @exit ldy # $00 lda ( vi_ptr2 ), y cmp # CR beq @found @continue: inc vi_ptr2 bne @out_compare inc vi_ptr2 + 1 @out_compare: jmp @L1 @found: inc vi_ptr2 bne @out_compare2 inc vi_ptr2 + 1 @out_compare2: jsr check_eof_vi_ptr2 cmp # IS_EOF beq @exit lda ( vi_ptr2 ), y cmp # LF bne @S1 inc vi_ptr2 bne @out_compare3 inc vi_ptr2 + 1 @out_compare3: jsr check_eof_vi_ptr2 cmp # IS_EOF beq @exit @S1: dec vi_tmp2 bne @continue @exit: lda vi_ptr2 ldy vi_ptr2 + 1 rts check_eof_vi_ptr2: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr2 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr2 + 1 cmp vi_tmp1 bne @not_eof lda # IS_EOF rts @not_eof: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__compute__video__adress_8s/","text":"vi_compute_video_adress.s Routine Name vi_compute_video_adress Routine documentation Routine vi_compute_video_adress vi_compute_video_adress Source code .proc vi_compute_video_adress ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tay lda TABLE_LOW_TEXT , y sta vi_ptr_screen lda TABLE_HIGH_TEXT , y sta vi_ptr_screen + 1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_compute_video_adress.s"},{"location":"tools_docs/vi/Files/vi__compute__video__adress_8s/#vi_compute_video_adresss","text":"","title":"vi_compute_video_adress.s"},{"location":"tools_docs/vi/Files/vi__compute__video__adress_8s/#routine","text":"Name vi_compute_video_adress","title":"Routine"},{"location":"tools_docs/vi/Files/vi__compute__video__adress_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__compute__video__adress_8s/#routine-vi_compute_video_adress","text":"vi_compute_video_adress","title":"Routine vi_compute_video_adress"},{"location":"tools_docs/vi/Files/vi__compute__video__adress_8s/#source-code","text":".proc vi_compute_video_adress ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tay lda TABLE_LOW_TEXT , y sta vi_ptr_screen lda TABLE_HIGH_TEXT , y sta vi_ptr_screen + 1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__copy__arg1__to__name__file__open_8s/","text":"vi_copy_arg1_to_name_file_open.s Routine Name vi_copy_arg1_to_name_file_open Routine documentation Routine vi_copy_arg1_to_name_file_open vi_copy_arg1_to_name_file_open Source code .proc vi_copy_arg1_to_name_file_open ldy # $00 sty vi_tmp1 ldy # vi_struct_data: : name_file_open sty vi_tmp2 @loop_copy_filename: ldy vi_tmp1 lda ( vi_arg1 ), y beq @exit_copy_filename iny sty vi_tmp1 ldy vi_tmp2 sta ( vi_struct ), y iny sty vi_tmp2 cpy # VI_MAX_LENGTH_FILENAME + vi_struct_data: : name_file_open bne @loop_copy_filename lda # $00 ; EOS if overflow @exit_copy_filename: ldy vi_tmp2 sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_copy_arg1_to_name_file_open.s"},{"location":"tools_docs/vi/Files/vi__copy__arg1__to__name__file__open_8s/#vi_copy_arg1_to_name_file_opens","text":"","title":"vi_copy_arg1_to_name_file_open.s"},{"location":"tools_docs/vi/Files/vi__copy__arg1__to__name__file__open_8s/#routine","text":"Name vi_copy_arg1_to_name_file_open","title":"Routine"},{"location":"tools_docs/vi/Files/vi__copy__arg1__to__name__file__open_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__copy__arg1__to__name__file__open_8s/#routine-vi_copy_arg1_to_name_file_open","text":"vi_copy_arg1_to_name_file_open","title":"Routine vi_copy_arg1_to_name_file_open"},{"location":"tools_docs/vi/Files/vi__copy__arg1__to__name__file__open_8s/#source-code","text":".proc vi_copy_arg1_to_name_file_open ldy # $00 sty vi_tmp1 ldy # vi_struct_data: : name_file_open sty vi_tmp2 @loop_copy_filename: ldy vi_tmp1 lda ( vi_arg1 ), y beq @exit_copy_filename iny sty vi_tmp1 ldy vi_tmp2 sta ( vi_struct ), y iny sty vi_tmp2 cpy # VI_MAX_LENGTH_FILENAME + vi_struct_data: : name_file_open bne @loop_copy_filename lda # $00 ; EOS if overflow @exit_copy_filename: ldy vi_tmp2 sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__decal__text_8s/","text":"vi_decal_text.s Routine Name vi_decal_text Routine documentation Routine vi_decal_text vi_decal_text Source code .proc vi_decal_text ; A & X address dest to copy sta DECCIB stx DECCIB + 1 lda vi_ptr_file_used ; address first char ldy vi_ptr_file_used + 1 sta DECDEB sty DECDEB + 1 ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta DECFIN iny lda ( vi_struct ), y sta DECFIN + 1 BRK_TELEMON XDECAL rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_decal_text.s"},{"location":"tools_docs/vi/Files/vi__decal__text_8s/#vi_decal_texts","text":"","title":"vi_decal_text.s"},{"location":"tools_docs/vi/Files/vi__decal__text_8s/#routine","text":"Name vi_decal_text","title":"Routine"},{"location":"tools_docs/vi/Files/vi__decal__text_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__decal__text_8s/#routine-vi_decal_text","text":"vi_decal_text","title":"Routine vi_decal_text"},{"location":"tools_docs/vi/Files/vi__decal__text_8s/#source-code","text":".proc vi_decal_text ; A & X address dest to copy sta DECCIB stx DECCIB + 1 lda vi_ptr_file_used ; address first char ldy vi_ptr_file_used + 1 sta DECDEB sty DECDEB + 1 ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta DECFIN iny lda ( vi_struct ), y sta DECFIN + 1 BRK_TELEMON XDECAL rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__display__char_8s/","text":"vi_display_char.s Routine Name vi_display_char Routine documentation Routine vi_display_char vi_display_char Source code .proc vi_display_char sta vi_tmp2 ; Avoid to display a line greater than 80 chars ? lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_strlen_current_line cpx # 80 - 1 bcc @add_char rts @add_char: @not_eol: jsr vi_editor_switch_off_cursor jsr vi_check_eof cmp # IS_EOF ; Is eof ? beq @not_eof jsr vi_shift_file_from_memory_one_char ; Scroll now ; if posx==VI_EDITOR_MAX_COLUMN then skip scroll ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # VI_EDITOR_MAX_COLUMN bne @scroll ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda vi_tmp2 ; get char sta ( vi_ptr_screen ), y ldy # $00 sta ( vi_ptr_file_used ), y ; Insert into file jsr vi_vi_ptr_file_used_plus_plus jsr vi_set_xpos_0 jsr vi_ypos_screen_plus_plus ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @scroll_last_line tax scroll down ,, 26 ; Because the second empty arg is provided @scroll_last_line: ; FIXME rts @scroll: jsr vi_scroll_from_left_to_right_full_line @not_eof: ; Check if we need to scroll jsr vi_check_inserted_char_overflow_the_max_column cmp # $03 beq @scroll_screen cmp # $01 beq @L100 bne @line_not_full @scroll_screen: ; jsr vi_ypos_screen_plus_plus ; cmp #$01 ; We are on the last line ; bne @not_last_line ; ; Code for lastline @not_last_line: ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax inx scroll down , , 26 ; Yes scroll @L100: ; scroll the next line ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y clc adc # $01 pha jsr vi_shift_line_left_to_right_editor pla tay lda TABLE_LOW_TEXT , y sta vi_ptr1 lda TABLE_HIGH_TEXT , y sta vi_ptr1 + 1 ldy # vi_struct_data: : xpos_screen lda # VI_EDITOR_MAX_COLUMN + 1 sec sbc ( vi_struct ), y tay lda ( vi_ptr_file_used ), y ldy # $00 sta ( vi_ptr1 ), y @line_not_full: ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda vi_tmp2 ; get char sta ( vi_ptr_screen ), y sty vi_tmp1 ldy # $00 sta ( vi_ptr_file_used ), y ; Insert into file jsr vi_vi_ptr_file_used_plus_plus jsr vi_ptr_last_char_plus_plus jsr vi_length_file_plus_plus ; ; end_insert char on screen jsr vi_xpos_screen_plus_plus cmp # $01 ; Are we on the end of line ? bne @exit jsr vi_ypos_screen_plus_plus ; x=0 lda # $00 ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y @exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_display_char.s"},{"location":"tools_docs/vi/Files/vi__display__char_8s/#vi_display_chars","text":"","title":"vi_display_char.s"},{"location":"tools_docs/vi/Files/vi__display__char_8s/#routine","text":"Name vi_display_char","title":"Routine"},{"location":"tools_docs/vi/Files/vi__display__char_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__display__char_8s/#routine-vi_display_char","text":"vi_display_char","title":"Routine vi_display_char"},{"location":"tools_docs/vi/Files/vi__display__char_8s/#source-code","text":".proc vi_display_char sta vi_tmp2 ; Avoid to display a line greater than 80 chars ? lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_strlen_current_line cpx # 80 - 1 bcc @add_char rts @add_char: @not_eol: jsr vi_editor_switch_off_cursor jsr vi_check_eof cmp # IS_EOF ; Is eof ? beq @not_eof jsr vi_shift_file_from_memory_one_char ; Scroll now ; if posx==VI_EDITOR_MAX_COLUMN then skip scroll ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # VI_EDITOR_MAX_COLUMN bne @scroll ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda vi_tmp2 ; get char sta ( vi_ptr_screen ), y ldy # $00 sta ( vi_ptr_file_used ), y ; Insert into file jsr vi_vi_ptr_file_used_plus_plus jsr vi_set_xpos_0 jsr vi_ypos_screen_plus_plus ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @scroll_last_line tax scroll down ,, 26 ; Because the second empty arg is provided @scroll_last_line: ; FIXME rts @scroll: jsr vi_scroll_from_left_to_right_full_line @not_eof: ; Check if we need to scroll jsr vi_check_inserted_char_overflow_the_max_column cmp # $03 beq @scroll_screen cmp # $01 beq @L100 bne @line_not_full @scroll_screen: ; jsr vi_ypos_screen_plus_plus ; cmp #$01 ; We are on the last line ; bne @not_last_line ; ; Code for lastline @not_last_line: ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax inx scroll down , , 26 ; Yes scroll @L100: ; scroll the next line ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y clc adc # $01 pha jsr vi_shift_line_left_to_right_editor pla tay lda TABLE_LOW_TEXT , y sta vi_ptr1 lda TABLE_HIGH_TEXT , y sta vi_ptr1 + 1 ldy # vi_struct_data: : xpos_screen lda # VI_EDITOR_MAX_COLUMN + 1 sec sbc ( vi_struct ), y tay lda ( vi_ptr_file_used ), y ldy # $00 sta ( vi_ptr1 ), y @line_not_full: ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda vi_tmp2 ; get char sta ( vi_ptr_screen ), y sty vi_tmp1 ldy # $00 sta ( vi_ptr_file_used ), y ; Insert into file jsr vi_vi_ptr_file_used_plus_plus jsr vi_ptr_last_char_plus_plus jsr vi_length_file_plus_plus ; ; end_insert char on screen jsr vi_xpos_screen_plus_plus cmp # $01 ; Are we on the end of line ? bne @exit jsr vi_ypos_screen_plus_plus ; x=0 lda # $00 ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y @exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__display__file__opened_8s/","text":"vi_display_file_opened.s Routine Name vi_display_file_opened Routine documentation Routine vi_display_file_opened vi_display_file_opened Source code .proc vi_display_file_opened @loop: ; Do we reached eof ? ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof rts @not_eof: ldy # $00 lda ( vi_ptr1 ), y ldx # VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE jsr vi_put_char ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @compute_empty_line inc vi_ptr1 bne @S30 inc vi_ptr1 + 1 @S30: jmp @loop @do_not_add_high_to_ptr: lda vi_length_file_compute bne @dec_low dec vi_length_file_compute + 1 @dec_low: dec vi_length_file_compute bne @loop lda vi_length_file_compute + 1 bne @loop @compute_empty_line: ; display last line lda vi_ptr1 ldy vi_ptr1 + 1 jsr vi_fill_last_line rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_display_file_opened.s"},{"location":"tools_docs/vi/Files/vi__display__file__opened_8s/#vi_display_file_openeds","text":"","title":"vi_display_file_opened.s"},{"location":"tools_docs/vi/Files/vi__display__file__opened_8s/#routine","text":"Name vi_display_file_opened","title":"Routine"},{"location":"tools_docs/vi/Files/vi__display__file__opened_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__display__file__opened_8s/#routine-vi_display_file_opened","text":"vi_display_file_opened","title":"Routine vi_display_file_opened"},{"location":"tools_docs/vi/Files/vi__display__file__opened_8s/#source-code","text":".proc vi_display_file_opened @loop: ; Do we reached eof ? ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof rts @not_eof: ldy # $00 lda ( vi_ptr1 ), y ldx # VI_FILL_SCREEN_MODE_STOP_AT_THE_END_OF_LAST_LINE jsr vi_put_char ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @compute_empty_line inc vi_ptr1 bne @S30 inc vi_ptr1 + 1 @S30: jmp @loop @do_not_add_high_to_ptr: lda vi_length_file_compute bne @dec_low dec vi_length_file_compute + 1 @dec_low: dec vi_length_file_compute bne @loop lda vi_length_file_compute + 1 bne @loop @compute_empty_line: ; display last line lda vi_ptr1 ldy vi_ptr1 + 1 jsr vi_fill_last_line rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/","text":"/Routines/vi_displays_info.s Routine Name vi_displays_info displays_debug Routine documentation Routine vi_displays_info vi_displays_info Routine displays_debug displays_debug Source code .proc vi_displays_info lda vi_fileopened beq @is_new_file ; Displays filename at the bottom lda # $22 ; \" char sta VI_COMMANDLINE_VIDEO_ADRESS ldy # $00 ldx # $01 @L1: lda ( vi_arg1 ), y beq @end_display_filename sta VI_COMMANDLINE_VIDEO_ADRESS , x inx iny bne @L1 @end_display_filename: lda # $22 ; \" char sta VI_COMMANDLINE_VIDEO_ADRESS , x rts @is_new_file: ldy # $00 @L10: lda msg_nofile , y beq @end_display_msg_nofile sta VI_COMMANDLINE_VIDEO_ADRESS , y iny bne @L10 @end_display_msg_nofile: sty vi_pos_debug jsr displays_debug rts .endproc .proc displays_debug lda # $02 sta VI_COMMANDLINE_VIDEO_ADRESS , y ; y iny ; Display ptr_last_char_file offset sty RES ldy # vi_struct_data: : ptr_last_char_file + 1 ; last char file lda ( vi_struct ), y BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny sty RES ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda # $02 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny sty RES ; pos_file_addr lda vi_ptr_file_used + 1 BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny sty RES ; pos_file_addr lda vi_ptr_file_used BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y ; Display length lda # $06 sta VI_COMMANDLINE_VIDEO_ADRESS + 22 lda # < ( $bb80 + 40 * 27 + 23 ) sta TR5 lda # > ( $bb80 + 40 * 27 + 23 ) sta TR5 + 1 lda # $20 sta DEFAFF ldx # $01 ldy vi_length_file + 1 lda vi_length_file BRK_TELEMON XBINDX lda # $05 sta VI_COMMANDLINE_VIDEO_ADRESS + 28 ; Display char under the cursor ldy # $00 lda ( vi_ptr_file_used ), y cmp # $0D bne @notcrlf lda # '$' @notcrlf: sta $bb80 + 40 * 27 + 29 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_displays_info.s"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/#routinesvi_displays_infos","text":"","title":"/Routines/vi_displays_info.s"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/#routine","text":"Name vi_displays_info displays_debug","title":"Routine"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/#routine-vi_displays_info","text":"vi_displays_info","title":"Routine vi_displays_info"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/#routine-displays_debug","text":"displays_debug","title":"Routine displays_debug"},{"location":"tools_docs/vi/Files/vi__displays__info_8s/#source-code","text":".proc vi_displays_info lda vi_fileopened beq @is_new_file ; Displays filename at the bottom lda # $22 ; \" char sta VI_COMMANDLINE_VIDEO_ADRESS ldy # $00 ldx # $01 @L1: lda ( vi_arg1 ), y beq @end_display_filename sta VI_COMMANDLINE_VIDEO_ADRESS , x inx iny bne @L1 @end_display_filename: lda # $22 ; \" char sta VI_COMMANDLINE_VIDEO_ADRESS , x rts @is_new_file: ldy # $00 @L10: lda msg_nofile , y beq @end_display_msg_nofile sta VI_COMMANDLINE_VIDEO_ADRESS , y iny bne @L10 @end_display_msg_nofile: sty vi_pos_debug jsr displays_debug rts .endproc .proc displays_debug lda # $02 sta VI_COMMANDLINE_VIDEO_ADRESS , y ; y iny ; Display ptr_last_char_file offset sty RES ldy # vi_struct_data: : ptr_last_char_file + 1 ; last char file lda ( vi_struct ), y BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny sty RES ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda # $02 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny sty RES ; pos_file_addr lda vi_ptr_file_used + 1 BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y iny sty RES ; pos_file_addr lda vi_ptr_file_used BRK_TELEMON XHEXA ; A and Y sty vi_tmp1 ldy RES sta VI_COMMANDLINE_VIDEO_ADRESS , y iny lda vi_tmp1 sta VI_COMMANDLINE_VIDEO_ADRESS , y ; Display length lda # $06 sta VI_COMMANDLINE_VIDEO_ADRESS + 22 lda # < ( $bb80 + 40 * 27 + 23 ) sta TR5 lda # > ( $bb80 + 40 * 27 + 23 ) sta TR5 + 1 lda # $20 sta DEFAFF ldx # $01 ldy vi_length_file + 1 lda vi_length_file BRK_TELEMON XBINDX lda # $05 sta VI_COMMANDLINE_VIDEO_ADRESS + 28 ; Display char under the cursor ldy # $00 lda ( vi_ptr_file_used ), y cmp # $0D bne @notcrlf lda # '$' @notcrlf: sta $bb80 + 40 * 27 + 29 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__edition__keyboard_8s/","text":"/Routines/vi_edition_keyboard.s Routine Name vi_edition_keyboard Routine documentation Routine vi_edition_keyboard vi_edition_keyboard Source code .proc vi_edition_keyboard jsr vi_clear_command_line jsr vi_displays_info @loop: cgetc ; read keyboard cmp # 'i' beq switch_to_edition_mode cmp # ':' bne @loop jsr vi_command_edition cmp # $00 ; A is equal to 0 ? Yes restart keyboard beq @loop jsr _clrscr_vi lda # $01 ; Exit vi rts switch_to_edition_mode: jsr vi_clear_command_line ldx # $00 @loop: lda msg_insert , x beq @out sta VI_COMMANDLINE_VIDEO_ADRESS , x inx .IFPC02 .pc02 bra @loop .p02 .else jmp @loop .endif @out: txa tay sty vi_pos_debug jsr displays_debug jsr vi_switch_to_edition_mode rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_edition_keyboard.s"},{"location":"tools_docs/vi/Files/vi__edition__keyboard_8s/#routinesvi_edition_keyboards","text":"","title":"/Routines/vi_edition_keyboard.s"},{"location":"tools_docs/vi/Files/vi__edition__keyboard_8s/#routine","text":"Name vi_edition_keyboard","title":"Routine"},{"location":"tools_docs/vi/Files/vi__edition__keyboard_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__edition__keyboard_8s/#routine-vi_edition_keyboard","text":"vi_edition_keyboard","title":"Routine vi_edition_keyboard"},{"location":"tools_docs/vi/Files/vi__edition__keyboard_8s/#source-code","text":".proc vi_edition_keyboard jsr vi_clear_command_line jsr vi_displays_info @loop: cgetc ; read keyboard cmp # 'i' beq switch_to_edition_mode cmp # ':' bne @loop jsr vi_command_edition cmp # $00 ; A is equal to 0 ? Yes restart keyboard beq @loop jsr _clrscr_vi lda # $01 ; Exit vi rts switch_to_edition_mode: jsr vi_clear_command_line ldx # $00 @loop: lda msg_insert , x beq @out sta VI_COMMANDLINE_VIDEO_ADRESS , x inx .IFPC02 .pc02 bra @loop .p02 .else jmp @loop .endif @out: txa tay sty vi_pos_debug jsr displays_debug jsr vi_switch_to_edition_mode rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__editor__switch__off__cursor_8s/","text":"/Routines/vi_editor_switch_off_cursor.s Routine Name vi_editor_switch_off_cursor Routine documentation Routine vi_editor_switch_off_cursor vi_editor_switch_off_cursor Source code .proc vi_editor_switch_off_cursor ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda ( vi_ptr_screen ), y ; display cursor and # %01111111 sta ( vi_ptr_screen ), y ; display cursor rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_editor_switch_off_cursor.s"},{"location":"tools_docs/vi/Files/vi__editor__switch__off__cursor_8s/#routinesvi_editor_switch_off_cursors","text":"","title":"/Routines/vi_editor_switch_off_cursor.s"},{"location":"tools_docs/vi/Files/vi__editor__switch__off__cursor_8s/#routine","text":"Name vi_editor_switch_off_cursor","title":"Routine"},{"location":"tools_docs/vi/Files/vi__editor__switch__off__cursor_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__editor__switch__off__cursor_8s/#routine-vi_editor_switch_off_cursor","text":"vi_editor_switch_off_cursor","title":"Routine vi_editor_switch_off_cursor"},{"location":"tools_docs/vi/Files/vi__editor__switch__off__cursor_8s/#source-code","text":".proc vi_editor_switch_off_cursor ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda ( vi_ptr_screen ), y ; display cursor and # %01111111 sta ( vi_ptr_screen ), y ; display cursor rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__editor__switch__on__cursor_8s/","text":"/Routines/vi_editor_switch_on_cursor.s Routine Name vi_editor_switch_on_cursor Routine documentation Routine vi_editor_switch_on_cursor vi_editor_switch_on_cursor Source code .proc vi_editor_switch_on_cursor ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda ( vi_ptr_screen ), y ora # $80 sta ( vi_ptr_screen ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_editor_switch_on_cursor.s"},{"location":"tools_docs/vi/Files/vi__editor__switch__on__cursor_8s/#routinesvi_editor_switch_on_cursors","text":"","title":"/Routines/vi_editor_switch_on_cursor.s"},{"location":"tools_docs/vi/Files/vi__editor__switch__on__cursor_8s/#routine","text":"Name vi_editor_switch_on_cursor","title":"Routine"},{"location":"tools_docs/vi/Files/vi__editor__switch__on__cursor_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__editor__switch__on__cursor_8s/#routine-vi_editor_switch_on_cursor","text":"vi_editor_switch_on_cursor","title":"Routine vi_editor_switch_on_cursor"},{"location":"tools_docs/vi/Files/vi__editor__switch__on__cursor_8s/#source-code","text":".proc vi_editor_switch_on_cursor ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda ( vi_ptr_screen ), y ora # $80 sta ( vi_ptr_screen ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__fill__last__line_8s/","text":"vi_fill_last_line.s Routine Name vi_fill_last_line Routine documentation Routine vi_fill_last_line vi_fill_last_line Source code .proc vi_fill_last_line ; A and Y contains the ptr on the file to display on the last line sta vi_ptr1 sty vi_ptr1 + 1 ldx # $00 @compute_empty_line_loop: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof ; reached the end of the file rts @not_eof: inc vi_ptr1 bne @S40 inc vi_ptr1 + 1 @S40: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit cmp # LF beq @compute_empty_line_loop sta VI_EDITION_LAST_VIDEO_ADRESS , x inx cpx # VI_EDITOR_MAX_COLUMN + 1 beq @exit jmp @compute_empty_line_loop @exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_fill_last_line.s"},{"location":"tools_docs/vi/Files/vi__fill__last__line_8s/#vi_fill_last_lines","text":"","title":"vi_fill_last_line.s"},{"location":"tools_docs/vi/Files/vi__fill__last__line_8s/#routine","text":"Name vi_fill_last_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__fill__last__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__fill__last__line_8s/#routine-vi_fill_last_line","text":"vi_fill_last_line","title":"Routine vi_fill_last_line"},{"location":"tools_docs/vi/Files/vi__fill__last__line_8s/#source-code","text":".proc vi_fill_last_line ; A and Y contains the ptr on the file to display on the last line sta vi_ptr1 sty vi_ptr1 + 1 ldx # $00 @compute_empty_line_loop: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof ; reached the end of the file rts @not_eof: inc vi_ptr1 bne @S40 inc vi_ptr1 + 1 @S40: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit cmp # LF beq @compute_empty_line_loop sta VI_EDITION_LAST_VIDEO_ADRESS , x inx cpx # VI_EDITOR_MAX_COLUMN + 1 beq @exit jmp @compute_empty_line_loop @exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__fill__screen__with__empty__line_8s/","text":"/Routines/vi_fill_screen_with_empty_line.s Routine Name vi_fill_screen_with_empty_line Routine documentation Routine vi_fill_screen_with_empty_line vi_fill_screen_with_empty_line Source code .proc vi_fill_screen_with_empty_line ; X the first line cpy # $00 beq @out stx vi_tmp1 ldx # VI_LAST_LINE_EDITOR ldy # $00 @loop: lda TABLE_LOW_TEXT , x sta vi_ptr1 lda TABLE_HIGH_TEXT , x sta vi_ptr1 + 1 @skip: lda # VI_EDITOR_CHAR_LIMITS_EMPTY sta ( vi_ptr1 ), y dex cpx vi_tmp1 bpl @loop @out: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_fill_screen_with_empty_line.s"},{"location":"tools_docs/vi/Files/vi__fill__screen__with__empty__line_8s/#routinesvi_fill_screen_with_empty_lines","text":"","title":"/Routines/vi_fill_screen_with_empty_line.s"},{"location":"tools_docs/vi/Files/vi__fill__screen__with__empty__line_8s/#routine","text":"Name vi_fill_screen_with_empty_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__fill__screen__with__empty__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__fill__screen__with__empty__line_8s/#routine-vi_fill_screen_with_empty_line","text":"vi_fill_screen_with_empty_line","title":"Routine vi_fill_screen_with_empty_line"},{"location":"tools_docs/vi/Files/vi__fill__screen__with__empty__line_8s/#source-code","text":".proc vi_fill_screen_with_empty_line ; X the first line cpy # $00 beq @out stx vi_tmp1 ldx # VI_LAST_LINE_EDITOR ldy # $00 @loop: lda TABLE_LOW_TEXT , x sta vi_ptr1 lda TABLE_HIGH_TEXT , x sta vi_ptr1 + 1 @skip: lda # VI_EDITOR_CHAR_LIMITS_EMPTY sta ( vi_ptr1 ), y dex cpx vi_tmp1 bpl @loop @out: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__init__vi__struct_8s/","text":"vi_init_vi_struct.s Routine Name vi_init_vi_struct Routine documentation Routine vi_init_vi_struct vi_init_vi_struct Source code .proc vi_init_vi_struct ; init struct to 0 jsr vi_set_xpos_0 ldy # vi_struct_data: : ypos_screen sta ( vi_struct ), y ldy # vi_struct_data: : xpos_text sta ( vi_struct ), y ldy # vi_struct_data: : ypos_text sta ( vi_struct ), y ldy # vi_struct_data: : xpos_command_line sta ( vi_struct ), y ldy # vi_struct_data: : pos_file_addr sta ( vi_struct ), y iny sta ( vi_struct ), y ldy # vi_struct_data: : pos_file sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y ldy # vi_struct_data: : posx_command_line sta ( vi_struct ), y ldy # vi_struct_data: : name_file_open sta ( vi_struct ), y ldy # vi_struct_data: : length_file sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y ldy # vi_struct_data: : ptr_last_char_file lda # $00 sta ( vi_struct ), y iny sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_init_vi_struct.s"},{"location":"tools_docs/vi/Files/vi__init__vi__struct_8s/#vi_init_vi_structs","text":"","title":"vi_init_vi_struct.s"},{"location":"tools_docs/vi/Files/vi__init__vi__struct_8s/#routine","text":"Name vi_init_vi_struct","title":"Routine"},{"location":"tools_docs/vi/Files/vi__init__vi__struct_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__init__vi__struct_8s/#routine-vi_init_vi_struct","text":"vi_init_vi_struct","title":"Routine vi_init_vi_struct"},{"location":"tools_docs/vi/Files/vi__init__vi__struct_8s/#source-code","text":".proc vi_init_vi_struct ; init struct to 0 jsr vi_set_xpos_0 ldy # vi_struct_data: : ypos_screen sta ( vi_struct ), y ldy # vi_struct_data: : xpos_text sta ( vi_struct ), y ldy # vi_struct_data: : ypos_text sta ( vi_struct ), y ldy # vi_struct_data: : xpos_command_line sta ( vi_struct ), y ldy # vi_struct_data: : pos_file_addr sta ( vi_struct ), y iny sta ( vi_struct ), y ldy # vi_struct_data: : pos_file sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y ldy # vi_struct_data: : posx_command_line sta ( vi_struct ), y ldy # vi_struct_data: : name_file_open sta ( vi_struct ), y ldy # vi_struct_data: : length_file sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y iny sta ( vi_struct ), y ldy # vi_struct_data: : ptr_last_char_file lda # $00 sta ( vi_struct ), y iny sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__key__del_8s/","text":"vi_key_del.s Routine Name vi_manage_del vi_remove_char_in_text_file vi_decal_text_left_to_right Routine documentation Routine vi_manage_del vi_manage_del Routine vi_remove_char_in_text_file vi_remove_char_in_text_file Routine vi_decal_text_left_to_right vi_decal_text_left_to_right Source code .proc vi_manage_del ; Check if we are at the beginning of the file jsr vi_check_beginning_of_file cmp # IS_BEGINNING_OF_THE_FILE bne @delete_char rts @delete_char: jsr vi_editor_switch_off_cursor ; if xpos==0 then goto @first_colomn else goto @not_first_column ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # $00 ; First column ? bne @not_first_column ; First column @first_colomn: ; Does a $0D under the cursor (X=0 and current_char==0x0D ?) yes, scroll and remove the char ; if file[posfile]=='\\n' then goto ldy # $01 lda ( vi_ptr_file_used ), y cmp # LF bne @remove_char_from_the_first_column ; remove 0A jsr vi_remove_char_in_text_file ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR bne @do_not_move_twice ; for $0A jsr vi_remove_char_in_text_file ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR bne @check_0A jsr vi_ptr_file_used_plus_plus @check_0A: ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @not_0A jsr vi_ptr_file_used_plus_plus @not_0A: @do_not_move_twice: ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax ;inx scroll up ,, 26 ; Because the second arg is provided ;jsr vi_ypos_screen_sub_sub ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax inx lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_compute_last_text_line jsr vi_fill_last_line rts @not_first_column: tay jsr vi_scroll_to_left jsr vi_xpos_screen_sub_sub @dec_ptr_and_move_file: jsr vi_remove_char_in_text_file @out: rts @remove_char_from_the_first_column: ; For 0A ; Editor management part ; search the last char of the previous line to concat lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_search_previous_cr ; Search the previous \\n ; Don't put anything here, a and Y are kept for next vi_search_previous_cr jsr vi_search_previous_cr ; Search the first previous line \\n stx vi_tmp3 ; Save the number of char found jsr vi_remove_char_in_text_file ; For 0D jsr vi_remove_char_in_text_file jsr vi_ypos_screen_sub_sub jsr vi_compute_video_adress lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 @L1: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit ldy vi_tmp3 sta ( vi_ptr_screen ), y inc vi_ptr_screen bne @out_compare inc vi_ptr_screen + 1 @out_compare: inc vi_ptr1 ; 98 bne @out_compare2 inc vi_ptr1 + 1 @out_compare2: jmp @L1 @exit: lda vi_tmp3 jsr vi_set_xpos_from_A ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax inx scroll up ,, 26 ; Because the second empty arg is provided rts ; And of previous empty line management @not_an_empty_line: jsr vi_ypos_screen_sub_sub ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax scroll up ,, 26 ; Because the second empty arg is provided rts .endproc .proc vi_remove_char_in_text_file ; Remove a char in the text file in the current position jsr vi_ptr_file_used_sub_sub jsr vi_ptr_last_char_sub_sub jsr vi_decal_text_left_to_right jsr vi_length_file_sub_sub rts .endproc .proc vi_decal_text_left_to_right lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 @restart: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof ldy # $01 lda ( vi_ptr1 ), y dey sta ( vi_ptr1 ), y inc vi_ptr1 bne @out2 inc vi_ptr1 + 1 @out2: rts @not_eof: ldy # $01 lda ( vi_ptr1 ), y dey sta ( vi_ptr1 ), y inc vi_ptr1 bne @out inc vi_ptr1 + 1 @out: jmp @restart rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_key_del.s"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#vi_key_dels","text":"","title":"vi_key_del.s"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#routine","text":"Name vi_manage_del vi_remove_char_in_text_file vi_decal_text_left_to_right","title":"Routine"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#routine-vi_manage_del","text":"vi_manage_del","title":"Routine vi_manage_del"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#routine-vi_remove_char_in_text_file","text":"vi_remove_char_in_text_file","title":"Routine vi_remove_char_in_text_file"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#routine-vi_decal_text_left_to_right","text":"vi_decal_text_left_to_right","title":"Routine vi_decal_text_left_to_right"},{"location":"tools_docs/vi/Files/vi__key__del_8s/#source-code","text":".proc vi_manage_del ; Check if we are at the beginning of the file jsr vi_check_beginning_of_file cmp # IS_BEGINNING_OF_THE_FILE bne @delete_char rts @delete_char: jsr vi_editor_switch_off_cursor ; if xpos==0 then goto @first_colomn else goto @not_first_column ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # $00 ; First column ? bne @not_first_column ; First column @first_colomn: ; Does a $0D under the cursor (X=0 and current_char==0x0D ?) yes, scroll and remove the char ; if file[posfile]=='\\n' then goto ldy # $01 lda ( vi_ptr_file_used ), y cmp # LF bne @remove_char_from_the_first_column ; remove 0A jsr vi_remove_char_in_text_file ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR bne @do_not_move_twice ; for $0A jsr vi_remove_char_in_text_file ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR bne @check_0A jsr vi_ptr_file_used_plus_plus @check_0A: ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @not_0A jsr vi_ptr_file_used_plus_plus @not_0A: @do_not_move_twice: ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax ;inx scroll up ,, 26 ; Because the second arg is provided ;jsr vi_ypos_screen_sub_sub ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax inx lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_compute_last_text_line jsr vi_fill_last_line rts @not_first_column: tay jsr vi_scroll_to_left jsr vi_xpos_screen_sub_sub @dec_ptr_and_move_file: jsr vi_remove_char_in_text_file @out: rts @remove_char_from_the_first_column: ; For 0A ; Editor management part ; search the last char of the previous line to concat lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_search_previous_cr ; Search the previous \\n ; Don't put anything here, a and Y are kept for next vi_search_previous_cr jsr vi_search_previous_cr ; Search the first previous line \\n stx vi_tmp3 ; Save the number of char found jsr vi_remove_char_in_text_file ; For 0D jsr vi_remove_char_in_text_file jsr vi_ypos_screen_sub_sub jsr vi_compute_video_adress lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 @L1: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit ldy vi_tmp3 sta ( vi_ptr_screen ), y inc vi_ptr_screen bne @out_compare inc vi_ptr_screen + 1 @out_compare: inc vi_ptr1 ; 98 bne @out_compare2 inc vi_ptr1 + 1 @out_compare2: jmp @L1 @exit: lda vi_tmp3 jsr vi_set_xpos_from_A ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax inx scroll up ,, 26 ; Because the second empty arg is provided rts ; And of previous empty line management @not_an_empty_line: jsr vi_ypos_screen_sub_sub ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y tax scroll up ,, 26 ; Because the second empty arg is provided rts .endproc .proc vi_remove_char_in_text_file ; Remove a char in the text file in the current position jsr vi_ptr_file_used_sub_sub jsr vi_ptr_last_char_sub_sub jsr vi_decal_text_left_to_right jsr vi_length_file_sub_sub rts .endproc .proc vi_decal_text_left_to_right lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 @restart: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof ldy # $01 lda ( vi_ptr1 ), y dey sta ( vi_ptr1 ), y inc vi_ptr1 bne @out2 inc vi_ptr1 + 1 @out2: rts @not_eof: ldy # $01 lda ( vi_ptr1 ), y dey sta ( vi_ptr1 ), y inc vi_ptr1 bne @out inc vi_ptr1 + 1 @out: jmp @restart rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__key__down_8s/","text":"vi_key_down.s Routine Name vi_key_down Key down management. Routine documentation Routine vi_key_down vi_key_down Key down management. [vi_strlen_current_line] Source code ;; Key down management ; ;@link ;vi_strlen_current_line ;@endlink ;; .proc vi_key_down jsr vi_editor_switch_off_cursor ; Checking if we can go below ; if eof then goto eof jsr vi_check_eof cmp # IS_EOF beq @eof ; x=0 jsr vi_set_xpos_0 ; y++ jsr vi_ypos_screen_plus_plus ; Last line ? cmp # IS_LAST_LINE_OF_SCREEN_TEXT bne @continue_down scroll up , 0 , 26 ; Yes scroll @search_eof: ldx # $00 @L100: ; ptr_file++ jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @display_line jsr vi_vi_ptr_file_used_plus_plus inx cpx # VI_EDITOR_MAX_COLUMN beq @display_line jmp @L100 @eof: rts @display_line: @start_display_line: iny jsr vi_check_0A lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_fill_last_line ; And displays the line jsr vi_check_0A jsr vi_check_eof cmp # IS_EOF beq @eof jsr vi_check_if_previous_line_was_truncated rts @exit_display_line: @exit_near: rts @continue_down: ldx # $00 @L1: jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @found_0D @not_eof2: inx cpx # VI_EDITOR_MAX_COLUMN + 1 bne @not_eol jsr vi_set_xpos_0 ; y++ jsr vi_ypos_screen_plus_plus ldx # $00 @not_eol: jsr vi_vi_ptr_file_used_plus_plus jmp @L1 ; Checking if eof @found_0D: jsr vi_vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @S20 jsr vi_vi_ptr_file_used_plus_plus @S20: jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @not_eof jsr vi_vi_ptr_file_used_plus_plus jmp @S20 @not_eof: ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # $00 beq @no_compute tax @add: jsr vi_vi_ptr_file_used_plus_plus dex bne @add @no_compute: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_key_down.s"},{"location":"tools_docs/vi/Files/vi__key__down_8s/#vi_key_downs","text":"","title":"vi_key_down.s"},{"location":"tools_docs/vi/Files/vi__key__down_8s/#routine","text":"Name vi_key_down Key down management.","title":"Routine"},{"location":"tools_docs/vi/Files/vi__key__down_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__key__down_8s/#routine-vi_key_down","text":"vi_key_down Key down management. [vi_strlen_current_line]","title":"Routine vi_key_down"},{"location":"tools_docs/vi/Files/vi__key__down_8s/#source-code","text":";; Key down management ; ;@link ;vi_strlen_current_line ;@endlink ;; .proc vi_key_down jsr vi_editor_switch_off_cursor ; Checking if we can go below ; if eof then goto eof jsr vi_check_eof cmp # IS_EOF beq @eof ; x=0 jsr vi_set_xpos_0 ; y++ jsr vi_ypos_screen_plus_plus ; Last line ? cmp # IS_LAST_LINE_OF_SCREEN_TEXT bne @continue_down scroll up , 0 , 26 ; Yes scroll @search_eof: ldx # $00 @L100: ; ptr_file++ jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @display_line jsr vi_vi_ptr_file_used_plus_plus inx cpx # VI_EDITOR_MAX_COLUMN beq @display_line jmp @L100 @eof: rts @display_line: @start_display_line: iny jsr vi_check_0A lda vi_ptr_file_used ldy vi_ptr_file_used + 1 jsr vi_fill_last_line ; And displays the line jsr vi_check_0A jsr vi_check_eof cmp # IS_EOF beq @eof jsr vi_check_if_previous_line_was_truncated rts @exit_display_line: @exit_near: rts @continue_down: ldx # $00 @L1: jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @found_0D @not_eof2: inx cpx # VI_EDITOR_MAX_COLUMN + 1 bne @not_eol jsr vi_set_xpos_0 ; y++ jsr vi_ypos_screen_plus_plus ldx # $00 @not_eol: jsr vi_vi_ptr_file_used_plus_plus jmp @L1 ; Checking if eof @found_0D: jsr vi_vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @S20 jsr vi_vi_ptr_file_used_plus_plus @S20: jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @not_eof jsr vi_vi_ptr_file_used_plus_plus jmp @S20 @not_eof: ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # $00 beq @no_compute tax @add: jsr vi_vi_ptr_file_used_plus_plus dex bne @add @no_compute: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__key__enter_8s/","text":"vi_key_enter.s Routine Name vi_key_enter Routine documentation Routine vi_key_enter vi_key_enter Source code .proc vi_key_enter jsr vi_editor_switch_off_cursor lda # CR jsr vi_add_char_to_text lda # LF jsr vi_add_char_to_text ; Are we on the last ; if xpos==0 then goto @check_others_cases ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y bne @check_others_cases ; if ypos==VI_LAST_LINE_EDITOR then goto @scroll_last_line ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @scroll_last_line tax scroll down ,, 26 ; Because the second empty arg is provided jsr vi_ypos_screen_plus_plus rts @scroll_last_line: scroll up , 0 , 25 ; Because the second empty arg is provided rts @check_others_cases: ; if ypos < VI_LAST_LINE_EDITOR then goto @scroll_for_insert ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR bne @scroll_for_insert ; else scrollup(0,26); scroll up , 0 , 26 jmp @continue @scroll_for_insert: sta vi_tmp1 ; if posx=0 then goto @we_are_at_pos_0 (scroll) ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y bne @we_are_at_pos_0 ; first_line_to_scroll++; inc vi_tmp1 ; if (ypos>26) then goto @last_line_case_scroll jsr vi_ypos_screen_plus_plus cmp # $00 bne @last_line_case_scroll jsr vi_set_xpos_0 rts @we_are_at_pos_0: ; scrolldown(first_line_to_scroll,26) ldx vi_tmp1 inx scroll down ,, 26 ; Because the second empty arg is provided ; Now copy the current line jsr vi_ypos_screen_plus_plus jsr vi_compute_video_adress lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 @L1: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit sta ( vi_ptr_screen ), y sty vi_tmp2 inc vi_ptr_screen ; 98 bne @out_compare inc vi_ptr_screen + 1 @out_compare: inc vi_ptr1 ; 98 bne @out_compare2 inc vi_ptr1 + 1 @out_compare2: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof beq @eof @not_eof: jmp @L1 @eof: @exit: ; Now we erase the char on the previous line jsr vi_ypos_screen_sub_sub jsr vi_compute_video_adress ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda # $00 @L2: sta ( vi_ptr_screen ), y iny cpy # VI_EDITOR_MAX_COLUMN bne @L2 jsr vi_ypos_screen_plus_plus jsr vi_set_xpos_0 rts @continue: jsr vi_set_xpos_0 jsr vi_ypos_screen_plus_plus rts @last_line_case_scroll: ;FIXME rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_key_enter.s"},{"location":"tools_docs/vi/Files/vi__key__enter_8s/#vi_key_enters","text":"","title":"vi_key_enter.s"},{"location":"tools_docs/vi/Files/vi__key__enter_8s/#routine","text":"Name vi_key_enter","title":"Routine"},{"location":"tools_docs/vi/Files/vi__key__enter_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__key__enter_8s/#routine-vi_key_enter","text":"vi_key_enter","title":"Routine vi_key_enter"},{"location":"tools_docs/vi/Files/vi__key__enter_8s/#source-code","text":".proc vi_key_enter jsr vi_editor_switch_off_cursor lda # CR jsr vi_add_char_to_text lda # LF jsr vi_add_char_to_text ; Are we on the last ; if xpos==0 then goto @check_others_cases ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y bne @check_others_cases ; if ypos==VI_LAST_LINE_EDITOR then goto @scroll_last_line ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @scroll_last_line tax scroll down ,, 26 ; Because the second empty arg is provided jsr vi_ypos_screen_plus_plus rts @scroll_last_line: scroll up , 0 , 25 ; Because the second empty arg is provided rts @check_others_cases: ; if ypos < VI_LAST_LINE_EDITOR then goto @scroll_for_insert ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR bne @scroll_for_insert ; else scrollup(0,26); scroll up , 0 , 26 jmp @continue @scroll_for_insert: sta vi_tmp1 ; if posx=0 then goto @we_are_at_pos_0 (scroll) ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y bne @we_are_at_pos_0 ; first_line_to_scroll++; inc vi_tmp1 ; if (ypos>26) then goto @last_line_case_scroll jsr vi_ypos_screen_plus_plus cmp # $00 bne @last_line_case_scroll jsr vi_set_xpos_0 rts @we_are_at_pos_0: ; scrolldown(first_line_to_scroll,26) ldx vi_tmp1 inx scroll down ,, 26 ; Because the second empty arg is provided ; Now copy the current line jsr vi_ypos_screen_plus_plus jsr vi_compute_video_adress lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 @L1: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit sta ( vi_ptr_screen ), y sty vi_tmp2 inc vi_ptr_screen ; 98 bne @out_compare inc vi_ptr_screen + 1 @out_compare: inc vi_ptr1 ; 98 bne @out_compare2 inc vi_ptr1 + 1 @out_compare2: ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 cmp vi_tmp1 bne @not_eof ldy # vi_struct_data: : ptr_last_char_file + 1 lda ( vi_struct ), y sta vi_tmp1 lda vi_ptr1 + 1 cmp vi_tmp1 bne @not_eof beq @eof @not_eof: jmp @L1 @eof: @exit: ; Now we erase the char on the previous line jsr vi_ypos_screen_sub_sub jsr vi_compute_video_adress ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay lda # $00 @L2: sta ( vi_ptr_screen ), y iny cpy # VI_EDITOR_MAX_COLUMN bne @L2 jsr vi_ypos_screen_plus_plus jsr vi_set_xpos_0 rts @continue: jsr vi_set_xpos_0 jsr vi_ypos_screen_plus_plus rts @last_line_case_scroll: ;FIXME rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__key__left_8s/","text":"vi_key_left.s Routine Name vi_key_left Routine documentation Routine vi_key_left vi_key_left Source code .proc vi_key_left jsr vi_editor_switch_off_cursor jsr vi_xpos_screen_sub_sub cmp # IS_BEGINNING_OF_THE_LINE beq @exit_and_check ; x_equal_to_zero jsr vi_ptr_file_used_sub_sub @exit: rts @exit_and_check: ; At this step we are on the column 0 (xpos=0) jsr vi_check_beginning_of_file cmp # $00 beq @exit ; Check if the previous char is a crlf ; if posfile[vi_ptr_file_used]=$0A goto @exit_add jsr vi_ptr_file_used_sub_sub ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF beq @exit_add ; LF exit ; if posfile[vi_ptr_file_used]=$0D goto @exit_add ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @exit_add ; CR ?exit jsr vi_ypos_screen_sub_sub ldy # vi_struct_data: : xpos_screen lda # VI_EDITOR_MAX_COLUMN sta ( vi_struct ), y rts @exit_add: jsr vi_ptr_file_used_plus_plus rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_key_left.s"},{"location":"tools_docs/vi/Files/vi__key__left_8s/#vi_key_lefts","text":"","title":"vi_key_left.s"},{"location":"tools_docs/vi/Files/vi__key__left_8s/#routine","text":"Name vi_key_left","title":"Routine"},{"location":"tools_docs/vi/Files/vi__key__left_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__key__left_8s/#routine-vi_key_left","text":"vi_key_left","title":"Routine vi_key_left"},{"location":"tools_docs/vi/Files/vi__key__left_8s/#source-code","text":".proc vi_key_left jsr vi_editor_switch_off_cursor jsr vi_xpos_screen_sub_sub cmp # IS_BEGINNING_OF_THE_LINE beq @exit_and_check ; x_equal_to_zero jsr vi_ptr_file_used_sub_sub @exit: rts @exit_and_check: ; At this step we are on the column 0 (xpos=0) jsr vi_check_beginning_of_file cmp # $00 beq @exit ; Check if the previous char is a crlf ; if posfile[vi_ptr_file_used]=$0A goto @exit_add jsr vi_ptr_file_used_sub_sub ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF beq @exit_add ; LF exit ; if posfile[vi_ptr_file_used]=$0D goto @exit_add ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @exit_add ; CR ?exit jsr vi_ypos_screen_sub_sub ldy # vi_struct_data: : xpos_screen lda # VI_EDITOR_MAX_COLUMN sta ( vi_struct ), y rts @exit_add: jsr vi_ptr_file_used_plus_plus rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__key__right_8s/","text":"vi_key_right.s Routine Name vi_key_right Routine documentation Routine vi_key_right vi_key_right Source code .proc vi_key_right ; are we on the end of the text file ? ; Compute if we need to erase ~ jsr vi_check_eof cmp # IS_EOF bne @not_eof rts @not_eof: jsr vi_editor_switch_off_cursor ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @no_add_x cmp # LF beq @no_add_x jsr vi_ptr_file_used_plus_plus jsr vi_xpos_screen_plus_plus cmp # $01 bne @no_add_x jsr vi_set_xpos_0 jsr vi_ypos_screen_plus_plus cmp # $01 bne @no_add_x scroll up , 0 , 26 ; Yes scroll lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 lda vi_ptr1 ldy vi_ptr1 + 1 jsr vi_fill_last_line @no_add_x: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_key_right.s"},{"location":"tools_docs/vi/Files/vi__key__right_8s/#vi_key_rights","text":"","title":"vi_key_right.s"},{"location":"tools_docs/vi/Files/vi__key__right_8s/#routine","text":"Name vi_key_right","title":"Routine"},{"location":"tools_docs/vi/Files/vi__key__right_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__key__right_8s/#routine-vi_key_right","text":"vi_key_right","title":"Routine vi_key_right"},{"location":"tools_docs/vi/Files/vi__key__right_8s/#source-code","text":".proc vi_key_right ; are we on the end of the text file ? ; Compute if we need to erase ~ jsr vi_check_eof cmp # IS_EOF bne @not_eof rts @not_eof: jsr vi_editor_switch_off_cursor ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @no_add_x cmp # LF beq @no_add_x jsr vi_ptr_file_used_plus_plus jsr vi_xpos_screen_plus_plus cmp # $01 bne @no_add_x jsr vi_set_xpos_0 jsr vi_ypos_screen_plus_plus cmp # $01 bne @no_add_x scroll up , 0 , 26 ; Yes scroll lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 lda vi_ptr1 ldy vi_ptr1 + 1 jsr vi_fill_last_line @no_add_x: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__key__up_8s/","text":"vi_key_up.s Routine Name vi_key_up Routine documentation Routine vi_key_up vi_key_up Source code .proc vi_key_up ; Debut du fichier ? On sort jsr vi_check_beginning_of_file cmp # IS_BEGINNING_OF_THE_FILE beq @stop_shorter ; On eteint le curseur jsr vi_editor_switch_off_cursor ; On force \u00e0 revenir \u00e0 la position X=0 de la ligne pr\u00e9c\u00e9cente : FIXME jsr vi_set_xpos_0 @continue_up: ; Checking if previous char is not $0A or $0D if it's not the case, it's on a truncated line ; On va voir si la pr\u00e9dente ligne c'est une fin de ligne ou pas lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 lda vi_ptr1 ; 98 ; On d\u00e9cr\u00e9mente la copie de ptr_file_used pour lire le caract\u00e8re pr\u00e9c\u00e9dent bne @out_compare dec vi_ptr1 + 1 @out_compare: dec vi_ptr1 ldy # $00 lda ( vi_ptr1 ), y cmp # LF beq @search_previous_line ;ldy #$00 lda ( vi_ptr1 ), y cmp # CR beq @search_previous_line lda vi_ptr1 ; 98 bne @out_compare2 dec vi_ptr1 + 1 @out_compare2: dec vi_ptr1 ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @search_previous_line ; Check if the jsr vi_ypos_screen_sub_sub jsr vi_search_previous_line_beginning ; Looking for previous line ($0D detection) jsr vi_ptr_file_used_sub_sub ; Skip $0D cpx # VI_EDITOR_MAX_COLUMN + 1 bcc @skip_y_plusplus jsr vi_ypos_screen_sub_sub @skip_y_plusplus: jsr vi_search_previous_line_beginning ; Looking for previous line ($0D detection) jsr vi_ptr_file_used_plus_plus ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @S10 jsr vi_ptr_file_used_plus_plus @S10: @stop_shorter: rts @search_previous_line: jsr vi_search_previous_line_beginning ; Looking for previous line ($0D detection) cmp # $00 beq @exit jsr vi_search_previous_line_beginning cmp # $00 beq @exit cpx # VI_EDITOR_MAX_COLUMN bcc @no_line_greater_than_39_chars jsr vi_ptr_file_used_plus_plus ldx # $00 @looking_for_truncated_line: ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @finished cmp # LF beq @skip_inx inx @skip_inx: jsr vi_ptr_file_used_plus_plus cpx # VI_EDITOR_MAX_COLUMN + 1 bne @looking_for_truncated_line ldx # $00 beq @looking_for_truncated_line @finished: jsr vi_ypos_screen_sub_sub txa jsr vi_set_xpos_from_A rts @no_line_greater_than_39_chars: jsr vi_ptr_file_used_plus_plus ldy # $00 jsr vi_check_0A @exit: ; Check if posx=0 and not the beginning of the file ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y bne @stop scroll down , 0 , 26 ldx # $01 stx vi_savex ldx vi_savex cpx # $00 beq @stop ldy # $00 @L1: lda ( vi_ptr_file_used ), y cmp # CR beq @stop sta VI_EDITION_VIDEO_ADRESS , y iny cpy # VI_EDITOR_MAX_COLUMN beq @stop bne @L1 @stop: jsr vi_ypos_screen_sub_sub rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_key_up.s"},{"location":"tools_docs/vi/Files/vi__key__up_8s/#vi_key_ups","text":"","title":"vi_key_up.s"},{"location":"tools_docs/vi/Files/vi__key__up_8s/#routine","text":"Name vi_key_up","title":"Routine"},{"location":"tools_docs/vi/Files/vi__key__up_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__key__up_8s/#routine-vi_key_up","text":"vi_key_up","title":"Routine vi_key_up"},{"location":"tools_docs/vi/Files/vi__key__up_8s/#source-code","text":".proc vi_key_up ; Debut du fichier ? On sort jsr vi_check_beginning_of_file cmp # IS_BEGINNING_OF_THE_FILE beq @stop_shorter ; On eteint le curseur jsr vi_editor_switch_off_cursor ; On force \u00e0 revenir \u00e0 la position X=0 de la ligne pr\u00e9c\u00e9cente : FIXME jsr vi_set_xpos_0 @continue_up: ; Checking if previous char is not $0A or $0D if it's not the case, it's on a truncated line ; On va voir si la pr\u00e9dente ligne c'est une fin de ligne ou pas lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 lda vi_ptr1 ; 98 ; On d\u00e9cr\u00e9mente la copie de ptr_file_used pour lire le caract\u00e8re pr\u00e9c\u00e9dent bne @out_compare dec vi_ptr1 + 1 @out_compare: dec vi_ptr1 ldy # $00 lda ( vi_ptr1 ), y cmp # LF beq @search_previous_line ;ldy #$00 lda ( vi_ptr1 ), y cmp # CR beq @search_previous_line lda vi_ptr1 ; 98 bne @out_compare2 dec vi_ptr1 + 1 @out_compare2: dec vi_ptr1 ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @search_previous_line ; Check if the jsr vi_ypos_screen_sub_sub jsr vi_search_previous_line_beginning ; Looking for previous line ($0D detection) jsr vi_ptr_file_used_sub_sub ; Skip $0D cpx # VI_EDITOR_MAX_COLUMN + 1 bcc @skip_y_plusplus jsr vi_ypos_screen_sub_sub @skip_y_plusplus: jsr vi_search_previous_line_beginning ; Looking for previous line ($0D detection) jsr vi_ptr_file_used_plus_plus ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @S10 jsr vi_ptr_file_used_plus_plus @S10: @stop_shorter: rts @search_previous_line: jsr vi_search_previous_line_beginning ; Looking for previous line ($0D detection) cmp # $00 beq @exit jsr vi_search_previous_line_beginning cmp # $00 beq @exit cpx # VI_EDITOR_MAX_COLUMN bcc @no_line_greater_than_39_chars jsr vi_ptr_file_used_plus_plus ldx # $00 @looking_for_truncated_line: ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @finished cmp # LF beq @skip_inx inx @skip_inx: jsr vi_ptr_file_used_plus_plus cpx # VI_EDITOR_MAX_COLUMN + 1 bne @looking_for_truncated_line ldx # $00 beq @looking_for_truncated_line @finished: jsr vi_ypos_screen_sub_sub txa jsr vi_set_xpos_from_A rts @no_line_greater_than_39_chars: jsr vi_ptr_file_used_plus_plus ldy # $00 jsr vi_check_0A @exit: ; Check if posx=0 and not the beginning of the file ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y bne @stop scroll down , 0 , 26 ldx # $01 stx vi_savex ldx vi_savex cpx # $00 beq @stop ldy # $00 @L1: lda ( vi_ptr_file_used ), y cmp # CR beq @stop sta VI_EDITION_VIDEO_ADRESS , y iny cpy # VI_EDITOR_MAX_COLUMN beq @stop bne @L1 @stop: jsr vi_ypos_screen_sub_sub rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__length__file__plus__plus_8s/","text":"vi_length_file_plus_plus.s Routine Name vi_length_file_plus_plus Routine documentation Routine vi_length_file_plus_plus vi_length_file_plus_plus Source code .proc vi_length_file_plus_plus ; add length_file=length_file+1 inc vi_length_file bne @S1 inc vi_length_file + 1 @S1: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_length_file_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__length__file__plus__plus_8s/#vi_length_file_plus_pluss","text":"","title":"vi_length_file_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__length__file__plus__plus_8s/#routine","text":"Name vi_length_file_plus_plus","title":"Routine"},{"location":"tools_docs/vi/Files/vi__length__file__plus__plus_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__length__file__plus__plus_8s/#routine-vi_length_file_plus_plus","text":"vi_length_file_plus_plus","title":"Routine vi_length_file_plus_plus"},{"location":"tools_docs/vi/Files/vi__length__file__plus__plus_8s/#source-code","text":".proc vi_length_file_plus_plus ; add length_file=length_file+1 inc vi_length_file bne @S1 inc vi_length_file + 1 @S1: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__length__file__sub__sub_8s/","text":"vi_length_file_sub_sub.s Routine Name vi_length_file_sub_sub Routine documentation Routine vi_length_file_sub_sub vi_length_file_sub_sub Source code .proc vi_length_file_sub_sub ; add length_file=length_file-- lda vi_length_file bne @out dec vi_length_file + 1 @out: dec vi_length_file rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_length_file_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__length__file__sub__sub_8s/#vi_length_file_sub_subs","text":"","title":"vi_length_file_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__length__file__sub__sub_8s/#routine","text":"Name vi_length_file_sub_sub","title":"Routine"},{"location":"tools_docs/vi/Files/vi__length__file__sub__sub_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__length__file__sub__sub_8s/#routine-vi_length_file_sub_sub","text":"vi_length_file_sub_sub","title":"Routine vi_length_file_sub_sub"},{"location":"tools_docs/vi/Files/vi__length__file__sub__sub_8s/#source-code","text":".proc vi_length_file_sub_sub ; add length_file=length_file-- lda vi_length_file bne @out dec vi_length_file + 1 @out: dec vi_length_file rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus_8s/","text":"vi_ptr_file_used_plus_plus.s Routine Name vi_ptr_file_used_plus_plus Routine documentation Routine vi_ptr_file_used_plus_plus vi_ptr_file_used_plus_plus Source code .proc vi_ptr_file_used_plus_plus inc vi_ptr_file_used bne @out inc vi_ptr_file_used + 1 @out: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ptr_file_used_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus_8s/#vi_ptr_file_used_plus_pluss","text":"","title":"vi_ptr_file_used_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus_8s/#routine","text":"Name vi_ptr_file_used_plus_plus","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus_8s/#routine-vi_ptr_file_used_plus_plus","text":"vi_ptr_file_used_plus_plus","title":"Routine vi_ptr_file_used_plus_plus"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus_8s/#source-code","text":".proc vi_ptr_file_used_plus_plus inc vi_ptr_file_used bne @out inc vi_ptr_file_used + 1 @out: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus__and__check__eof_8s/","text":"vi_ptr_file_used_plus_plus_and_check_eof.s Routine Name vi_ptr_file_used_plus_plus_and_check_eof Routine documentation Routine vi_ptr_file_used_plus_plus_and_check_eof vi_ptr_file_used_plus_plus_and_check_eof Source code .proc vi_ptr_file_used_plus_plus_and_check_eof rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ptr_file_used_plus_plus_and_check_eof.s"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus__and__check__eof_8s/#vi_ptr_file_used_plus_plus_and_check_eofs","text":"","title":"vi_ptr_file_used_plus_plus_and_check_eof.s"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus__and__check__eof_8s/#routine","text":"Name vi_ptr_file_used_plus_plus_and_check_eof","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus__and__check__eof_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus__and__check__eof_8s/#routine-vi_ptr_file_used_plus_plus_and_check_eof","text":"vi_ptr_file_used_plus_plus_and_check_eof","title":"Routine vi_ptr_file_used_plus_plus_and_check_eof"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__plus__plus__and__check__eof_8s/#source-code","text":".proc vi_ptr_file_used_plus_plus_and_check_eof rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__sub__sub_8s/","text":"vi_ptr_file_used_sub_sub.s Routine Name vi_ptr_file_used_sub_sub Routine documentation Routine vi_ptr_file_used_sub_sub vi_ptr_file_used_sub_sub Source code .proc vi_ptr_file_used_sub_sub jsr vi_check_beginning_of_file cmp # IS_BEGINNING_OF_THE_FILE beq @beginning_of_file lda vi_ptr_file_used ; 98 bne @out dec vi_ptr_file_used + 1 @out: dec vi_ptr_file_used lda # $01 rts @beginning_of_file: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ptr_file_used_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__sub__sub_8s/#vi_ptr_file_used_sub_subs","text":"","title":"vi_ptr_file_used_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__sub__sub_8s/#routine","text":"Name vi_ptr_file_used_sub_sub","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__sub__sub_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__sub__sub_8s/#routine-vi_ptr_file_used_sub_sub","text":"vi_ptr_file_used_sub_sub","title":"Routine vi_ptr_file_used_sub_sub"},{"location":"tools_docs/vi/Files/vi__ptr__file__used__sub__sub_8s/#source-code","text":".proc vi_ptr_file_used_sub_sub jsr vi_check_beginning_of_file cmp # IS_BEGINNING_OF_THE_FILE beq @beginning_of_file lda vi_ptr_file_used ; 98 bne @out dec vi_ptr_file_used + 1 @out: dec vi_ptr_file_used lda # $01 rts @beginning_of_file: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__add_8s/","text":"vi_ptr_last_char_add.s Routine Name vi_ptr_last_char_add Routine documentation Routine vi_ptr_last_char_add vi_ptr_last_char_add Source code .proc vi_ptr_last_char_add ; A and X the value to add pha txa ldy # vi_struct_data: : ptr_last_char_file + 1 ; 3737 clc adc ( vi_struct ), y sta ( vi_struct ), y pla ldy # vi_struct_data: : ptr_last_char_file sec sbc # $01 clc adc ( vi_struct ), y bcc @do_not_inc_ptr_last_char pha iny lda ( vi_struct ), y clc adc # $01 sta ( vi_struct ), y dey pla @do_not_inc_ptr_last_char: sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ptr_last_char_add.s"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__add_8s/#vi_ptr_last_char_adds","text":"","title":"vi_ptr_last_char_add.s"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__add_8s/#routine","text":"Name vi_ptr_last_char_add","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__add_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__add_8s/#routine-vi_ptr_last_char_add","text":"vi_ptr_last_char_add","title":"Routine vi_ptr_last_char_add"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__add_8s/#source-code","text":".proc vi_ptr_last_char_add ; A and X the value to add pha txa ldy # vi_struct_data: : ptr_last_char_file + 1 ; 3737 clc adc ( vi_struct ), y sta ( vi_struct ), y pla ldy # vi_struct_data: : ptr_last_char_file sec sbc # $01 clc adc ( vi_struct ), y bcc @do_not_inc_ptr_last_char pha iny lda ( vi_struct ), y clc adc # $01 sta ( vi_struct ), y dey pla @do_not_inc_ptr_last_char: sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__plus__plus_8s/","text":"vi_ptr_last_char_plus_plus.s Routine Name vi_ptr_last_char_plus_plus Routine documentation Routine vi_ptr_last_char_plus_plus vi_ptr_last_char_plus_plus Source code .proc vi_ptr_last_char_plus_plus ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y clc adc # $01 bcc @S1 pha iny lda ( vi_struct ), y clc adc # $01 sta ( vi_struct ), y dey pla @S1: sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ptr_last_char_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__plus__plus_8s/#vi_ptr_last_char_plus_pluss","text":"","title":"vi_ptr_last_char_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__plus__plus_8s/#routine","text":"Name vi_ptr_last_char_plus_plus","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__plus__plus_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__plus__plus_8s/#routine-vi_ptr_last_char_plus_plus","text":"vi_ptr_last_char_plus_plus","title":"Routine vi_ptr_last_char_plus_plus"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__plus__plus_8s/#source-code","text":".proc vi_ptr_last_char_plus_plus ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y clc adc # $01 bcc @S1 pha iny lda ( vi_struct ), y clc adc # $01 sta ( vi_struct ), y dey pla @S1: sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__sub__sub_8s/","text":"vi_ptr_last_char_sub_sub.s Routine Name vi_ptr_last_char_sub_sub Routine documentation Routine vi_ptr_last_char_sub_sub vi_ptr_last_char_sub_sub Source code .proc vi_ptr_last_char_sub_sub ldy # vi_struct_data: : ptr_last_char_file iny lda ( vi_struct ), y bne @dec sec sbc # $01 sta ( vi_struct ), y @dec: dey lda ( vi_struct ), y sec sbc # $01 sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ptr_last_char_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__sub__sub_8s/#vi_ptr_last_char_sub_subs","text":"","title":"vi_ptr_last_char_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__sub__sub_8s/#routine","text":"Name vi_ptr_last_char_sub_sub","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__sub__sub_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__sub__sub_8s/#routine-vi_ptr_last_char_sub_sub","text":"vi_ptr_last_char_sub_sub","title":"Routine vi_ptr_last_char_sub_sub"},{"location":"tools_docs/vi/Files/vi__ptr__last__char__sub__sub_8s/#source-code","text":".proc vi_ptr_last_char_sub_sub ldy # vi_struct_data: : ptr_last_char_file iny lda ( vi_struct ), y bne @dec sec sbc # $01 sta ( vi_struct ), y @dec: dey lda ( vi_struct ), y sec sbc # $01 sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__put__char_8s/","text":"/Routines/vi_put_char.s Routine Name vi_put_char Routine documentation Routine vi_put_char vi_put_char Source code .proc vi_put_char cmp # $0A beq exit cmp # $0D beq @return_line pha jsr vi_compute_video_adress ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # 40 bne @not_eol_onscreen jsr vi_ypos_screen_plus_plus jsr vi_compute_video_adress ldy # vi_struct_data: : xpos_screen lda # $00 sta ( vi_struct ), y @not_eol_onscreen: tay pla sta ( vi_ptr_screen ), y iny bne @do_not_inc_y @do_not_inc_y: tya ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y rts @return_line: lda # $00 ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y ldy # vi_struct_data: : file_number_of_line lda ( vi_struct ), y clc adc # $01 sta ( vi_struct ), y jsr vi_ypos_screen_plus_plus rts exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_put_char.s"},{"location":"tools_docs/vi/Files/vi__put__char_8s/#routinesvi_put_chars","text":"","title":"/Routines/vi_put_char.s"},{"location":"tools_docs/vi/Files/vi__put__char_8s/#routine","text":"Name vi_put_char","title":"Routine"},{"location":"tools_docs/vi/Files/vi__put__char_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__put__char_8s/#routine-vi_put_char","text":"vi_put_char","title":"Routine vi_put_char"},{"location":"tools_docs/vi/Files/vi__put__char_8s/#source-code","text":".proc vi_put_char cmp # $0A beq exit cmp # $0D beq @return_line pha jsr vi_compute_video_adress ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # 40 bne @not_eol_onscreen jsr vi_ypos_screen_plus_plus jsr vi_compute_video_adress ldy # vi_struct_data: : xpos_screen lda # $00 sta ( vi_struct ), y @not_eol_onscreen: tay pla sta ( vi_ptr_screen ), y iny bne @do_not_inc_y @do_not_inc_y: tya ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y rts @return_line: lda # $00 ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y ldy # vi_struct_data: : file_number_of_line lda ( vi_struct ), y clc adc # $01 sta ( vi_struct ), y jsr vi_ypos_screen_plus_plus rts exit: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__scroll__from__left__to__right__full__line_8s/","text":"vi_scroll_from_left_to_right_full_line.s Routine Name vi_scroll_from_left_to_right_full_line Routine documentation Routine vi_scroll_from_left_to_right_full_line vi_scroll_from_left_to_right_full_line Source code .proc vi_scroll_from_left_to_right_full_line ; Scroll une ligne Y ; insert copy on screen ldy # vi_struct_data: : xpos_screen ; Get X position lda ( vi_struct ), y ; get value sec sbc # $01 sta vi_tmp1 ; Save It lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 ; Compute number of char to scroll ldy # $00 ldx # $00 @compute: lda ( vi_ptr1 ), y cmp # CR beq @end_compute inc vi_ptr1 bne @S2 inc vi_ptr1 + 1 @S2: inc vi_ptr1 inx bne @compute @end_compute: txa tay ldy # 38 @L2: lda ( vi_ptr_screen ), y iny sta ( vi_ptr_screen ), y dey dey cpy vi_tmp1 bne @L2 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_scroll_from_left_to_right_full_line.s"},{"location":"tools_docs/vi/Files/vi__scroll__from__left__to__right__full__line_8s/#vi_scroll_from_left_to_right_full_lines","text":"","title":"vi_scroll_from_left_to_right_full_line.s"},{"location":"tools_docs/vi/Files/vi__scroll__from__left__to__right__full__line_8s/#routine","text":"Name vi_scroll_from_left_to_right_full_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__scroll__from__left__to__right__full__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__scroll__from__left__to__right__full__line_8s/#routine-vi_scroll_from_left_to_right_full_line","text":"vi_scroll_from_left_to_right_full_line","title":"Routine vi_scroll_from_left_to_right_full_line"},{"location":"tools_docs/vi/Files/vi__scroll__from__left__to__right__full__line_8s/#source-code","text":".proc vi_scroll_from_left_to_right_full_line ; Scroll une ligne Y ; insert copy on screen ldy # vi_struct_data: : xpos_screen ; Get X position lda ( vi_struct ), y ; get value sec sbc # $01 sta vi_tmp1 ; Save It lda vi_ptr_file_used sta vi_ptr1 lda vi_ptr_file_used + 1 sta vi_ptr1 + 1 ; Compute number of char to scroll ldy # $00 ldx # $00 @compute: lda ( vi_ptr1 ), y cmp # CR beq @end_compute inc vi_ptr1 bne @S2 inc vi_ptr1 + 1 @S2: inc vi_ptr1 inx bne @compute @end_compute: txa tay ldy # 38 @L2: lda ( vi_ptr_screen ), y iny sta ( vi_ptr_screen ), y dey dey cpy vi_tmp1 bne @L2 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__scroll__to__left_8s/","text":"vi_scroll_to_left.s Routine Name vi_scroll_to_left Routine documentation Routine vi_scroll_to_left vi_scroll_to_left Source code .proc vi_scroll_to_left pha ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay @L3: lda ( vi_ptr_screen ), y dey sta ( vi_ptr_screen ), y iny iny cpy # 39 bne @L3 pla rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_scroll_to_left.s"},{"location":"tools_docs/vi/Files/vi__scroll__to__left_8s/#vi_scroll_to_lefts","text":"","title":"vi_scroll_to_left.s"},{"location":"tools_docs/vi/Files/vi__scroll__to__left_8s/#routine","text":"Name vi_scroll_to_left","title":"Routine"},{"location":"tools_docs/vi/Files/vi__scroll__to__left_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__scroll__to__left_8s/#routine-vi_scroll_to_left","text":"vi_scroll_to_left","title":"Routine vi_scroll_to_left"},{"location":"tools_docs/vi/Files/vi__scroll__to__left_8s/#source-code","text":".proc vi_scroll_to_left pha ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y tay @L3: lda ( vi_ptr_screen ), y dey sta ( vi_ptr_screen ), y iny iny cpy # 39 bne @L3 pla rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__search__next__line_8s/","text":"vi_search_next_line.s Routine Name vi_search_next_line Routine documentation Routine vi_search_next_line vi_search_next_line Source code .proc vi_search_next_line ; vi_ptr_file_used is on $0D ; and the exit of the subroutine must be : ; -last char lda # $00 sta vi_tmp2 ; Contains the number of line when max number of_column has reached ; jsr vi_check_eof ; cmp #IS_EOF ; beq @eof ; ; The current line is empty : *$0D*, $0A, 'T',$0D, 0A ; ; The current line is chars : *$0D*, $0A, 'T',$0D, 0A ; ; The current line is the end of the file : *$0D*, $0A ; ; The current line is the end of the file : *'T'* ; jsr vi_ptr_file_used_plus_plus ; ; The current line is empty : $0D, *$0A*, 'T',$0D, 0A ; ; The current line is chars : $0D, *$0A*, 'T',$0D, 0A ; ; The current line is the end of the file : $0D, *$0A* ; ; The current line is the end of the file : 'T' ** err ; jsr vi_check_eof ; cmp #IS_EOF ; beq @eof ; ldy #$00 ; lda (vi_ptr_file_used),y ; cmp #LF ; bne @continue ; jsr vi_ptr_file_used_plus_plus ; jsr vi_check_eof ; cmp #IS_EOF ; beq @eof ldx # $00 @continue: ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @first_char_found jsr vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof inx cpx # VI_EDITOR_MAX_COLUMN bne @continue inc vi_tmp2 ldx # $00 jmp @continue @eof: ; A=IS_EOF rts @first_char_found: jsr vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @exit jsr vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof @exit: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_search_next_line.s"},{"location":"tools_docs/vi/Files/vi__search__next__line_8s/#vi_search_next_lines","text":"","title":"vi_search_next_line.s"},{"location":"tools_docs/vi/Files/vi__search__next__line_8s/#routine","text":"Name vi_search_next_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__search__next__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__search__next__line_8s/#routine-vi_search_next_line","text":"vi_search_next_line","title":"Routine vi_search_next_line"},{"location":"tools_docs/vi/Files/vi__search__next__line_8s/#source-code","text":".proc vi_search_next_line ; vi_ptr_file_used is on $0D ; and the exit of the subroutine must be : ; -last char lda # $00 sta vi_tmp2 ; Contains the number of line when max number of_column has reached ; jsr vi_check_eof ; cmp #IS_EOF ; beq @eof ; ; The current line is empty : *$0D*, $0A, 'T',$0D, 0A ; ; The current line is chars : *$0D*, $0A, 'T',$0D, 0A ; ; The current line is the end of the file : *$0D*, $0A ; ; The current line is the end of the file : *'T'* ; jsr vi_ptr_file_used_plus_plus ; ; The current line is empty : $0D, *$0A*, 'T',$0D, 0A ; ; The current line is chars : $0D, *$0A*, 'T',$0D, 0A ; ; The current line is the end of the file : $0D, *$0A* ; ; The current line is the end of the file : 'T' ** err ; jsr vi_check_eof ; cmp #IS_EOF ; beq @eof ; ldy #$00 ; lda (vi_ptr_file_used),y ; cmp #LF ; bne @continue ; jsr vi_ptr_file_used_plus_plus ; jsr vi_check_eof ; cmp #IS_EOF ; beq @eof ldx # $00 @continue: ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @first_char_found jsr vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof inx cpx # VI_EDITOR_MAX_COLUMN bne @continue inc vi_tmp2 ldx # $00 jmp @continue @eof: ; A=IS_EOF rts @first_char_found: jsr vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof ldy # $00 lda ( vi_ptr_file_used ), y cmp # LF bne @exit jsr vi_ptr_file_used_plus_plus jsr vi_check_eof cmp # IS_EOF beq @eof @exit: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__search__previous__cr_8s/","text":"vi_search_previous_cr.s Routine Name vi_search_previous_cr Routine documentation Routine vi_search_previous_cr vi_search_previous_cr Source code .proc vi_search_previous_cr ; Cherche le pr\u00e9c\u00e9dent \\n ; retourne dans A et Y la position en ptr ; Si on est en d\u00e9but de fichier A et Y = $0000 ; retourne dans X le nombre de char trouv\u00e9s entre le $0D et le 1er char de la ligne pr\u00e9c\u00e9dnte ligne sta vi_ptr1 sty vi_ptr1 + 1 ldx # $00 @L1: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit cmp # LF beq @no_inc inx @no_inc: lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 lda vi_ptr1 cmp vi_ptr_file bne @not_beginning lda vi_ptr1 + 1 cmp vi_ptr_file + 1 bne @not_beginning @exit_beginning_of_the_file_is_reached: inx lda # $00 ldy # $00 rts @not_beginning: jmp @L1 @exit: lda vi_ptr1 bne @S2 dec vi_ptr1 + 1 @S2: dec vi_ptr1 lda vi_ptr1 cmp vi_ptr_file bne @not_beginning2 lda vi_ptr1 + 1 cmp vi_ptr_file + 1 bne @not_beginning2 beq @exit_beginning_of_the_file_is_reached @not_beginning2: lda vi_ptr1 ldy vi_ptr1 + 1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_search_previous_cr.s"},{"location":"tools_docs/vi/Files/vi__search__previous__cr_8s/#vi_search_previous_crs","text":"","title":"vi_search_previous_cr.s"},{"location":"tools_docs/vi/Files/vi__search__previous__cr_8s/#routine","text":"Name vi_search_previous_cr","title":"Routine"},{"location":"tools_docs/vi/Files/vi__search__previous__cr_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__search__previous__cr_8s/#routine-vi_search_previous_cr","text":"vi_search_previous_cr","title":"Routine vi_search_previous_cr"},{"location":"tools_docs/vi/Files/vi__search__previous__cr_8s/#source-code","text":".proc vi_search_previous_cr ; Cherche le pr\u00e9c\u00e9dent \\n ; retourne dans A et Y la position en ptr ; Si on est en d\u00e9but de fichier A et Y = $0000 ; retourne dans X le nombre de char trouv\u00e9s entre le $0D et le 1er char de la ligne pr\u00e9c\u00e9dnte ligne sta vi_ptr1 sty vi_ptr1 + 1 ldx # $00 @L1: ldy # $00 lda ( vi_ptr1 ), y cmp # CR beq @exit cmp # LF beq @no_inc inx @no_inc: lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 lda vi_ptr1 cmp vi_ptr_file bne @not_beginning lda vi_ptr1 + 1 cmp vi_ptr_file + 1 bne @not_beginning @exit_beginning_of_the_file_is_reached: inx lda # $00 ldy # $00 rts @not_beginning: jmp @L1 @exit: lda vi_ptr1 bne @S2 dec vi_ptr1 + 1 @S2: dec vi_ptr1 lda vi_ptr1 cmp vi_ptr_file bne @not_beginning2 lda vi_ptr1 + 1 cmp vi_ptr_file + 1 bne @not_beginning2 beq @exit_beginning_of_the_file_is_reached @not_beginning2: lda vi_ptr1 ldy vi_ptr1 + 1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__search__previous__line__beginning_8s/","text":"vi_search_previous_line_beginning.s Routine Name vi_search_previous_line_beginning Routine documentation Routine vi_search_previous_line_beginning vi_search_previous_line_beginning Source code .proc vi_search_previous_line_beginning ; A = 1 found $0D ; A = 0 find beginning ; X contains the number of char parsed ldx # $00 @L1: jsr vi_ptr_file_used_sub_sub cmp # IS_BEGINNING_OF_THE_FILE beq @beginning_of_file ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @found_0D cmp # LF beq @dex inx bne @L1 @dex: jmp @L1 @found_0D: lda # $01 rts @beginning_of_file: lda # $00 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_search_previous_line_beginning.s"},{"location":"tools_docs/vi/Files/vi__search__previous__line__beginning_8s/#vi_search_previous_line_beginnings","text":"","title":"vi_search_previous_line_beginning.s"},{"location":"tools_docs/vi/Files/vi__search__previous__line__beginning_8s/#routine","text":"Name vi_search_previous_line_beginning","title":"Routine"},{"location":"tools_docs/vi/Files/vi__search__previous__line__beginning_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__search__previous__line__beginning_8s/#routine-vi_search_previous_line_beginning","text":"vi_search_previous_line_beginning","title":"Routine vi_search_previous_line_beginning"},{"location":"tools_docs/vi/Files/vi__search__previous__line__beginning_8s/#source-code","text":".proc vi_search_previous_line_beginning ; A = 1 found $0D ; A = 0 find beginning ; X contains the number of char parsed ldx # $00 @L1: jsr vi_ptr_file_used_sub_sub cmp # IS_BEGINNING_OF_THE_FILE beq @beginning_of_file ldy # $00 lda ( vi_ptr_file_used ), y cmp # CR beq @found_0D cmp # LF beq @dex inx bne @L1 @dex: jmp @L1 @found_0D: lda # $01 rts @beginning_of_file: lda # $00 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__set__length__file_8s/","text":"/Routines/vi_set_length_file.s Routine Name vi_set_length_file Routine documentation Routine vi_set_length_file vi_set_length_file Source code ; A,X,Y RES contains the length .proc vi_set_length_file ; set file length A and X contains the value pha jsr populate_tmp0_16_with_ptr_length_file pla ldy # $00 sta ( tmp0_16 ), y txa iny sta ( tmp0_16 ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_set_length_file.s"},{"location":"tools_docs/vi/Files/vi__set__length__file_8s/#routinesvi_set_length_files","text":"","title":"/Routines/vi_set_length_file.s"},{"location":"tools_docs/vi/Files/vi__set__length__file_8s/#routine","text":"Name vi_set_length_file","title":"Routine"},{"location":"tools_docs/vi/Files/vi__set__length__file_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__set__length__file_8s/#routine-vi_set_length_file","text":"vi_set_length_file","title":"Routine vi_set_length_file"},{"location":"tools_docs/vi/Files/vi__set__length__file_8s/#source-code","text":"; A,X,Y RES contains the length .proc vi_set_length_file ; set file length A and X contains the value pha jsr populate_tmp0_16_with_ptr_length_file pla ldy # $00 sta ( tmp0_16 ), y txa iny sta ( tmp0_16 ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__set__ptr__last__char_8s/","text":"vi_set_ptr_last_char.s Routine Name vi_set_ptr_last_char Routine documentation Routine vi_set_ptr_last_char vi_set_ptr_last_char Source code .proc vi_set_ptr_last_char ; A and X contains the last char ptr ldy # vi_struct_data: : ptr_last_char_file sta ( vi_struct ), y txa iny sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_set_ptr_last_char.s"},{"location":"tools_docs/vi/Files/vi__set__ptr__last__char_8s/#vi_set_ptr_last_chars","text":"","title":"vi_set_ptr_last_char.s"},{"location":"tools_docs/vi/Files/vi__set__ptr__last__char_8s/#routine","text":"Name vi_set_ptr_last_char","title":"Routine"},{"location":"tools_docs/vi/Files/vi__set__ptr__last__char_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__set__ptr__last__char_8s/#routine-vi_set_ptr_last_char","text":"vi_set_ptr_last_char","title":"Routine vi_set_ptr_last_char"},{"location":"tools_docs/vi/Files/vi__set__ptr__last__char_8s/#source-code","text":".proc vi_set_ptr_last_char ; A and X contains the last char ptr ldy # vi_struct_data: : ptr_last_char_file sta ( vi_struct ), y txa iny sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__set__xpos__0_8s/","text":"vi_set_xpos_0.s Routine Name vi_set_xpos_0 Routine documentation Routine vi_set_xpos_0 vi_set_xpos_0 Source code .proc vi_set_xpos_0 ldy # vi_struct_data: : xpos_screen lda # $00 sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_set_xpos_0.s"},{"location":"tools_docs/vi/Files/vi__set__xpos__0_8s/#vi_set_xpos_0s","text":"","title":"vi_set_xpos_0.s"},{"location":"tools_docs/vi/Files/vi__set__xpos__0_8s/#routine","text":"Name vi_set_xpos_0","title":"Routine"},{"location":"tools_docs/vi/Files/vi__set__xpos__0_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__set__xpos__0_8s/#routine-vi_set_xpos_0","text":"vi_set_xpos_0","title":"Routine vi_set_xpos_0"},{"location":"tools_docs/vi/Files/vi__set__xpos__0_8s/#source-code","text":".proc vi_set_xpos_0 ldy # vi_struct_data: : xpos_screen lda # $00 sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__set__xpos__from__A_8s/","text":"vi_set_xpos_from_A.s Routine Name vi_set_xpos_from_A Routine documentation Routine vi_set_xpos_from_A vi_set_xpos_from_A Source code .proc vi_set_xpos_from_A ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_set_xpos_from_A.s"},{"location":"tools_docs/vi/Files/vi__set__xpos__from__A_8s/#vi_set_xpos_from_as","text":"","title":"vi_set_xpos_from_A.s"},{"location":"tools_docs/vi/Files/vi__set__xpos__from__A_8s/#routine","text":"Name vi_set_xpos_from_A","title":"Routine"},{"location":"tools_docs/vi/Files/vi__set__xpos__from__A_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__set__xpos__from__A_8s/#routine-vi_set_xpos_from_a","text":"vi_set_xpos_from_A","title":"Routine vi_set_xpos_from_A"},{"location":"tools_docs/vi/Files/vi__set__xpos__from__A_8s/#source-code","text":".proc vi_set_xpos_from_A ldy # vi_struct_data: : xpos_screen sta ( vi_struct ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__shift__file__from__memory__one__char_8s/","text":"vi_shift_file_from_memory_one_char.s Routine Name vi_shift_file_from_memory_one_char Routine documentation Routine vi_shift_file_from_memory_one_char vi_shift_file_from_memory_one_char Source code .proc vi_shift_file_from_memory_one_char ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_ptr1 ; A4 A0 39 iny lda ( vi_struct ), y sta vi_ptr1 + 1 ; 3A 3A 08 @copy_char_routine: ldy # $00 lda ( vi_ptr1 ), y iny sta ( vi_ptr1 ), y lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 @L1: lda vi_ptr1 cmp vi_ptr_file_used bne @copy_char_routine lda vi_ptr1 + 1 cmp vi_ptr_file_used + 1 bne @copy_char_routine ldy # $00 lda ( vi_ptr1 ), y iny sta ( vi_ptr1 ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_shift_file_from_memory_one_char.s"},{"location":"tools_docs/vi/Files/vi__shift__file__from__memory__one__char_8s/#vi_shift_file_from_memory_one_chars","text":"","title":"vi_shift_file_from_memory_one_char.s"},{"location":"tools_docs/vi/Files/vi__shift__file__from__memory__one__char_8s/#routine","text":"Name vi_shift_file_from_memory_one_char","title":"Routine"},{"location":"tools_docs/vi/Files/vi__shift__file__from__memory__one__char_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__shift__file__from__memory__one__char_8s/#routine-vi_shift_file_from_memory_one_char","text":"vi_shift_file_from_memory_one_char","title":"Routine vi_shift_file_from_memory_one_char"},{"location":"tools_docs/vi/Files/vi__shift__file__from__memory__one__char_8s/#source-code","text":".proc vi_shift_file_from_memory_one_char ldy # vi_struct_data: : ptr_last_char_file lda ( vi_struct ), y sta vi_ptr1 ; A4 A0 39 iny lda ( vi_struct ), y sta vi_ptr1 + 1 ; 3A 3A 08 @copy_char_routine: ldy # $00 lda ( vi_ptr1 ), y iny sta ( vi_ptr1 ), y lda vi_ptr1 bne @S1 dec vi_ptr1 + 1 @S1: dec vi_ptr1 @L1: lda vi_ptr1 cmp vi_ptr_file_used bne @copy_char_routine lda vi_ptr1 + 1 cmp vi_ptr_file_used + 1 bne @copy_char_routine ldy # $00 lda ( vi_ptr1 ), y iny sta ( vi_ptr1 ), y rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__shift__line__left__to__right__editor_8s/","text":"vi_shift_line_left_to_right_editor.s Routine Name vi_shift_line_left_to_right_editor Routine documentation Routine vi_shift_line_left_to_right_editor vi_shift_line_left_to_right_editor Source code .proc vi_shift_line_left_to_right_editor ; A the line to scroll tay lda TABLE_LOW_TEXT , y sta vi_ptr1 lda TABLE_HIGH_TEXT , y sta vi_ptr1 + 1 ldy # 38 @L1: lda ( vi_ptr1 ), y iny sta ( vi_ptr1 ), y dey dey bpl @L1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_shift_line_left_to_right_editor.s"},{"location":"tools_docs/vi/Files/vi__shift__line__left__to__right__editor_8s/#vi_shift_line_left_to_right_editors","text":"","title":"vi_shift_line_left_to_right_editor.s"},{"location":"tools_docs/vi/Files/vi__shift__line__left__to__right__editor_8s/#routine","text":"Name vi_shift_line_left_to_right_editor","title":"Routine"},{"location":"tools_docs/vi/Files/vi__shift__line__left__to__right__editor_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__shift__line__left__to__right__editor_8s/#routine-vi_shift_line_left_to_right_editor","text":"vi_shift_line_left_to_right_editor","title":"Routine vi_shift_line_left_to_right_editor"},{"location":"tools_docs/vi/Files/vi__shift__line__left__to__right__editor_8s/#source-code","text":".proc vi_shift_line_left_to_right_editor ; A the line to scroll tay lda TABLE_LOW_TEXT , y sta vi_ptr1 lda TABLE_HIGH_TEXT , y sta vi_ptr1 + 1 ldy # 38 @L1: lda ( vi_ptr1 ), y iny sta ( vi_ptr1 ), y dey dey bpl @L1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__strlen__current__line_8s/","text":"vi_strlen_current_line.s Routine Name vi_strlen_current_line Routine documentation Routine vi_strlen_current_line vi_strlen_current_line Source code ;; strlen of a line ; ;@param A&Y : ptr of the position ;@return X : the length of the line ;@return A & Y : the ptr reached ;@see vi_struct ; ;@example This routine compute ... ;@page strlen ;; .proc vi_strlen_current_line ; Returns in A and Y the ptr of the beginning of the line ; Returns in X the length of the line sta vi_ptr2 sty vi_ptr2 + 1 ; Looking for the beginning of the line ldy # $00 lda ( vi_ptr2 ), y cmp # CR bne @search_beginning_of_the_line lda vi_ptr2 ; 98 bne @out_compare2 dec vi_ptr2 + 1 @out_compare2: dec vi_ptr2 @search_beginning_of_the_line: ; Check beginning lda vi_ptr2 cmp vi_ptr_file bne @not_beginning lda vi_ptr2 + 1 cmp vi_ptr_file + 1 bne @not_beginning lda vi_ptr2 ldy vi_ptr2 + 1 ldx # $00 rts @not_beginning: ldy # $00 lda ( vi_ptr2 ), y cmp # LF beq @found_beginning cmp # CR beq @found_beginning lda vi_ptr2 ; 98 bne @out_compare dec vi_ptr2 + 1 @out_compare: dec vi_ptr2 jmp @search_beginning_of_the_line @found_beginning: inc vi_ptr2 bne @no_inc inc vi_ptr2 + 1 @no_inc: ; At this step we are at the beginning of the line ; search now the end of the line ldx # $00 ldy # $00 @search_eol: lda ( vi_ptr2 ), y cmp # CR beq @found_eol iny bne @search_eol @found_eol: tya tax lda vi_ptr2 ldy vi_ptr2 + 1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_strlen_current_line.s"},{"location":"tools_docs/vi/Files/vi__strlen__current__line_8s/#vi_strlen_current_lines","text":"","title":"vi_strlen_current_line.s"},{"location":"tools_docs/vi/Files/vi__strlen__current__line_8s/#routine","text":"Name vi_strlen_current_line","title":"Routine"},{"location":"tools_docs/vi/Files/vi__strlen__current__line_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__strlen__current__line_8s/#routine-vi_strlen_current_line","text":"vi_strlen_current_line","title":"Routine vi_strlen_current_line"},{"location":"tools_docs/vi/Files/vi__strlen__current__line_8s/#source-code","text":";; strlen of a line ; ;@param A&Y : ptr of the position ;@return X : the length of the line ;@return A & Y : the ptr reached ;@see vi_struct ; ;@example This routine compute ... ;@page strlen ;; .proc vi_strlen_current_line ; Returns in A and Y the ptr of the beginning of the line ; Returns in X the length of the line sta vi_ptr2 sty vi_ptr2 + 1 ; Looking for the beginning of the line ldy # $00 lda ( vi_ptr2 ), y cmp # CR bne @search_beginning_of_the_line lda vi_ptr2 ; 98 bne @out_compare2 dec vi_ptr2 + 1 @out_compare2: dec vi_ptr2 @search_beginning_of_the_line: ; Check beginning lda vi_ptr2 cmp vi_ptr_file bne @not_beginning lda vi_ptr2 + 1 cmp vi_ptr_file + 1 bne @not_beginning lda vi_ptr2 ldy vi_ptr2 + 1 ldx # $00 rts @not_beginning: ldy # $00 lda ( vi_ptr2 ), y cmp # LF beq @found_beginning cmp # CR beq @found_beginning lda vi_ptr2 ; 98 bne @out_compare dec vi_ptr2 + 1 @out_compare: dec vi_ptr2 jmp @search_beginning_of_the_line @found_beginning: inc vi_ptr2 bne @no_inc inc vi_ptr2 + 1 @no_inc: ; At this step we are at the beginning of the line ; search now the end of the line ldx # $00 ldy # $00 @search_eol: lda ( vi_ptr2 ), y cmp # CR beq @found_eol iny bne @search_eol @found_eol: tya tax lda vi_ptr2 ldy vi_ptr2 + 1 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__struct_8s/","text":"/Routines/vi_struct.s Classes Name struct vi_struct_data Defines Name VI_MAX_LENGTH_FILENAME Macros Documentation define VI_MAX_LENGTH_FILENAME # define VI_MAX_LENGTH_FILENAME 16 Source code .define VI_MAX_LENGTH_FILENAME 16 .struct vi_struct_data xpos_screen .byte ; position x of the cursor on the screen ypos_screen .byte ; position y of the cursor on the screen pos_file_addr .word ; position on the file (address) pos_file .res 4 ; position in the file posx_command_line .byte ; position on command line name_file_open .res VI_MAX_LENGTH_FILENAME ;ptr_file_begin .word ; adress of the beginning of the file length_file .res 4 ; Length of the file pos_ptr_video_address .word file_number_of_line .res 4 xpos_command_line .byte command_line_buffer .res 39 ptr_last_char_file .word line_id .word xpos_text .byte ypos_text .byte .endstruct .if .sizeof ( vi_struct_data ) > 255 .error \"vi_struct_data size is greater than 255. It's impossible because code does not handle a struct greater than 255\" .endif Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_struct.s"},{"location":"tools_docs/vi/Files/vi__struct_8s/#routinesvi_structs","text":"","title":"/Routines/vi_struct.s"},{"location":"tools_docs/vi/Files/vi__struct_8s/#classes","text":"Name struct vi_struct_data","title":"Classes"},{"location":"tools_docs/vi/Files/vi__struct_8s/#defines","text":"Name VI_MAX_LENGTH_FILENAME","title":"Defines"},{"location":"tools_docs/vi/Files/vi__struct_8s/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"tools_docs/vi/Files/vi__struct_8s/#define-vi_max_length_filename","text":"# define VI_MAX_LENGTH_FILENAME 16","title":"define VI_MAX_LENGTH_FILENAME"},{"location":"tools_docs/vi/Files/vi__struct_8s/#source-code","text":".define VI_MAX_LENGTH_FILENAME 16 .struct vi_struct_data xpos_screen .byte ; position x of the cursor on the screen ypos_screen .byte ; position y of the cursor on the screen pos_file_addr .word ; position on the file (address) pos_file .res 4 ; position in the file posx_command_line .byte ; position on command line name_file_open .res VI_MAX_LENGTH_FILENAME ;ptr_file_begin .word ; adress of the beginning of the file length_file .res 4 ; Length of the file pos_ptr_video_address .word file_number_of_line .res 4 xpos_command_line .byte command_line_buffer .res 39 ptr_last_char_file .word line_id .word xpos_text .byte ypos_text .byte .endstruct .if .sizeof ( vi_struct_data ) > 255 .error \"vi_struct_data size is greater than 255. It's impossible because code does not handle a struct greater than 255\" .endif Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__switch__to__edition__mode_8s/","text":"/Routines/vi_switch_to_edition_mode.s Routine Name vi_switch_to_edition_mode Routine documentation Routine vi_switch_to_edition_mode vi_switch_to_edition_mode Source code .proc vi_switch_to_edition_mode @loop: ; Display debug ldy vi_pos_debug jsr displays_debug ; end display debug jsr vi_compute_video_adress jsr vi_editor_switch_on_cursor cgetc cmp # KEY_ESC beq @exit cmp # KEY_UP beq @key_up cmp # KEY_DEL beq @key_del cmp # KEY_RETURN beq @key_enter cmp # KEY_DOWN beq @key_down cmp # KEY_RIGHT beq @key_right cmp # KEY_LEFT beq @key_left jsr @display_char jmp @loop @exit: rts @key_right: jsr vi_key_right jmp @loop @key_left: jsr vi_key_left jmp @loop @key_up: jsr vi_key_up jmp @loop @key_del: jsr vi_manage_del jmp @loop @key_enter: jsr vi_key_enter jmp @loop @key_down: jsr vi_key_down jmp @loop @display_char: jsr vi_display_char rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"/Routines/vi_switch_to_edition_mode.s"},{"location":"tools_docs/vi/Files/vi__switch__to__edition__mode_8s/#routinesvi_switch_to_edition_modes","text":"","title":"/Routines/vi_switch_to_edition_mode.s"},{"location":"tools_docs/vi/Files/vi__switch__to__edition__mode_8s/#routine","text":"Name vi_switch_to_edition_mode","title":"Routine"},{"location":"tools_docs/vi/Files/vi__switch__to__edition__mode_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__switch__to__edition__mode_8s/#routine-vi_switch_to_edition_mode","text":"vi_switch_to_edition_mode","title":"Routine vi_switch_to_edition_mode"},{"location":"tools_docs/vi/Files/vi__switch__to__edition__mode_8s/#source-code","text":".proc vi_switch_to_edition_mode @loop: ; Display debug ldy vi_pos_debug jsr displays_debug ; end display debug jsr vi_compute_video_adress jsr vi_editor_switch_on_cursor cgetc cmp # KEY_ESC beq @exit cmp # KEY_UP beq @key_up cmp # KEY_DEL beq @key_del cmp # KEY_RETURN beq @key_enter cmp # KEY_DOWN beq @key_down cmp # KEY_RIGHT beq @key_right cmp # KEY_LEFT beq @key_left jsr @display_char jmp @loop @exit: rts @key_right: jsr vi_key_right jmp @loop @key_left: jsr vi_key_left jmp @loop @key_up: jsr vi_key_up jmp @loop @key_del: jsr vi_manage_del jmp @loop @key_enter: jsr vi_key_enter jmp @loop @key_down: jsr vi_key_down jmp @loop @display_char: jsr vi_display_char rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__vi__ptr__file__used__plus__plus_8s/","text":"vi_vi_ptr_file_used_plus_plus.s Routine Name vi_vi_ptr_file_used_plus_plus Routine documentation Routine vi_vi_ptr_file_used_plus_plus vi_vi_ptr_file_used_plus_plus Source code .proc vi_vi_ptr_file_used_plus_plus ; A the char to add ; Insert into file (memory) char inc vi_ptr_file_used bne @no_inc inc vi_ptr_file_used + 1 @no_inc: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_vi_ptr_file_used_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__vi__ptr__file__used__plus__plus_8s/#vi_vi_ptr_file_used_plus_pluss","text":"","title":"vi_vi_ptr_file_used_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__vi__ptr__file__used__plus__plus_8s/#routine","text":"Name vi_vi_ptr_file_used_plus_plus","title":"Routine"},{"location":"tools_docs/vi/Files/vi__vi__ptr__file__used__plus__plus_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__vi__ptr__file__used__plus__plus_8s/#routine-vi_vi_ptr_file_used_plus_plus","text":"vi_vi_ptr_file_used_plus_plus","title":"Routine vi_vi_ptr_file_used_plus_plus"},{"location":"tools_docs/vi/Files/vi__vi__ptr__file__used__plus__plus_8s/#source-code","text":".proc vi_vi_ptr_file_used_plus_plus ; A the char to add ; Insert into file (memory) char inc vi_ptr_file_used bne @no_inc inc vi_ptr_file_used + 1 @no_inc: rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__xpos__screen__plus__plus_8s/","text":"vi_xpos_screen_plus_plus.s Routine Name vi_xpos_screen_plus_plus Routine documentation Routine vi_xpos_screen_plus_plus vi_xpos_screen_plus_plus Source code ; Returns in A=1 if we reached the eol .proc vi_xpos_screen_plus_plus ; ypos_screen=ypos_screen+1 ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # VI_EDITOR_MAX_COLUMN beq @no_add clc adc # $01 sta ( vi_struct ), y lda # $00 rts @no_add: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_xpos_screen_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__xpos__screen__plus__plus_8s/#vi_xpos_screen_plus_pluss","text":"","title":"vi_xpos_screen_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__xpos__screen__plus__plus_8s/#routine","text":"Name vi_xpos_screen_plus_plus","title":"Routine"},{"location":"tools_docs/vi/Files/vi__xpos__screen__plus__plus_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__xpos__screen__plus__plus_8s/#routine-vi_xpos_screen_plus_plus","text":"vi_xpos_screen_plus_plus","title":"Routine vi_xpos_screen_plus_plus"},{"location":"tools_docs/vi/Files/vi__xpos__screen__plus__plus_8s/#source-code","text":"; Returns in A=1 if we reached the eol .proc vi_xpos_screen_plus_plus ; ypos_screen=ypos_screen+1 ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y cmp # VI_EDITOR_MAX_COLUMN beq @no_add clc adc # $01 sta ( vi_struct ), y lda # $00 rts @no_add: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__xpos__screen__sub__sub_8s/","text":"vi_xpos_screen_sub_sub.s Routine Name vi_xpos_screen_sub_sub Routine documentation Routine vi_xpos_screen_sub_sub vi_xpos_screen_sub_sub Source code .proc vi_xpos_screen_sub_sub ;; vi_xpos_screen_sub_sub ;; Return 00 if we are on the first line ;; xpos_screen=ypos_screen+1 ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y beq @no_substract sec sbc # $01 sta ( vi_struct ), y lda # $01 rts @no_substract: lda # IS_BEGINNING_OF_THE_LINE rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_xpos_screen_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__xpos__screen__sub__sub_8s/#vi_xpos_screen_sub_subs","text":"","title":"vi_xpos_screen_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__xpos__screen__sub__sub_8s/#routine","text":"Name vi_xpos_screen_sub_sub","title":"Routine"},{"location":"tools_docs/vi/Files/vi__xpos__screen__sub__sub_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__xpos__screen__sub__sub_8s/#routine-vi_xpos_screen_sub_sub","text":"vi_xpos_screen_sub_sub","title":"Routine vi_xpos_screen_sub_sub"},{"location":"tools_docs/vi/Files/vi__xpos__screen__sub__sub_8s/#source-code","text":".proc vi_xpos_screen_sub_sub ;; vi_xpos_screen_sub_sub ;; Return 00 if we are on the first line ;; xpos_screen=ypos_screen+1 ldy # vi_struct_data: : xpos_screen lda ( vi_struct ), y beq @no_substract sec sbc # $01 sta ( vi_struct ), y lda # $01 rts @no_substract: lda # IS_BEGINNING_OF_THE_LINE rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ypos__screen__plus__plus_8s/","text":"vi_ypos_screen_plus_plus.s Routine Name vi_ypos_screen_plus_plus Increment ypos and returns IS_LAST_LINE_OF_SCREEN_TEXT. Routine documentation Routine vi_ypos_screen_plus_plus vi_ypos_screen_plus_plus Increment ypos and returns IS_LAST_LINE_OF_SCREEN_TEXT. See : vi_struct Return : A : IS_LAST_LINE_OF_SCREEN_TEXT if we are on the last line of the screen else $00 Source code ;; Increment ypos and returns IS_LAST_LINE_OF_SCREEN_TEXT ; ;@return A : IS_LAST_LINE_OF_SCREEN_TEXT if we are on the last line of the screen else $00 ;@see vi_struct ;; .proc vi_ypos_screen_plus_plus ; ypos_screen=ypos_screen+1 ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @no_add clc adc # $01 sta ( vi_struct ), y lda # $00 rts @no_add: ; lda # IS_LAST_LINE_OF_SCREEN_TEXT rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ypos_screen_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__ypos__screen__plus__plus_8s/#vi_ypos_screen_plus_pluss","text":"","title":"vi_ypos_screen_plus_plus.s"},{"location":"tools_docs/vi/Files/vi__ypos__screen__plus__plus_8s/#routine","text":"Name vi_ypos_screen_plus_plus Increment ypos and returns IS_LAST_LINE_OF_SCREEN_TEXT.","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ypos__screen__plus__plus_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ypos__screen__plus__plus_8s/#routine-vi_ypos_screen_plus_plus","text":"vi_ypos_screen_plus_plus Increment ypos and returns IS_LAST_LINE_OF_SCREEN_TEXT. See : vi_struct Return : A : IS_LAST_LINE_OF_SCREEN_TEXT if we are on the last line of the screen else $00","title":"Routine vi_ypos_screen_plus_plus"},{"location":"tools_docs/vi/Files/vi__ypos__screen__plus__plus_8s/#source-code","text":";; Increment ypos and returns IS_LAST_LINE_OF_SCREEN_TEXT ; ;@return A : IS_LAST_LINE_OF_SCREEN_TEXT if we are on the last line of the screen else $00 ;@see vi_struct ;; .proc vi_ypos_screen_plus_plus ; ypos_screen=ypos_screen+1 ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y cmp # VI_LAST_LINE_EDITOR beq @no_add clc adc # $01 sta ( vi_struct ), y lda # $00 rts @no_add: ; lda # IS_LAST_LINE_OF_SCREEN_TEXT rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Files/vi__ypos__screen__sub__sub_8s/","text":"vi_ypos_screen_sub_sub.s Routine Name vi_ypos_screen_sub_sub Decrement ypos. Routine documentation Routine vi_ypos_screen_sub_sub vi_ypos_screen_sub_sub Decrement ypos. See : vi_struct Return : A : returns 1 if y=0 or A returns 0 if y!=0 Source code ;; Decrement ypos ; ;@return A : returns 1 if y=0 or A returns 0 if y!=0 ;@see vi_struct ; ;; .proc vi_ypos_screen_sub_sub ; ypos_screen=ypos_screen-1 ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y beq @no_substract sec sbc # $01 sta ( vi_struct ), y lda # $00 rts @no_substract: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_ypos_screen_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__ypos__screen__sub__sub_8s/#vi_ypos_screen_sub_subs","text":"","title":"vi_ypos_screen_sub_sub.s"},{"location":"tools_docs/vi/Files/vi__ypos__screen__sub__sub_8s/#routine","text":"Name vi_ypos_screen_sub_sub Decrement ypos.","title":"Routine"},{"location":"tools_docs/vi/Files/vi__ypos__screen__sub__sub_8s/#routine-documentation","text":"","title":"Routine documentation"},{"location":"tools_docs/vi/Files/vi__ypos__screen__sub__sub_8s/#routine-vi_ypos_screen_sub_sub","text":"vi_ypos_screen_sub_sub Decrement ypos. See : vi_struct Return : A : returns 1 if y=0 or A returns 0 if y!=0","title":"Routine vi_ypos_screen_sub_sub"},{"location":"tools_docs/vi/Files/vi__ypos__screen__sub__sub_8s/#source-code","text":";; Decrement ypos ; ;@return A : returns 1 if y=0 or A returns 0 if y!=0 ;@see vi_struct ; ;; .proc vi_ypos_screen_sub_sub ; ypos_screen=ypos_screen-1 ldy # vi_struct_data: : ypos_screen lda ( vi_struct ), y beq @no_substract sec sbc # $01 sta ( vi_struct ), y lda # $00 rts @no_substract: lda # $01 rts .endproc Updated on 2022-12-15 at 14:20:17 +0100","title":"Source code"},{"location":"tools_docs/vi/Pages/strlen/","text":"strlen Updated on 2022-12-15 at 14:20:17 +0100","title":"strlen"},{"location":"tools_docs/vi/Pages/strlen/#strlen","text":"Updated on 2022-12-15 at 14:20:17 +0100","title":"strlen"},{"location":"tools_docs/vi/Structs/structvi__struct__data/","text":"vi_struct_data Public Attributes Name char xpos_screen char ypos_screen int pos_file_addr char[4] pos_file char posx_command_line char[VI_MAX_LENGTH_FILENAME] name_file_open int ptr_file_begin char[4] length_file int pos_ptr_video_address char[4] file_number_of_line char xpos_command_line char[39] command_line_buffer int ptr_last_char_file int line_id char xpos_text char ypos_text Public Attributes Documentation variable xpos_screen char xpos_screen ; position x of the cursor on the screen variable ypos_screen char ypos_screen ; position y of the cursor on the screen variable pos_file_addr int pos_file_addr ; position on the file (address) variable pos_file char [ 4 ] pos_file ; position in the file variable posx_command_line char posx_command_line ; position on command line variable name_file_open char [ VI_MAX_LENGTH_FILENAME ] name_file_open ; variable int int ; variable ptr_file_begin ptr_file_begin ; adress of the beginning of the file variable length_file char [ 4 ] length_file ; Length of the file variable pos_ptr_video_address int pos_ptr_video_address ; variable file_number_of_line char [ 4 ] file_number_of_line ; variable xpos_command_line char xpos_command_line ; variable command_line_buffer char [ 39 ] command_line_buffer ; variable ptr_last_char_file int ptr_last_char_file ; variable line_id int line_id ; variable xpos_text char xpos_text ; variable ypos_text char ypos_text ; Updated on 2022-12-15 at 14:20:17 +0100","title":"vi_struct_data"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#vi_struct_data","text":"","title":"vi_struct_data"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#public-attributes","text":"Name char xpos_screen char ypos_screen int pos_file_addr char[4] pos_file char posx_command_line char[VI_MAX_LENGTH_FILENAME] name_file_open int ptr_file_begin char[4] length_file int pos_ptr_video_address char[4] file_number_of_line char xpos_command_line char[39] command_line_buffer int ptr_last_char_file int line_id char xpos_text char ypos_text","title":"Public Attributes"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-xpos_screen","text":"char xpos_screen ; position x of the cursor on the screen","title":"variable xpos_screen"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-ypos_screen","text":"char ypos_screen ; position y of the cursor on the screen","title":"variable ypos_screen"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-pos_file_addr","text":"int pos_file_addr ; position on the file (address)","title":"variable pos_file_addr"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-pos_file","text":"char [ 4 ] pos_file ; position in the file","title":"variable pos_file"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-posx_command_line","text":"char posx_command_line ; position on command line","title":"variable posx_command_line"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-name_file_open","text":"char [ VI_MAX_LENGTH_FILENAME ] name_file_open ;","title":"variable name_file_open"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-int","text":"int ;","title":"variable int"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-ptr_file_begin","text":"ptr_file_begin ; adress of the beginning of the file","title":"variable ptr_file_begin"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-length_file","text":"char [ 4 ] length_file ; Length of the file","title":"variable length_file"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-pos_ptr_video_address","text":"int pos_ptr_video_address ;","title":"variable pos_ptr_video_address"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-file_number_of_line","text":"char [ 4 ] file_number_of_line ;","title":"variable file_number_of_line"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-xpos_command_line","text":"char xpos_command_line ;","title":"variable xpos_command_line"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-command_line_buffer","text":"char [ 39 ] command_line_buffer ;","title":"variable command_line_buffer"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-ptr_last_char_file","text":"int ptr_last_char_file ;","title":"variable ptr_last_char_file"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-line_id","text":"int line_id ;","title":"variable line_id"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-xpos_text","text":"char xpos_text ;","title":"variable xpos_text"},{"location":"tools_docs/vi/Structs/structvi__struct__data/#variable-ypos_text","text":"char ypos_text ; Updated on 2022-12-15 at 14:20:17 +0100","title":"variable ypos_text"},{"location":"tutorials/","text":"","title":"Index"},{"location":"tutorials/basic11_programming_fr/","text":"Programmer en basic sur la machine D\u00e9marrer basic11 au shell : /#basic11 taper son programme : 10 ?\"Salut Sauvegarder : CSAVE\"PRG quitter taper quit ou appuyer sur reset sur le shell voir la pr\u00e9sence de son fichier dans le bon folder : /#cd home/basic11 /#ls PRG.* => il devrait \u00eatre pr\u00e9sent. Revenir au basic11 et le charger /#basic11 CLOAD\"PRG LIST","title":"Programmer en basic sur la machine"},{"location":"tutorials/basic11_programming_fr/#programmer-en-basic-sur-la-machine","text":"D\u00e9marrer basic11 au shell : /#basic11 taper son programme : 10 ?\"Salut Sauvegarder : CSAVE\"PRG quitter taper quit ou appuyer sur reset sur le shell voir la pr\u00e9sence de son fichier dans le bon folder : /#cd home/basic11 /#ls PRG.* => il devrait \u00eatre pr\u00e9sent. Revenir au basic11 et le charger /#basic11 CLOAD\"PRG LIST","title":"Programmer en basic sur la machine"},{"location":"tutorials/network/","text":"Gestion ethernet beta (WIP) : n\u00e9cessite une carte \u00e0 ins\u00e9rer dans la twilighte board ATTENTION : c'est une version en cours de dev, il y a beaucoup de bugs. D\u00e9marrer l'oric s'assurer que le cable r\u00e9seau est branch\u00e9 sur la carte r\u00e9seau et que le cable est bien sur un r\u00e9seau disposant d'un dhcp Presser FUNCT+L (pour passer un bug) quitter (ESC) pui presser FUNCT+N et attendre le d\u00e9marrage de la couche r\u00e9seau. 3 [OK] en vert devrait apparaitre, si ce n'est pas le cas, se r\u00e9f\u00e9rer \u00e0 l'erreur concern\u00e9e (cable d\u00e9branch\u00e9, dhcp ...) Quand tout est vert, regarder l'ip r\u00e9cup\u00e9r\u00e9e au dhcp : /#ifcfg L'adresse IP est pr\u00e9sente et la mac address de la carte est pr\u00e9sente aussi. V\u00e9rifier les commandes qu'apporte ce d\u00e9marrage r\u00e9seau (banque network num\u00e9ro 34) /#help -b34 V\u00e9rifier le serveur DNS configur\u00e9 /#resvctl Faire une r\u00e9solution dns d'oric.org puis de www.google.com /#dig www.oric.org puis /#dig www.google.com Envoyer un message sur un serveur rsyslog => n\u00e9cessite d'avoir un serveur rsyslog sur le r\u00e9seau acceptant les messages en UDP (\u00e0 configurer sur le serveur distant) /#nc -u 192.168.1.200 514 -s MONMSG Telecharger un fichier de 5 mo et l'\u00e9crire sur disque /# curl => attendre 3 Mins, le programme rend la main. /# ls -l un fichier index.htm de 5mo est pr\u00e9sent /# v => fait appelle un serveur web, et r\u00e9cup\u00e8re un index.hlp qui s'affiche \u00e0 l'\u00e9cran","title":"Gestion ethernet beta (WIP) : n\u00e9cessite une carte \u00e0 ins\u00e9rer dans la twilighte board"},{"location":"tutorials/network/#gestion-ethernet-beta-wip-necessite-une-carte-a-inserer-dans-la-twilighte-board","text":"ATTENTION : c'est une version en cours de dev, il y a beaucoup de bugs. D\u00e9marrer l'oric s'assurer que le cable r\u00e9seau est branch\u00e9 sur la carte r\u00e9seau et que le cable est bien sur un r\u00e9seau disposant d'un dhcp Presser FUNCT+L (pour passer un bug) quitter (ESC) pui presser FUNCT+N et attendre le d\u00e9marrage de la couche r\u00e9seau. 3 [OK] en vert devrait apparaitre, si ce n'est pas le cas, se r\u00e9f\u00e9rer \u00e0 l'erreur concern\u00e9e (cable d\u00e9branch\u00e9, dhcp ...) Quand tout est vert, regarder l'ip r\u00e9cup\u00e9r\u00e9e au dhcp : /#ifcfg L'adresse IP est pr\u00e9sente et la mac address de la carte est pr\u00e9sente aussi. V\u00e9rifier les commandes qu'apporte ce d\u00e9marrage r\u00e9seau (banque network num\u00e9ro 34) /#help -b34 V\u00e9rifier le serveur DNS configur\u00e9 /#resvctl Faire une r\u00e9solution dns d'oric.org puis de www.google.com /#dig www.oric.org puis /#dig www.google.com Envoyer un message sur un serveur rsyslog => n\u00e9cessite d'avoir un serveur rsyslog sur le r\u00e9seau acceptant les messages en UDP (\u00e0 configurer sur le serveur distant) /#nc -u 192.168.1.200 514 -s MONMSG Telecharger un fichier de 5 mo et l'\u00e9crire sur disque /# curl => attendre 3 Mins, le programme rend la main. /# ls -l un fichier index.htm de 5mo est pr\u00e9sent /# v => fait appelle un serveur web, et r\u00e9cup\u00e8re un index.hlp qui s'affiche \u00e0 l'\u00e9cran","title":"Gestion ethernet beta (WIP) : n\u00e9cessite une carte \u00e0 ins\u00e9rer dans la twilighte board"},{"location":"tutorials/start_a_software_fr/","text":"D\u00e9marrer un software D\u00e9marrer un soft oric-1 ou atmos (Loader v2022.3) Exemple d'un jeu atmos (A.T.M) D\u00e9marrer l'oric Au shell, appuyer sur funct+L : un menu apparait. Aller sur l'icone joyspad. Appuyer sur la touche A -> Nous arrivons sur le premier jeu commen\u00e7ant par la lettre A Appuyer sur espace : la fiche de jeu s'affiche. Utiliser la fl\u00e8che du bas pour descendre et acc\u00e9der par exemple aux commentaires. Pour revenir en haut de la fiche, appuyer sur la touche haut. Quitter la fiche jeu, appuyer sur espace. Appuyer sur entr\u00e9e pour d\u00e9marrer ATM. Pour quitter le jeu, appuyer sur le bouton reset. Le loader permet de lancer les soft oric-1 et atmos, mais pas seulement \u00e0 l'avenir Demarrer un soft oric-1 only D\u00e9marrer l'oric taper basic10 -g naviguer avec les fl\u00e8ches et choisir le soft \u00e0 lancer avec les fl\u00e8ches : Appuyer sur entr\u00e9e Demarrer un soft Atmos only D\u00e9marrer l'oric taper basic11 -g naviguer avec les fl\u00e8ches et choisir le soft \u00e0 lancer avec les fl\u00e8ches : Appuyer sur entr\u00e9e Demarrer un soft personnel sur atmos Sur le shell, taper : cd /home/basic11 ls Memoriser le nom d'un .tap dans la liste Puis taper au shell basic11 basic11 Puis faire un cload : CLOAD\"MONTAP D\u00e9marrer un .dsk jasmin sans lecteur jasmin (beta) Rep\u00e9rer un dsk dans /home/basic11/dsk /#cd home/basic11/dsk /#ls Prendre par exemple le dsk theoric9.dsk Lancer ftdos avec ce dsk : ftdos theoric9 Le dsk d\u00e9marre. Regarder le contenu du dsk : !CAT\"","title":"D\u00e9marrer un software"},{"location":"tutorials/start_a_software_fr/#demarrer-un-software","text":"","title":"D\u00e9marrer un software"},{"location":"tutorials/start_a_software_fr/#demarrer-un-soft-oric-1-ou-atmos-loader-v20223","text":"Exemple d'un jeu atmos (A.T.M) D\u00e9marrer l'oric Au shell, appuyer sur funct+L : un menu apparait. Aller sur l'icone joyspad. Appuyer sur la touche A -> Nous arrivons sur le premier jeu commen\u00e7ant par la lettre A Appuyer sur espace : la fiche de jeu s'affiche. Utiliser la fl\u00e8che du bas pour descendre et acc\u00e9der par exemple aux commentaires. Pour revenir en haut de la fiche, appuyer sur la touche haut. Quitter la fiche jeu, appuyer sur espace. Appuyer sur entr\u00e9e pour d\u00e9marrer ATM. Pour quitter le jeu, appuyer sur le bouton reset. Le loader permet de lancer les soft oric-1 et atmos, mais pas seulement \u00e0 l'avenir","title":"D\u00e9marrer un soft oric-1 ou atmos (Loader v2022.3)"},{"location":"tutorials/start_a_software_fr/#demarrer-un-soft-oric-1-only","text":"D\u00e9marrer l'oric taper basic10 -g naviguer avec les fl\u00e8ches et choisir le soft \u00e0 lancer avec les fl\u00e8ches : Appuyer sur entr\u00e9e","title":"Demarrer un soft oric-1 only"},{"location":"tutorials/start_a_software_fr/#demarrer-un-soft-atmos-only","text":"D\u00e9marrer l'oric taper basic11 -g naviguer avec les fl\u00e8ches et choisir le soft \u00e0 lancer avec les fl\u00e8ches : Appuyer sur entr\u00e9e","title":"Demarrer un soft Atmos only"},{"location":"tutorials/start_a_software_fr/#demarrer-un-soft-personnel-sur-atmos","text":"Sur le shell, taper : cd /home/basic11 ls Memoriser le nom d'un .tap dans la liste Puis taper au shell basic11 basic11 Puis faire un cload : CLOAD\"MONTAP","title":"Demarrer un soft personnel sur atmos"},{"location":"tutorials/start_a_software_fr/#demarrer-un-dsk-jasmin-sans-lecteur-jasmin-beta","text":"Rep\u00e9rer un dsk dans /home/basic11/dsk /#cd home/basic11/dsk /#ls Prendre par exemple le dsk theoric9.dsk Lancer ftdos avec ce dsk : ftdos theoric9 Le dsk d\u00e9marre. Regarder le contenu du dsk : !CAT\"","title":"D\u00e9marrer un .dsk jasmin sans lecteur jasmin (beta)"},{"location":"update/2022_3/","text":"v2022.3 Kernel [XMKDIR] Fix registers [XATN] Arc Tan routine removed [XCOS] Cosinus routine removed [XSIN] sinus routine removed [XLN] Ln routine removed [XLOG] Log routine removed [XEXP] Exp routine removed [XOPEN] Now, WR_ONLY Flag does not create the file. O_CREAT is handled and create the file [XFSEEK] now works in 32 bits mode (return EOK if OK, EINVAL if whence is not recognize) [XOPEN] [XREAD] [XCLOSE] Allows to open 2 files at the same times [XFREE] Fix many bugs [Load from device] Add magic token to start any binary without checks Can open 2 files at the same times Many bugs corrected in XFREE primitive memory management FSEEK primitive to move into the opened files CC65 (telestrat target) [cc65] Fix mkdir bug [cc65] now send correct fd for fwrite/fopen/fread to the kernel [cc65] kbhit has the right behavior now Shell Add readline (command line behavior) : insert/replace mode move to end of the line, at the beginning etc (see : sh - Orix (orix-software.github.io) code : Assinie) update man pages Readline : Man man removes shell ptr and no others command were working, when man is used without any argument => fixed man can displays now more than one screen Loader (funct+L) Displays the version of the loader When we press space the informations(and comments) of the software is displayed. Up and down arrows are availables to navigate into this page (788 games, 60 roms, 35 demos, 142 tools, 80 musics) When a letter is pressed, it goes to the first entry of this letter. New command line tool : grep Grep search pattern into file (grep is a tool to find pattern into file.) New command line tool : untar can untar tar files New command line tool : submit submit can launch script file(Submit is a script management system in order to launch command like a shell script) How to upgrade Download https://repo.orix.oric.org/dists/official/tgz/6502/sdcard.tgz gunzip/untar sdcard.tgz on the twilighte board device type in the orix shell : cd /usr/share/carts/2022.3 if the default device is a usb key /# orixcfg -r -s 4 kernelus.r64 if the default device is a sdcard /#orixcfg -r -s 4 kernelsd.r64 Convertion Pushing the envelop born in 1983 Blake's 7 Oric tech ...","title":2022.3},{"location":"update/2022_3/#v20223","text":"","title":"v2022.3"},{"location":"update/2022_3/#kernel","text":"[XMKDIR] Fix registers [XATN] Arc Tan routine removed [XCOS] Cosinus routine removed [XSIN] sinus routine removed [XLN] Ln routine removed [XLOG] Log routine removed [XEXP] Exp routine removed [XOPEN] Now, WR_ONLY Flag does not create the file. O_CREAT is handled and create the file [XFSEEK] now works in 32 bits mode (return EOK if OK, EINVAL if whence is not recognize) [XOPEN] [XREAD] [XCLOSE] Allows to open 2 files at the same times [XFREE] Fix many bugs [Load from device] Add magic token to start any binary without checks Can open 2 files at the same times Many bugs corrected in XFREE primitive memory management FSEEK primitive to move into the opened files","title":"Kernel"},{"location":"update/2022_3/#cc65-telestrat-target","text":"[cc65] Fix mkdir bug [cc65] now send correct fd for fwrite/fopen/fread to the kernel [cc65] kbhit has the right behavior now","title":"CC65 (telestrat target)"},{"location":"update/2022_3/#shell","text":"Add readline (command line behavior) : insert/replace mode move to end of the line, at the beginning etc (see : sh - Orix (orix-software.github.io) code : Assinie) update man pages Readline :","title":"Shell"},{"location":"update/2022_3/#man","text":"man removes shell ptr and no others command were working, when man is used without any argument => fixed man can displays now more than one screen","title":"Man"},{"location":"update/2022_3/#loader-functl","text":"Displays the version of the loader When we press space the informations(and comments) of the software is displayed. Up and down arrows are availables to navigate into this page (788 games, 60 roms, 35 demos, 142 tools, 80 musics) When a letter is pressed, it goes to the first entry of this letter.","title":"Loader (funct+L)"},{"location":"update/2022_3/#new-command-line-tool-grep","text":"Grep search pattern into file (grep is a tool to find pattern into file.)","title":"New command line tool : grep"},{"location":"update/2022_3/#new-command-line-tool-untar","text":"can untar tar files","title":"New command line tool : untar"},{"location":"update/2022_3/#new-command-line-tool-submit","text":"submit can launch script file(Submit is a script management system in order to launch command like a shell script)","title":"New command line tool : submit"},{"location":"update/2022_3/#how-to-upgrade","text":"Download https://repo.orix.oric.org/dists/official/tgz/6502/sdcard.tgz gunzip/untar sdcard.tgz on the twilighte board device type in the orix shell : cd /usr/share/carts/2022.3 if the default device is a usb key /# orixcfg -r -s 4 kernelus.r64 if the default device is a sdcard /#orixcfg -r -s 4 kernelsd.r64","title":"How to upgrade"},{"location":"update/2022_3/#convertion","text":"Pushing the envelop born in 1983 Blake's 7 Oric tech ...","title":"Convertion"},{"location":"update/2022_4/","text":"v2022.4 and v2022.4.1 Kernel Kernel supports relocation mode binary fixbug in multiples files opened CC65 (telestrat target) binary from cc65 will be deprecated (without relocbin tool in order to convert it in relocation mode). It needs to get relocbin from orix-sdk : https://github.com/assinie/orix-sdk Shell cp now works many man pages had been improved bugfix with \"cd /\" which did not work How to upgrade Download https://repo.orix.oric.org/dists/official/tgz/6502/sdcard.tgz gunzip/untar sdcard.tgz on the twilighte board device type in the orix shell : cd /usr/share/carts/2022.4 if the default device is a usb key /# orixcfg -r -s 4 kernelus.r64 if the default device is a sdcard /# orixcfg -r -s 4 kernelsd.r64","title":2022.4},{"location":"update/2022_4/#v20224-and-v202241","text":"","title":"v2022.4 and v2022.4.1"},{"location":"update/2022_4/#kernel","text":"Kernel supports relocation mode binary fixbug in multiples files opened","title":"Kernel"},{"location":"update/2022_4/#cc65-telestrat-target","text":"binary from cc65 will be deprecated (without relocbin tool in order to convert it in relocation mode). It needs to get relocbin from orix-sdk : https://github.com/assinie/orix-sdk","title":"CC65 (telestrat target)"},{"location":"update/2022_4/#shell","text":"cp now works many man pages had been improved bugfix with \"cd /\" which did not work","title":"Shell"},{"location":"update/2022_4/#how-to-upgrade","text":"Download https://repo.orix.oric.org/dists/official/tgz/6502/sdcard.tgz gunzip/untar sdcard.tgz on the twilighte board device type in the orix shell : cd /usr/share/carts/2022.4 if the default device is a usb key /# orixcfg -r -s 4 kernelus.r64 if the default device is a sdcard /# orixcfg -r -s 4 kernelsd.r64","title":"How to upgrade"},{"location":"update/2023_1/","text":"2023.1 Kernel add ftell in XVALUES primitive add getProcessName from an id malloc entry get table copy of free malloc table (from XVALUES) get table copy of busy malloc table (from XVALUES) when MAX_PROCESS is reached, kernel displays a kernel panic fix bug when wronly us set only fix two bugs for dynamic relocation format (2) Shell lsmem is recoded from scratch /etc/autoboot is checked at the start of shell in order to boot any submit script (autoboot is a .sub file without extension) pstree added It's now possible to add \"#\" on command line to specify a comment Install Download : https://repo.orix.oric.org/dists/official/tgz/6502/cardridge.tgz untar/gunzip on the twilighte board device. orixcfg (below 2023.2 orixcfg version) Under Orix /# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.1# orixcfg -r -s 4 kernelus.r64 orixcfg (equal or greater than 2023.2 orixcfg version) /# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.1# orixcfg -k kernelus.r64","title":2023.1},{"location":"update/2023_1/#20231","text":"","title":"2023.1"},{"location":"update/2023_1/#kernel","text":"add ftell in XVALUES primitive add getProcessName from an id malloc entry get table copy of free malloc table (from XVALUES) get table copy of busy malloc table (from XVALUES) when MAX_PROCESS is reached, kernel displays a kernel panic fix bug when wronly us set only fix two bugs for dynamic relocation format (2)","title":"Kernel"},{"location":"update/2023_1/#shell","text":"lsmem is recoded from scratch /etc/autoboot is checked at the start of shell in order to boot any submit script (autoboot is a .sub file without extension) pstree added It's now possible to add \"#\" on command line to specify a comment","title":"Shell"},{"location":"update/2023_1/#install","text":"Download : https://repo.orix.oric.org/dists/official/tgz/6502/cardridge.tgz untar/gunzip on the twilighte board device.","title":"Install"},{"location":"update/2023_1/#orixcfg-below-20232-orixcfg-version","text":"Under Orix /# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.1# orixcfg -r -s 4 kernelus.r64","title":"orixcfg (below 2023.2 orixcfg version)"},{"location":"update/2023_1/#orixcfg-equal-or-greater-than-20232-orixcfg-version","text":"/# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.1# orixcfg -k kernelus.r64","title":"orixcfg (equal or greater than 2023.2 orixcfg version)"},{"location":"update/2023_2/","text":"2023.2 Kernel XEXEC works with absolute path (/root/bin/toto can be launched) XEXEC works with relative \"./\" syntax only (./toto can be launched) Shell Install Download : https://repo.orix.oric.org/dists/official/tgz/6502/cardridge.tgz untar/gunzip on the twilighte board device. orixcfg (below 2023.2 orixcfg version) Under Orix /# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.2# orixcfg -r -s 4 kernelus.r64 orixcfg (equal or greater than 2023.2 orixcfg version) /# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.1# orixcfg -k kernelus.r64","title":"2023.2"},{"location":"update/2023_2/#20232","text":"","title":"2023.2"},{"location":"update/2023_2/#kernel","text":"XEXEC works with absolute path (/root/bin/toto can be launched) XEXEC works with relative \"./\" syntax only (./toto can be launched)","title":"Kernel"},{"location":"update/2023_2/#shell","text":"","title":"Shell"},{"location":"update/2023_2/#install","text":"Download : https://repo.orix.oric.org/dists/official/tgz/6502/cardridge.tgz untar/gunzip on the twilighte board device.","title":"Install"},{"location":"update/2023_2/#orixcfg-below-20232-orixcfg-version","text":"Under Orix /# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.2# orixcfg -r -s 4 kernelus.r64","title":"orixcfg (below 2023.2 orixcfg version)"},{"location":"update/2023_2/#orixcfg-equal-or-greater-than-20232-orixcfg-version","text":"/# cd /usr/share/carts/2023.1/ /usr/share/carts/2023.1# orixcfg -k kernelus.r64","title":"orixcfg (equal or greater than 2023.2 orixcfg version)"},{"location":"update/file/file/","text":"file 2022.4 Built in order to manage fd file open built in relocation binary displays more informations from format 2","title":"File"},{"location":"update/file/file/#file","text":"","title":"file"},{"location":"update/file/file/#20224","text":"Built in order to manage fd file open built in relocation binary displays more informations from format 2","title":"2022.4"},{"location":"user_manual/loader/","text":"Loader Loader can start atmos or oric-1 tape files. If the software is available for Atmos, the tape file will be launched with atmos rom. But if the tape file is Oric-1 only, the software will be launched only in Oric-1 mode Usage Press ++funct+L++ to start loader","title":"Software loader"},{"location":"user_manual/loader/#loader","text":"Loader can start atmos or oric-1 tape files. If the software is available for Atmos, the tape file will be launched with atmos rom. But if the tape file is Oric-1 only, the software will be launched only in Oric-1 mode","title":"Loader"},{"location":"user_manual/loader/#usage","text":"Press ++funct+L++ to start loader","title":"Usage"},{"location":"user_manual/overview/","text":"Overview","title":"Overview"},{"location":"user_manual/overview/#overview","text":"","title":"Overview"},{"location":"user_manual/quickstart/","text":"Quick Start Default storage : the kernel is set with usb storage. The manual is : https://orix-software.github.io/twilighte_manual.pdf For board with 39SF040 eeprom, only use orixcfg equal or greater than 2023.2. Check version under Orix with : orixcfg -v. Beta version is here: http://repo.orix.oric.org/dists/alpha/tgz/6502/orixcfg.tgz How the board must be plugged How the board must be plugged when board does not with the oric (keyboard is lost or prompt does not appears)","title":"Quick Start"},{"location":"user_manual/quickstart/#quick-start","text":"Default storage : the kernel is set with usb storage. The manual is : https://orix-software.github.io/twilighte_manual.pdf For board with 39SF040 eeprom, only use orixcfg equal or greater than 2023.2. Check version under Orix with : orixcfg -v. Beta version is here: http://repo.orix.oric.org/dists/alpha/tgz/6502/orixcfg.tgz","title":"Quick Start"},{"location":"user_manual/quickstart/#how-the-board-must-be-plugged","text":"","title":"How the board must be plugged"},{"location":"user_manual/quickstart/#how-the-board-must-be-plugged-when-board-does-not-with-the-oric-keyboard-is-lost-or-prompt-does-not-appears","text":"","title":"How the board must be plugged when board does not with the oric (keyboard is lost or prompt does not appears)"}]}