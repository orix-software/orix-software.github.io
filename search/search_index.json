{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos Stratos . Twilighte Board . Orix 8 bits - Kernel Orix 16 bits Basic11 command and rom ch376 Doxygen for kernel .","title":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos"},{"location":"#documentation-for-orix8-bits-and-16-bits-twilighte-board-and-stratos","text":"Stratos . Twilighte Board . Orix 8 bits - Kernel Orix 16 bits Basic11 command and rom ch376 Doxygen for kernel .","title":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos"},{"location":"ch376/","text":"ch376","title":"ch376"},{"location":"ch376/#ch376","text":"","title":"ch376"},{"location":"ch376/vars8/","text":"CH376 extra vars Vars 8 #define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous-classe du p\u00e9riph\u00e9rique de stockage USB SubClass-Code, le bit 6 est 0 pour indiquer que la sous-classe est 6 et le bit 6 est 1 pour indiquer que la sous-classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l'\u00e9tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l'\u00e9tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB, si le bit 5 est 1, la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB, si le bit 5 est 1, il y a un p\u00e9riph\u00e9rique USB dans le port USB, et si le bit 5 est 0, il n'y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l'\u00e9tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB. Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu'il a \u00e9t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0, il ne r\u00e9essayera pas lorsque NAK est re\u00e7u, le bit 7 est 1 et le bit 6 est 0, et r\u00e9essayera \u00e0 l'infini lors de la r\u00e9ception de NAK (vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l'expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0, l'indicateur du syst\u00e8me de fichiers FAT du disque logique, 00-FAT12, 01-FAT16, 10-FAT32, 11-ill\u00e9gal * / / * Bit 2, indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9t\u00e9 modifi\u00e9es, 0-non modifi\u00e9, 1-modifi\u00e9 * / / * Bit 3, la longueur du fichier doit \u00eatre modifi\u00e9e, le fichier actuel est ajout\u00e9 avec les donn\u00e9es, 0-Aucune modification n'est pas ajout\u00e9e, 1-Ajout\u00e9 et doit \u00eatre modifi\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0, version de la carte SD, 0- prend uniquement en charge la premi\u00e8re version SD, 1- prend en charge la deuxi\u00e8me version SD * / / * Bit 1, reconnaissance automatique, carte 0-SD, carte 1-MMC * / / * Bit 2, identification automatique, carte SD de capacit\u00e9 standard 0, carte SD 1 grande capacit\u00e9 (HC-SD) * / / * Bit 4, d\u00e9lai d'expiration de la commande ACMD41 * / / * Bit 5, d\u00e9lai d'expiration de la commande CMD1 * / / * Bit 6, d\u00e9lai d'expiration de la commande CMD58 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0, doit \u00eatre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4, le num\u00e9ro d'unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB, apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB, la valeur par d\u00e9faut est d'acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0, le num\u00e9ro d'unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB, plus 1 est \u00e9gal au nombre d'unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"CH376 extra vars"},{"location":"ch376/vars8/#ch376-extra-vars","text":"","title":"CH376 extra vars"},{"location":"ch376/vars8/#vars-8","text":"#define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous-classe du p\u00e9riph\u00e9rique de stockage USB SubClass-Code, le bit 6 est 0 pour indiquer que la sous-classe est 6 et le bit 6 est 1 pour indiquer que la sous-classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l'\u00e9tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l'\u00e9tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB, si le bit 5 est 1, la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB, si le bit 5 est 1, il y a un p\u00e9riph\u00e9rique USB dans le port USB, et si le bit 5 est 0, il n'y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l'\u00e9tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB. Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu'il a \u00e9t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0, il ne r\u00e9essayera pas lorsque NAK est re\u00e7u, le bit 7 est 1 et le bit 6 est 0, et r\u00e9essayera \u00e0 l'infini lors de la r\u00e9ception de NAK (vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l'expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0, l'indicateur du syst\u00e8me de fichiers FAT du disque logique, 00-FAT12, 01-FAT16, 10-FAT32, 11-ill\u00e9gal * / / * Bit 2, indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9t\u00e9 modifi\u00e9es, 0-non modifi\u00e9, 1-modifi\u00e9 * / / * Bit 3, la longueur du fichier doit \u00eatre modifi\u00e9e, le fichier actuel est ajout\u00e9 avec les donn\u00e9es, 0-Aucune modification n'est pas ajout\u00e9e, 1-Ajout\u00e9 et doit \u00eatre modifi\u00e9 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0, version de la carte SD, 0- prend uniquement en charge la premi\u00e8re version SD, 1- prend en charge la deuxi\u00e8me version SD * / / * Bit 1, reconnaissance automatique, carte 0-SD, carte 1-MMC * / / * Bit 2, identification automatique, carte SD de capacit\u00e9 standard 0, carte SD 1 grande capacit\u00e9 (HC-SD) * / / * Bit 4, d\u00e9lai d'expiration de la commande ACMD41 * / / * Bit 5, d\u00e9lai d'expiration de la commande CMD1 * / / * Bit 6, d\u00e9lai d'expiration de la commande CMD58 * / / * Autres bits, r\u00e9serv\u00e9s, veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6, indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0, doit \u00eatre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4, le num\u00e9ro d'unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB, apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB, la valeur par d\u00e9faut est d'acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0, le num\u00e9ro d'unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB, plus 1 est \u00e9gal au nombre d'unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"Vars 8"},{"location":"orix8bits/","text":"Orix 8 Bits Install environment development for developers Getting-started Kernel primitives Primitives Tools Doxygen for kernel . Samples for kernel calls Get ctrl+c hook .include \"telestrat.inc\" asl KBDCTC bcc @no_ctrl ; here is ctrl management @no_ctrl: rts Test kernel Error when fopen failed ; Open ... BRK_KERNEL XOPEN cpy #$00 bne @read_rom cmp #$00 bne @read_rom ldx #$04 ; Get kernel ERRNO BRK_KERNEL XVARS sta userzp sty userzp+1 ldy #$00 lda (userzp),y ; get ERRNO from kernel cmp #ENOMEM bne @no_enomem_kernel_error PRINT str_enomem @no_enomem_kernel_error: cmp #ENOENT bne @no_enoent_kernel_error PRINT str_not_found Stop output when spacebar is pressed (for example) .include \"telestrat.inc\" @L12: BRK_KERNEL XRD0 bcs @no_char_action cmp #' ' ; Space pressed ? bne @no_char ; no continue lda myOffsetToManageSwitch ; One byte beq @inv_to_1 lda #$00 sta myOffsetToManageSwitch jmp @L12 @inv_to_1: inc myOffsetToManageSwitch jmp @L12 @no_char_action: lda myOffsetToManageSwitch beq @L12 @no_char: ; No keypressed Displays a string lda #<mystr ldy #>mystr BRK_KERNEL XWRSTR0 rts mysstr: .asciiz \"hello\"","title":"Orix 8 Bits"},{"location":"orix8bits/#orix-8-bits","text":"","title":"Orix 8 Bits"},{"location":"orix8bits/#install-environment-development-for-developers","text":"Getting-started","title":"Install environment development for developers"},{"location":"orix8bits/#kernel-primitives","text":"Primitives Tools Doxygen for kernel .","title":"Kernel primitives"},{"location":"orix8bits/#samples-for-kernel-calls","text":"","title":"Samples for kernel calls"},{"location":"orix8bits/#get-ctrlc-hook","text":".include \"telestrat.inc\" asl KBDCTC bcc @no_ctrl ; here is ctrl management @no_ctrl: rts","title":"Get ctrl+c hook"},{"location":"orix8bits/#test-kernel-error-when-fopen-failed","text":"; Open ... BRK_KERNEL XOPEN cpy #$00 bne @read_rom cmp #$00 bne @read_rom ldx #$04 ; Get kernel ERRNO BRK_KERNEL XVARS sta userzp sty userzp+1 ldy #$00 lda (userzp),y ; get ERRNO from kernel cmp #ENOMEM bne @no_enomem_kernel_error PRINT str_enomem @no_enomem_kernel_error: cmp #ENOENT bne @no_enoent_kernel_error PRINT str_not_found","title":"Test kernel Error when fopen failed"},{"location":"orix8bits/#stop-output-when-spacebar-is-pressed-for-example","text":".include \"telestrat.inc\" @L12: BRK_KERNEL XRD0 bcs @no_char_action cmp #' ' ; Space pressed ? bne @no_char ; no continue lda myOffsetToManageSwitch ; One byte beq @inv_to_1 lda #$00 sta myOffsetToManageSwitch jmp @L12 @inv_to_1: inc myOffsetToManageSwitch jmp @L12 @no_char_action: lda myOffsetToManageSwitch beq @L12 @no_char: ; No keypressed","title":"Stop output when spacebar is pressed (for example)"},{"location":"orix8bits/#displays-a-string","text":"lda #<mystr ldy #>mystr BRK_KERNEL XWRSTR0 rts mysstr: .asciiz \"hello\"","title":"Displays a string"},{"location":"orix8bits/getting-started/","text":"Install Step 1 : Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board=yes plugins/twilighte_board/twilighte.cfg you can put any rom you want. Step 2 : start oricutron Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip Step 3 : Download/build cc65 Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder) Step 4 : Download SDK (mainly for assembly) Clone https://github.com/assinie/orix-sdk in your project folder","title":"Install"},{"location":"orix8bits/getting-started/#install","text":"","title":"Install"},{"location":"orix8bits/getting-started/#step-1-configure-and-start-oricutron-with-twilighte-board","text":"Build from source code oricutron : https://github.com/pete-gordon/oricutron In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board=yes plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Step 1 : Configure and start oricutron with twilighte board"},{"location":"orix8bits/getting-started/#step-2-start-oricutron","text":"Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip","title":"Step 2 : start oricutron"},{"location":"orix8bits/getting-started/#step-3-downloadbuild-cc65","text":"Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder)","title":"Step 3 : Download/build cc65"},{"location":"orix8bits/getting-started/#step-4-download-sdk-mainly-for-assembly","text":"Clone https://github.com/assinie/orix-sdk in your project folder","title":"Step 4 : Download SDK  (mainly for assembly)"},{"location":"orix8bits/getting-started/kernel/","text":"Kernel Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orix SDK manages some kernel calls, and it's better to use macro set to call some primitives","title":"Kernel"},{"location":"orix8bits/getting-started/kernel/#kernel","text":"Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orix SDK manages some kernel calls, and it's better to use macro set to call some primitives","title":"Kernel"},{"location":"orix8bits/informations/binary_starts/","text":"Binary start sequence All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls xexec kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD Step 1 : check if binary in a bank Xexec reads all banks from 4 to 1 and tries to check if the program if in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks) That is why commands located in bank are quicker to start Step 2 : Check if the binary is on the device. If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If open fails, it returns command not found or impossible to mount if device is not present. Step 3 : binary on device is found Kernel opens the file, reads the header, and load contains of the binary on the right address. When it's OK, the binary is started (and a fork occurs.)","title":"Binary start sequence"},{"location":"orix8bits/informations/binary_starts/#binary-start-sequence","text":"All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls xexec kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD","title":"Binary start sequence"},{"location":"orix8bits/informations/binary_starts/#step-1-check-if-binary-in-a-bank","text":"Xexec reads all banks from 4 to 1 and tries to check if the program if in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks) That is why commands located in bank are quicker to start","title":"Step 1 : check if binary in a bank"},{"location":"orix8bits/informations/binary_starts/#step-2-check-if-the-binary-is-on-the-device","text":"If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If open fails, it returns command not found or impossible to mount if device is not present.","title":"Step 2 : Check if the binary is on the device."},{"location":"orix8bits/informations/binary_starts/#step-3-binary-on-device-is-found","text":"Kernel opens the file, reads the header, and load contains of the binary on the right address. When it's OK, the binary is started (and a fork occurs.)","title":"Step 3 : binary on device is found"},{"location":"orix8bits/informations/buildman/","text":"Build manual pages man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Build manual pages"},{"location":"orix8bits/informations/buildman/#build-manual-pages","text":"man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Build manual pages"},{"location":"orix8bits/informations/buildrom/","text":"Build a rom If you want to build an orix compatible rom, you need to use a special format. You can download rom template here : https://github.com/orix-software/empty-rom/","title":"Build a rom"},{"location":"orix8bits/informations/buildrom/#build-a-rom","text":"If you want to build an orix compatible rom, you need to use a special format. You can download rom template here : https://github.com/orix-software/empty-rom/","title":"Build a rom"},{"location":"orix8bits/informations/cc65/","text":"Use of cc65 cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary","title":"Use of cc65"},{"location":"orix8bits/informations/cc65/#use-of-cc65","text":"cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary","title":"Use of cc65"},{"location":"orix8bits/informations/firmware/","text":"Firmwares available You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables : Firmware 1 Firmware 2 Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank Firmware 3 It's under development but it will handles others hardware chips.","title":"Firmwares available"},{"location":"orix8bits/informations/firmware/#firmwares-available","text":"You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables :","title":"Firmwares available"},{"location":"orix8bits/informations/firmware/#firmware-1","text":"","title":"Firmware 1"},{"location":"orix8bits/informations/firmware/#firmware-2","text":"Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank","title":"Firmware 2"},{"location":"orix8bits/informations/firmware/#firmware-3","text":"It's under development but it will handles others hardware chips.","title":"Firmware 3"},{"location":"orix8bits/informations/header/","text":"Header Introduction Orix binary is not a relocated format. The binary must be never under $800. In the future, a relocated binary format could be used You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly *=$1000-20 ; include header .byt $01,$00 ; non-C64 marker like o65 format .byt \"o\", \"r\", \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header cpu_mode .byt $00 ; CPU see below for description os_type ; 0 : Orix ; 1 : Sedoric ; 2 : Stratsed ; 3 : FTDOS .byt $00 ; .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; operating system id for telemon $00 means telemon 3.0 version .byt $00 ; reserved .byt $00 ; reserved type_of_file ; bit 0 : basic ; bit 1 : machine langage .byt %00000000 ; .byt <start_adress,>start_adress ; loading adress .byt <endofmemory,>EndOfMemory ; end of loading adress .byt <start_adress,>start_adress ; starting adress start_adress: *=$1000 lda #$41 sta $bb80 rts EndOfMemory Description cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell) .byt %00000011 ; (bit 1 = 1 et bit0 =1) language_type On Telestrat (and Stratsed), Hyperbasic starts. When we load from Hyperbasic roms, roms contains routine to load hyperbasic file. This header adds a byte in order to start in the future the right program. %00000000 : Orix file %00000001 : Hyperbasic file, start hyperbasic interpreter %00000010 : Teleass file, start teleass interpreter %00000011 : Teleforth file, start teleforth interpreter other value will be used for others OS (sedoric, ftdos, xldos) type_of_file It used to keep compatibility with stratsed, ftdos, sedoric : Stratsed and sedoric keep in their header information the type of file. This trick is done because if we implement cp from stratsed disk to sdcard, we will lost this information. That is why these byte is reserved to this.","title":"Header"},{"location":"orix8bits/informations/header/#header","text":"","title":"Header"},{"location":"orix8bits/informations/header/#introduction","text":"Orix binary is not a relocated format. The binary must be never under $800. In the future, a relocated binary format could be used You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly *=$1000-20 ; include header .byt $01,$00 ; non-C64 marker like o65 format .byt \"o\", \"r\", \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header cpu_mode .byt $00 ; CPU see below for description os_type ; 0 : Orix ; 1 : Sedoric ; 2 : Stratsed ; 3 : FTDOS .byt $00 ; .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; operating system id for telemon $00 means telemon 3.0 version .byt $00 ; reserved .byt $00 ; reserved type_of_file ; bit 0 : basic ; bit 1 : machine langage .byt %00000000 ; .byt <start_adress,>start_adress ; loading adress .byt <endofmemory,>EndOfMemory ; end of loading adress .byt <start_adress,>start_adress ; starting adress start_adress: *=$1000 lda #$41 sta $bb80 rts EndOfMemory","title":"Introduction"},{"location":"orix8bits/informations/header/#description","text":"cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell) .byt %00000011 ; (bit 1 = 1 et bit0 =1) language_type On Telestrat (and Stratsed), Hyperbasic starts. When we load from Hyperbasic roms, roms contains routine to load hyperbasic file. This header adds a byte in order to start in the future the right program. %00000000 : Orix file %00000001 : Hyperbasic file, start hyperbasic interpreter %00000010 : Teleass file, start teleass interpreter %00000011 : Teleforth file, start teleforth interpreter other value will be used for others OS (sedoric, ftdos, xldos) type_of_file It used to keep compatibility with stratsed, ftdos, sedoric : Stratsed and sedoric keep in their header information the type of file. This trick is done because if we implement cp from stratsed disk to sdcard, we will lost this information. That is why these byte is reserved to this.","title":"Description"},{"location":"orix8bits/informations/joysticks/","text":"Joysticks development Joystick supports is done in telestrat target, it means that you just need to call standard joystick drivers in cc65. Twilighte board is emulated but emulation joystick is not done in atmos + twilighte board configuration, it only works with oricutron telestrat mode.","title":"Joysticks development"},{"location":"orix8bits/informations/joysticks/#joysticks-development","text":"Joystick supports is done in telestrat target, it means that you just need to call standard joystick drivers in cc65. Twilighte board is emulated but emulation joystick is not done in atmos + twilighte board configuration, it only works with oricutron telestrat mode.","title":"Joysticks development"},{"location":"orix8bits/informations/memory/","text":"Memory management Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. But theses primitives only returns pointer from main memory. For instance, extra memory can be accessed without kernel primitive with simple code Banking management The banking management is a bit special, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility $342 : twilighte board register Bit 5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $321 register for the id of the bank to switch b0,b1, b2 which can select the id of the bank wanted. $343 : twilighte board banking register It selects bank set ($343). When you start Orix you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown. For others banks (4,3,2,1), you have bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM You should not use this code, because it's not necessary to use theses routines (Kernel provides routines, or facility to call binaries in banks) If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda #$04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda #$01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli","title":"Memory management"},{"location":"orix8bits/informations/memory/#memory-management","text":"Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. But theses primitives only returns pointer from main memory. For instance, extra memory can be accessed without kernel primitive with simple code","title":"Memory management"},{"location":"orix8bits/informations/memory/#banking-management","text":"The banking management is a bit special, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility","title":"Banking management"},{"location":"orix8bits/informations/memory/#342-twilighte-board-register","text":"Bit 5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"orix8bits/informations/memory/#321-register-for-the-id-of-the-bank-to-switch","text":"b0,b1, b2 which can select the id of the bank wanted.","title":"$321 register for the id of the bank to switch"},{"location":"orix8bits/informations/memory/#343-twilighte-board-banking-register","text":"It selects bank set ($343). When you start Orix you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown. For others banks (4,3,2,1), you have bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM You should not use this code, because it's not necessary to use theses routines (Kernel provides routines, or facility to call binaries in banks) If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda #$04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda #$01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli","title":"$343 : twilighte board banking register"},{"location":"orix8bits/informations/orixsdk/","text":"Orix SDK It provides macro to help assembly coding for Orix. Load it you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"macros/SDK.mac\" Malloc ;---------------------------------------------------------------------- ; ; usage: ; malloc size [,ptr] [,oom_msg_ptr] [,fail_value] ; ; malloc #$0100 ; malloc (ptr) ; malloc value ; ; Note: ; - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AY is null (ie malloc error) ; ; Call XMALLOC function ; ;---------------------------------------------------------------------- ```ca65 Mfree (free pointer) ;---------------------------------------------------------------------- ; ; usage: ; mfree (ptr) ; ; Call XFREE function ;---------------------------------------------------------------------- ```ca65","title":"Orix SDK"},{"location":"orix8bits/informations/orixsdk/#orix-sdk","text":"It provides macro to help assembly coding for Orix.","title":"Orix SDK"},{"location":"orix8bits/informations/orixsdk/#load-it","text":"you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"macros/SDK.mac\"","title":"Load it"},{"location":"orix8bits/informations/orixsdk/#malloc","text":";---------------------------------------------------------------------- ; ; usage: ; malloc size [,ptr] [,oom_msg_ptr] [,fail_value] ; ; malloc #$0100 ; malloc (ptr) ; malloc value ; ; Note: ; - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AY is null (ie malloc error) ; ; Call XMALLOC function ; ;---------------------------------------------------------------------- ```ca65","title":"Malloc"},{"location":"orix8bits/informations/orixsdk/#mfree-free-pointer","text":";---------------------------------------------------------------------- ; ; usage: ; mfree (ptr) ; ; Call XFREE function ;---------------------------------------------------------------------- ```ca65","title":"Mfree (free pointer)"},{"location":"orix8bits/informations/pizero_connection/","text":"Pi zero connection You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Pi zero connection"},{"location":"orix8bits/informations/pizero_connection/#pi-zero-connection","text":"You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Pi zero connection"},{"location":"orix8bits/primitives/","text":"Summary Args from commandline XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct Numbers XBINDX : convert a number to decimal Memory XMALLOC XFREE Files XOPEN : Open a file","title":"Summary"},{"location":"orix8bits/primitives/#summary","text":"","title":"Summary"},{"location":"orix8bits/primitives/#args-from-commandline","text":"XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct","title":"Args from commandline"},{"location":"orix8bits/primitives/#numbers","text":"XBINDX : convert a number to decimal","title":"Numbers"},{"location":"orix8bits/primitives/#memory","text":"XMALLOC XFREE","title":"Memory"},{"location":"orix8bits/primitives/#files","text":"XOPEN : Open a file","title":"Files"},{"location":"orix8bits/primitives/xbindx/","text":"XBINDX Description convert A & Y number into decimal Input A & Y the 16 bits values TR5 the pointer of the address to put decimal number DEFAFF : space before the number X : xxx Output A & TR5 Example lda #<$bb80 sta TR5 lda #>$bb80 sta TR5+1 lda #$20 sta DEFAFF ldx #$01 ldy #$00 lda #$10 BRK_KERNEL XBINX","title":"XBINDX"},{"location":"orix8bits/primitives/xbindx/#xbindx","text":"","title":"XBINDX"},{"location":"orix8bits/primitives/xbindx/#description","text":"convert A & Y number into decimal","title":"Description"},{"location":"orix8bits/primitives/xbindx/#input","text":"A & Y the 16 bits values TR5 the pointer of the address to put decimal number DEFAFF : space before the number X : xxx","title":"Input"},{"location":"orix8bits/primitives/xbindx/#output","text":"A & TR5","title":"Output"},{"location":"orix8bits/primitives/xbindx/#example","text":"lda #<$bb80 sta TR5 lda #>$bb80 sta TR5+1 lda #$20 sta DEFAFF ldx #$01 ldy #$00 lda #$10 BRK_KERNEL XBINX","title":"Example"},{"location":"orix8bits/primitives/xgetargv/","text":"XGETARGV Description Get argv. X register contains the number of the arg search Input A & Y the ptr of struct from XMAINARGS X the number of arg to get Output A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed Example XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr+1 ldx #$02 ; get arg 2 lda debug_mainargs_ptr ldy debug_mainargs_ptr+1 BRK_KERNEL XGETARGV","title":"XGETARGV"},{"location":"orix8bits/primitives/xgetargv/#xgetargv","text":"","title":"XGETARGV"},{"location":"orix8bits/primitives/xgetargv/#description","text":"Get argv. X register contains the number of the arg search","title":"Description"},{"location":"orix8bits/primitives/xgetargv/#input","text":"A & Y the ptr of struct from XMAINARGS X the number of arg to get","title":"Input"},{"location":"orix8bits/primitives/xgetargv/#output","text":"A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed","title":"Output"},{"location":"orix8bits/primitives/xgetargv/#example","text":"XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr+1 ldx #$02 ; get arg 2 lda debug_mainargs_ptr ldy debug_mainargs_ptr+1 BRK_KERNEL XGETARGV","title":"Example"},{"location":"orix8bits/primitives/xmainargs/","text":"XMAINARGS ID primitive : $2C Description Return argc and argv Input Nothing Output A & Y contains ptr to XMAINARGS Struct X: number of args Usage XMAINARGS = $2C brk_kernel XMAINARGS stx save_argc sta save_argvlow sty save_argvhigh","title":"XMAINARGS"},{"location":"orix8bits/primitives/xmainargs/#xmainargs","text":"ID primitive : $2C","title":"XMAINARGS"},{"location":"orix8bits/primitives/xmainargs/#description","text":"Return argc and argv","title":"Description"},{"location":"orix8bits/primitives/xmainargs/#input","text":"Nothing","title":"Input"},{"location":"orix8bits/primitives/xmainargs/#output","text":"A & Y contains ptr to XMAINARGS Struct X: number of args","title":"Output"},{"location":"orix8bits/primitives/xmainargs/#usage","text":"XMAINARGS = $2C brk_kernel XMAINARGS stx save_argc sta save_argvlow sty save_argvhigh","title":"Usage"},{"location":"orix8bits/primitives/xmkdir/","text":"XMKDIR ID primitive : $4B Description Create a folder. But it does not support absolute path for instance. It can only create path in the current path. Input A and Y : ptr of the string Output Return #ENODEV if the device can't be mount Usage lda #<str ldy #>str BRK_TELEMON XMKDIR rts str: .asciiz \"myfolder\"","title":"XMKDIR"},{"location":"orix8bits/primitives/xmkdir/#xmkdir","text":"ID primitive : $4B","title":"XMKDIR"},{"location":"orix8bits/primitives/xmkdir/#description","text":"Create a folder. But it does not support absolute path for instance. It can only create path in the current path.","title":"Description"},{"location":"orix8bits/primitives/xmkdir/#input","text":"A and Y : ptr of the string","title":"Input"},{"location":"orix8bits/primitives/xmkdir/#output","text":"Return #ENODEV if the device can't be mount","title":"Output"},{"location":"orix8bits/primitives/xmkdir/#usage","text":"lda #<str ldy #>str BRK_TELEMON XMKDIR rts str: .asciiz \"myfolder\"","title":"Usage"},{"location":"orix8bits/samples_asm/","text":"Samples in Assembly Malloc Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 := userzp malloc 4000,myptr3,str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Samples in Assembly"},{"location":"orix8bits/samples_asm/#samples-in-assembly","text":"","title":"Samples in Assembly"},{"location":"orix8bits/samples_asm/#malloc","text":"Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 := userzp malloc 4000,myptr3,str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Malloc"},{"location":"orix8bits/samples_c/","text":"Open and read files with cc65 #include <stdio.h> unsigned char chars[255]; main (){ fp=fopen(\"/myfile\",\"r\"); if (fp==NULL) { printf(\"Can't open %s\\n\",argv[1]); return (1); } nb=fread(chars,255,1,fp); fclose(fp); }","title":"Open and read files with cc65"},{"location":"orix8bits/samples_c/#open-and-read-files-with-cc65","text":"#include <stdio.h> unsigned char chars[255]; main (){ fp=fopen(\"/myfile\",\"r\"); if (fp==NULL) { printf(\"Can't open %s\\n\",argv[1]); return (1); } nb=fread(chars,255,1,fp); fclose(fp); }","title":"Open and read files with cc65"},{"location":"orix8bits/samples_c/getcwd/","text":"Get CWD in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD=$48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd(); int main() { printf(\"Cwd : %s\",ogetcwd()); return 0; }","title":"Get CWD in cc65"},{"location":"orix8bits/samples_c/getcwd/#get-cwd-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD=$48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd(); int main() { printf(\"Cwd : %s\",ogetcwd()); return 0; }","title":"Get CWD in cc65"},{"location":"orix8bits/samples_c/mkdir/","text":"Create a folder with cc65 For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir(unsigned char *path); int main() { mkdir (\"myfolder\"); return 0; }","title":"Create a folder with cc65"},{"location":"orix8bits/samples_c/mkdir/#create-a-folder-with-cc65","text":"For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir(unsigned char *path); int main() { mkdir (\"myfolder\"); return 0; }","title":"Create a folder with cc65"},{"location":"orix8bits/samples_c/putcwd/","text":"chdir in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD=$49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd(); int main() { oputcwd(\"/etc\"); return 0; }","title":"chdir in cc65"},{"location":"orix8bits/samples_c/putcwd/#chdir-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD=$49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd(); int main() { oputcwd(\"/etc\"); return 0; }","title":"chdir in cc65"},{"location":"orix8bits/tools/mount/","text":"Mount (not developed yet) FP Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null. When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action : X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE ls case ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel cp/mv case don't know","title":"Mount (not developed yet)"},{"location":"orix8bits/tools/mount/#mount-not-developed-yet","text":"","title":"Mount (not developed yet)"},{"location":"orix8bits/tools/mount/#fp","text":"Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null.","title":"FP"},{"location":"orix8bits/tools/mount/#when-a-freadfwrite-is-done-if-extbank-is-different-to-0-then-kernel-will-launch-external-vector-with-a-and-y-contains-the-string-of-the-path-and-x-contains-the-action","text":"X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE","title":"When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action :"},{"location":"orix8bits/tools/mount/#ls-case","text":"ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel","title":"ls case"},{"location":"orix8bits/tools/mount/#cpmv-case","text":"don't know","title":"cp/mv case"},{"location":"orix8bits/tools/basic11/","text":"Fonctionnement Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance Si on tape : /#basic11 Cela lance la ROM Si on tape : /#basic11 \"TAPEFILE\" Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom. Si on tape : /#basic11 -l Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici Fonctionnement global Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1 Format du fichier \"maindb\" (basic11.db) Version 1 1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture) Format du fichier .db d'un soft version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Fonctionnement"},{"location":"orix8bits/tools/basic11/#fonctionnement","text":"Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance","title":"Fonctionnement"},{"location":"orix8bits/tools/basic11/#si-on-tape-basic11","text":"Cela lance la ROM","title":"Si on tape : /#basic11"},{"location":"orix8bits/tools/basic11/#si-on-tape-basic11-tapefile","text":"Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom.","title":"Si on tape : /#basic11 \"TAPEFILE\""},{"location":"orix8bits/tools/basic11/#si-on-tape-basic11-l","text":"Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici","title":"Si on tape : /#basic11 -l"},{"location":"orix8bits/tools/basic11/#fonctionnement-global","text":"Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1","title":"Fonctionnement global"},{"location":"orix8bits/tools/basic11/#format-du-fichier-maindb-basic11db","text":"","title":"Format du fichier \"maindb\" (basic11.db)"},{"location":"orix8bits/tools/basic11/#version-1","text":"1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture)","title":"Version 1"},{"location":"orix8bits/tools/basic11/#format-du-fichier-db-dun-soft","text":"version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Format du fichier .db d'un soft"},{"location":"stratos/","text":"Stratos Specs G\u00e9n\u00e9rales 15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier Fonctionnement atmos compatible La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ? Cas non g\u00e9r\u00e9s WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC Controleur usb, sdcard, clavier, souris Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi) Port ethernet ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ... EEprom kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg Kernel Orix 16bits appels via jsr avec un param\u00e8tre de primitive ?","title":"Stratos"},{"location":"stratos/#stratos","text":"","title":"Stratos"},{"location":"stratos/#specs-generales","text":"15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier","title":"Specs G\u00e9n\u00e9rales"},{"location":"stratos/#fonctionnement-atmos-compatible","text":"La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ?","title":"Fonctionnement atmos compatible"},{"location":"stratos/#cas-non-geres","text":"WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC","title":"Cas non g\u00e9r\u00e9s"},{"location":"stratos/#controleur-usb-sdcard-clavier-souris","text":"Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi)","title":"Controleur usb, sdcard, clavier, souris"},{"location":"stratos/#port-ethernet","text":"ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ...","title":"Port ethernet"},{"location":"stratos/#eeprom","text":"kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg","title":"EEprom"},{"location":"stratos/#kernel-orix-16bits","text":"appels via jsr avec un param\u00e8tre de primitive ?","title":"Kernel Orix 16bits"},{"location":"twilighteboard/","text":"Twilighte board FDC, RTC WIFI controller firmware version 1 $342 : twilighte board register b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $343 : Banking register Working board version with this firmware: v0.6 v0.65 firmware version 2 Reserved for twilighte board v0.6 & v0.65 upgrades firmware version 3 $342 b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ... $343 Banking register Notes Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version Twilighte board version 0.6 dirty hack for ca3083 replacement Twilighte board version 0.65 ca3083 removed and are replaced with BC547 Twilighte board version 0.7 Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board"},{"location":"twilighteboard/#twilighte-board","text":"FDC, RTC WIFI controller","title":"Twilighte board"},{"location":"twilighteboard/#firmware-version-1","text":"","title":"firmware version 1"},{"location":"twilighteboard/#342-twilighte-board-register","text":"b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"twilighteboard/#343-banking-register","text":"Working board version with this firmware: v0.6 v0.65","title":"$343 : Banking register"},{"location":"twilighteboard/#firmware-version-2","text":"Reserved for twilighte board v0.6 & v0.65 upgrades","title":"firmware version 2"},{"location":"twilighteboard/#firmware-version-3","text":"","title":"firmware version 3"},{"location":"twilighteboard/#342","text":"b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ...","title":"$342"},{"location":"twilighteboard/#343","text":"Banking register","title":"$343"},{"location":"twilighteboard/#notes","text":"Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version","title":"Notes"},{"location":"twilighteboard/#twilighte-board-version-06","text":"dirty hack for ca3083 replacement","title":"Twilighte board version 0.6"},{"location":"twilighteboard/#twilighte-board-version-065","text":"ca3083 removed and are replaced with BC547","title":"Twilighte board version 0.65"},{"location":"twilighteboard/#twilighte-board-version-07","text":"Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board version 0.7"},{"location":"twilighteboard/fdcWifiEsp/","text":"fdcsd I/O : * $315 : command port * $316 : data port ESP32_CHECK_EXIST ESP32_CHECK_EXIST = $06 Return data inverted bit ESP32_GET_IC_VER ESP32_GET_IC_VER = $01 Return version ESP32_SET_MODE CH376_SET_MODE = $15 Set mode ESP32_SET_MODE_CODE_FDC ESP32_LAUNCH_WIFI_SCAN $02 interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#fdcsd","text":"I/O : * $315 : command port * $316 : data port","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#esp32_check_exist","text":"ESP32_CHECK_EXIST = $06 Return data inverted bit","title":"ESP32_CHECK_EXIST"},{"location":"twilighteboard/fdcWifiEsp/#esp32_get_ic_ver","text":"ESP32_GET_IC_VER = $01 Return version","title":"ESP32_GET_IC_VER"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode","text":"CH376_SET_MODE = $15 Set mode","title":"ESP32_SET_MODE"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode_code_fdc","text":"","title":"ESP32_SET_MODE_CODE_FDC"},{"location":"twilighteboard/fdcWifiEsp/#esp32_launch_wifi_scan-02","text":"interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"ESP32_LAUNCH_WIFI_SCAN $02"}]}