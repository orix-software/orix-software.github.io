{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Definitions Twilighte board The Twilighte board is an extra hardware connected on the the oric (Atmos or Oric-1), it improves default Oric with hardware feature as eeprom (in system update), RAM, joysticks, usb controler. It handles 32 Banks of 16KB of eeprom and 32 Banks of 16KB for RAM. Orix Orix is the default (D)OS of the board when it plugged into the oric. Orix is a linux/unix style OS. It's the main OS which can help to start every others systems as oric-1 ROM, atmos ROM etc Orix must have at least 2 banks to boot : Kernel and shell. Kernel is a bank inserted in the 7th slot and it's the first start to boot. Shell is the 5th bank and contains sh binary. When system starts, kernel forks \"sh\" commands at the end of the kernel initialisation. Shell is available and can starts any commands. There is 2 kind of rom : Standalone ROM : it does not need to call kernel primitive, and manage all the main memory (for example : atmos ROM) Orix Roms : in that case, rom does not manage the main memory, and calls kernel to do tasks (for example : Shell roms). In Orix roms, the rom declares commands to an offset in the bank and can be accessed from command line. If any command are typed from prompt, kernel will launch \"XEXEC\" primitive to find in any rom where the command is.","title":"Home"},{"location":"#definitions","text":"","title":"Definitions"},{"location":"#twilighte-board","text":"The Twilighte board is an extra hardware connected on the the oric (Atmos or Oric-1), it improves default Oric with hardware feature as eeprom (in system update), RAM, joysticks, usb controler. It handles 32 Banks of 16KB of eeprom and 32 Banks of 16KB for RAM.","title":"Twilighte board"},{"location":"#orix","text":"Orix is the default (D)OS of the board when it plugged into the oric. Orix is a linux/unix style OS. It's the main OS which can help to start every others systems as oric-1 ROM, atmos ROM etc Orix must have at least 2 banks to boot : Kernel and shell. Kernel is a bank inserted in the 7th slot and it's the first start to boot. Shell is the 5th bank and contains sh binary. When system starts, kernel forks \"sh\" commands at the end of the kernel initialisation. Shell is available and can starts any commands. There is 2 kind of rom : Standalone ROM : it does not need to call kernel primitive, and manage all the main memory (for example : atmos ROM) Orix Roms : in that case, rom does not manage the main memory, and calls kernel to do tasks (for example : Shell roms). In Orix roms, the rom declares commands to an offset in the bank and can be accessed from command line. If any command are typed from prompt, kernel will launch \"XEXEC\" primitive to find in any rom where the command is.","title":"Orix"},{"location":"hardware/i_o/","text":"I/O","title":"I/O"},{"location":"hardware/i_o/#io","text":"","title":"I/O"},{"location":"home/","text":"Install envs for developpers Step 1 : Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board=yes plugins/twilighte_board/twilighte.cfg you can put any rom you want. Step 2 : get main rom (kernel and shell) Step 3 : start oricutron Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip Step 4 : Download/build cc65 Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder) Step 5 : Download SDK (mainly for assembly) Clone https://github.com/assinie/orix-sdk in your project folder","title":"Installation"},{"location":"home/#install-envs-for-developpers","text":"","title":"Install envs for developpers"},{"location":"home/#step-1-configure-and-start-oricutron-with-twilighte-board","text":"Build from source code oricutron : https://github.com/pete-gordon/oricutron In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board=yes plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Step 1 : Configure and start oricutron with twilighte board"},{"location":"home/#step-2-get-main-rom-kernel-and-shell","text":"","title":"Step 2 : get main rom (kernel and shell)"},{"location":"home/#step-3-start-oricutron","text":"Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip","title":"Step 3 : start oricutron"},{"location":"home/#step-4-downloadbuild-cc65","text":"Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder)","title":"Step 4 : Download/build cc65"},{"location":"home/#step-5-download-sdk-mainly-for-assembly","text":"Clone https://github.com/assinie/orix-sdk in your project folder","title":"Step 5 : Download SDK  (mainly for assembly)"},{"location":"home/buildman/","text":"Manual pages man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Manual pages"},{"location":"home/buildman/#manual-pages","text":"man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Manual pages"},{"location":"home/buildrom/","text":"Bank Structure If you want to build an orix compatible rom, you need to use a special format. You can download rom template here : https://github.com/orix-software/empty-rom/ Rom definition $fff0 : 1 byte, rom type (Value 0 : empty bank, value 1 : command bank)","title":"Bank Structure"},{"location":"home/buildrom/#bank-structure","text":"If you want to build an orix compatible rom, you need to use a special format. You can download rom template here : https://github.com/orix-software/empty-rom/ Rom definition $fff0 : 1 byte, rom type (Value 0 : empty bank, value 1 : command bank)","title":"Bank Structure"},{"location":"home/cc65/","text":"Cc65 use cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary.","title":"Cc65 use"},{"location":"home/cc65/#cc65-use","text":"cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary.","title":"Cc65 use"},{"location":"home/firmware/","text":"Firmwares You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables : Firmware 1 Firmware 2 Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank Firmware 3 It's under development but it will handles others hardware chips.","title":"Firmwares"},{"location":"home/firmware/#firmwares","text":"You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables :","title":"Firmwares"},{"location":"home/firmware/#firmware-1","text":"","title":"Firmware 1"},{"location":"home/firmware/#firmware-2","text":"Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank","title":"Firmware 2"},{"location":"home/firmware/#firmware-3","text":"It's under development but it will handles others hardware chips.","title":"Firmware 3"},{"location":"home/hardware/","text":"Hardware Twilighte Board .","title":"Hardware"},{"location":"home/hardware/#hardware","text":"Twilighte Board .","title":"Hardware"},{"location":"home/header/","text":"Header Orix binary v1 format (not relocated) Orix binary v1 is not a relocated format. The binary must be never under $800. In the future, a relocated binary format could be used You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly .byt $01,$00 ; non-C64 marker like o65 format .byt \"o\", \"r\", \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt <start_adress,>start_adress ; loading adress .byt <endofmemory,>EndOfMemory ; end of loading adress .byt <start_adress,>start_adress ; starting adress start_adress: *=$1000 lda #$41 sta $bb80 rts EndOfMemory: Orix binary v3 format (relocated by bitfield) .byt $01,$00 ; non-C64 marker like o65 format .byt \"o\", \"r\", \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description ;7 .byt $00 ; size of the bitfield map low .byt $00 ; size of the bitfield map high ;9 .byt $00 ; reserved ;10 .byt $00 ; reserved ;11 .byt $00 ; reserved ;12 .byt $00 ; reserved ;13 .byt $00 ; reserved ;14 .byt <start_adress,>start_adress ; loading adress ;16 .byt <endofmemory,>EndOfMemory ; end of loading adress ; 18 .byt $00 ; Offset of the bitfield map in the file low .byt $00 ; Offset of the bitfield map in the file high ; end of header start_adress: lda $00 rts EndOfMemory: Description cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell)","title":"Header"},{"location":"home/header/#header","text":"","title":"Header"},{"location":"home/header/#orix-binary-v1-format-not-relocated","text":"Orix binary v1 is not a relocated format. The binary must be never under $800. In the future, a relocated binary format could be used You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly .byt $01,$00 ; non-C64 marker like o65 format .byt \"o\", \"r\", \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt <start_adress,>start_adress ; loading adress .byt <endofmemory,>EndOfMemory ; end of loading adress .byt <start_adress,>start_adress ; starting adress start_adress: *=$1000 lda #$41 sta $bb80 rts EndOfMemory:","title":"Orix binary v1 format (not relocated)"},{"location":"home/header/#orix-binary-v3-format-relocated-by-bitfield","text":".byt $01,$00 ; non-C64 marker like o65 format .byt \"o\", \"r\", \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description ;7 .byt $00 ; size of the bitfield map low .byt $00 ; size of the bitfield map high ;9 .byt $00 ; reserved ;10 .byt $00 ; reserved ;11 .byt $00 ; reserved ;12 .byt $00 ; reserved ;13 .byt $00 ; reserved ;14 .byt <start_adress,>start_adress ; loading adress ;16 .byt <endofmemory,>EndOfMemory ; end of loading adress ; 18 .byt $00 ; Offset of the bitfield map in the file low .byt $00 ; Offset of the bitfield map in the file high ; end of header start_adress: lda $00 rts EndOfMemory:","title":"Orix binary v3 format (relocated by bitfield)"},{"location":"home/header/#description","text":"cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell)","title":"Description"},{"location":"home/joysticks/","text":"Joysticks management Joystick supports is done in telestrat target, it means that you just need to call standard joystick drivers in cc65. Twilighte board is emulated but emulation joystick is not done in atmos + twilighte board configuration, it only works with oricutron telestrat mode.","title":"Joysticks management"},{"location":"home/joysticks/#joysticks-management","text":"Joystick supports is done in telestrat target, it means that you just need to call standard joystick drivers in cc65. Twilighte board is emulated but emulation joystick is not done in atmos + twilighte board configuration, it only works with oricutron telestrat mode.","title":"Joysticks management"},{"location":"home/kernel/","text":"Kernel Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orix SDK manages some kernel calls, and it's better to use macro set to call some primitives Kernel doc for developpers Orix 8 bits - Kernel","title":"Kernel"},{"location":"home/kernel/#kernel","text":"Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orix SDK manages some kernel calls, and it's better to use macro set to call some primitives","title":"Kernel"},{"location":"home/kernel/#kernel-doc-for-developpers","text":"Orix 8 bits - Kernel","title":"Kernel doc for developpers"},{"location":"home/memory/","text":"Memory management Orix Roms Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. But theses primitives only returns pointer from main memory. Standalone ROM Extra memory can be accessed without kernel primitive with simple code Banking management The banking management is a bit special, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility $342 : twilighte board register Bit 5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $321 register for the id of the bank to switch b0,b1, b2 which can select the id of the bank wanted. $343 : twilighte board banking register It selects bank set ($343). When you start Orix you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown. For others banks (4,3,2,1), you have bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM You should not use this code, because it's not necessary to use theses routines (Kernel provides routines, or facility to call binaries in banks) If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda #$04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda #$01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli","title":"Memory management"},{"location":"home/memory/#memory-management","text":"","title":"Memory management"},{"location":"home/memory/#orix-roms","text":"Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. But theses primitives only returns pointer from main memory.","title":"Orix Roms"},{"location":"home/memory/#standalone-rom","text":"Extra memory can be accessed without kernel primitive with simple code","title":"Standalone ROM"},{"location":"home/memory/#banking-management","text":"The banking management is a bit special, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility","title":"Banking management"},{"location":"home/memory/#342-twilighte-board-register","text":"Bit 5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"home/memory/#321-register-for-the-id-of-the-bank-to-switch","text":"b0,b1, b2 which can select the id of the bank wanted.","title":"$321 register for the id of the bank to switch"},{"location":"home/memory/#343-twilighte-board-banking-register","text":"It selects bank set ($343). When you start Orix you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown. For others banks (4,3,2,1), you have bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM You should not use this code, because it's not necessary to use theses routines (Kernel provides routines, or facility to call binaries in banks) If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda #$04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda #$01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli","title":"$343 : twilighte board banking register"},{"location":"home/orixsdk/","text":"Orix SDK It provides macro to help assembly coding for Orix : https://github.com/assinie/orix-sdk/ Load it you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"macros/SDK.mac\" fopen ;---------------------------------------------------------------------- ; ; usage: ; fopen file, mode [,TELEMON] [,ptr] [,oom_msg_ptr] [,fail_value] ; ; note: ; - file may be: (ptr), address ; - if parameter 'ptr' is present, store resulting AX in ptr & ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AX is $FFFF (ie XOPEN error) ; ; Call XOPEN function ;---------------------------------------------------------------------- ex : fopen (basic11_ptr2), O_RDONLY cpx #$FF bne @read_maindb ; not null then start because we did not found a conf cmp #$FF bne @read_maindb ; not null then start because we did not found a conf PRINT str_basic11_missing BRK_KERNEL XCRLF lda #$FF ldx #$FF rts @read_maindb: bla Malloc ;---------------------------------------------------------------------- ; ; usage: ; malloc size [,ptr] [,oom_msg_ptr] [,fail_value] ; ; malloc #$0100 ; malloc (ptr) ; malloc value ; ; Note: ; - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AY is null (ie malloc error) ; ; Call XMALLOC function ; ;---------------------------------------------------------------------- Mfree (free pointer) ;---------------------------------------------------------------------- ; ; usage: ; mfree (ptr) ; ; Call XFREE function ;---------------------------------------------------------------------- strncpy ;---------------------------------------------------------------------- ; strncpy(src, dest, n) ; ; Sortie: ; A: 0 et Z=1 si copie effectu\u00e9e, inchang\u00e9 si non ; X: 0 ; Y: Longueur r\u00e9ellement copi\u00e9e ;----------------------------------------------------------------------","title":"Orix SDK"},{"location":"home/orixsdk/#orix-sdk","text":"It provides macro to help assembly coding for Orix : https://github.com/assinie/orix-sdk/","title":"Orix SDK"},{"location":"home/orixsdk/#load-it","text":"you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"macros/SDK.mac\"","title":"Load it"},{"location":"home/orixsdk/#fopen","text":";---------------------------------------------------------------------- ; ; usage: ; fopen file, mode [,TELEMON] [,ptr] [,oom_msg_ptr] [,fail_value] ; ; note: ; - file may be: (ptr), address ; - if parameter 'ptr' is present, store resulting AX in ptr & ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AX is $FFFF (ie XOPEN error) ; ; Call XOPEN function ;---------------------------------------------------------------------- ex : fopen (basic11_ptr2), O_RDONLY cpx #$FF bne @read_maindb ; not null then start because we did not found a conf cmp #$FF bne @read_maindb ; not null then start because we did not found a conf PRINT str_basic11_missing BRK_KERNEL XCRLF lda #$FF ldx #$FF rts @read_maindb: bla","title":"fopen"},{"location":"home/orixsdk/#malloc","text":";---------------------------------------------------------------------- ; ; usage: ; malloc size [,ptr] [,oom_msg_ptr] [,fail_value] ; ; malloc #$0100 ; malloc (ptr) ; malloc value ; ; Note: ; - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AY is null (ie malloc error) ; ; Call XMALLOC function ; ;----------------------------------------------------------------------","title":"Malloc"},{"location":"home/orixsdk/#mfree-free-pointer","text":";---------------------------------------------------------------------- ; ; usage: ; mfree (ptr) ; ; Call XFREE function ;----------------------------------------------------------------------","title":"Mfree (free pointer)"},{"location":"home/orixsdk/#strncpy","text":";---------------------------------------------------------------------- ; strncpy(src, dest, n) ; ; Sortie: ; A: 0 et Z=1 si copie effectu\u00e9e, inchang\u00e9 si non ; X: 0 ; Y: Longueur r\u00e9ellement copi\u00e9e ;----------------------------------------------------------------------","title":"strncpy"},{"location":"home/pizero_connection/","text":"Pi zero connection You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Pi zero connection"},{"location":"home/pizero_connection/#pi-zero-connection","text":"You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Pi zero connection"},{"location":"home/relocbin/","text":"Relocation format. If you want to generate a relocatable format for orix, follow this link : https://github.com/assinie/orix-sdk/blob/master/README.md","title":"Relocation format."},{"location":"home/relocbin/#relocation-format","text":"If you want to generate a relocatable format for orix, follow this link : https://github.com/assinie/orix-sdk/blob/master/README.md","title":"Relocation format."},{"location":"how-it-work/","text":"basic11 rom Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance Si on tape : /#basic11 Cela lance la ROM Si on tape : /#basic11 \"TAPEFILE\" Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom. Si on tape : /#basic11 -l Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici Fonctionnement global Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1 Format du fichier \"maindb\" (basic11.db) Version 1 1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture) Format du fichier .db d'un soft version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"basic11 rom"},{"location":"how-it-work/#basic11-rom","text":"Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance","title":"basic11 rom"},{"location":"how-it-work/#si-on-tape-basic11","text":"Cela lance la ROM","title":"Si on tape : /#basic11"},{"location":"how-it-work/#si-on-tape-basic11-tapefile","text":"Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom.","title":"Si on tape : /#basic11 \"TAPEFILE\""},{"location":"how-it-work/#si-on-tape-basic11-l","text":"Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici","title":"Si on tape : /#basic11 -l"},{"location":"how-it-work/#fonctionnement-global","text":"Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1","title":"Fonctionnement global"},{"location":"how-it-work/#format-du-fichier-maindb-basic11db","text":"","title":"Format du fichier \"maindb\" (basic11.db)"},{"location":"how-it-work/#version-1","text":"1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture)","title":"Version 1"},{"location":"how-it-work/#format-du-fichier-db-dun-soft","text":"version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Format du fichier .db d'un soft"},{"location":"how-it-work/binary_starts/","text":"Binary start sequence All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls XEXEC kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD Step 1 : check if binary in a bank Xexec reads all banks from 4 to 1 and tries to check if the program is in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks) That is why commands located in bank are quicker to start Step 2 : Check if the binary is on the device If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If open fails, it returns \"command not found\" or impossible to mount if device is not present. Step 3 : binary on device is found Kernel opens the file, reads the header, and loads the content of the binary on the right address. When it's OK, the binary is started (and a fork occurs.)","title":"Binary start sequence"},{"location":"how-it-work/binary_starts/#binary-start-sequence","text":"All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls XEXEC kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD","title":"Binary start sequence"},{"location":"how-it-work/binary_starts/#step-1-check-if-binary-in-a-bank","text":"Xexec reads all banks from 4 to 1 and tries to check if the program is in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks) That is why commands located in bank are quicker to start","title":"Step 1 : check if binary in a bank"},{"location":"how-it-work/binary_starts/#step-2-check-if-the-binary-is-on-the-device","text":"If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If open fails, it returns \"command not found\" or impossible to mount if device is not present.","title":"Step 2 : Check if the binary is on the device"},{"location":"how-it-work/binary_starts/#step-3-binary-on-device-is-found","text":"Kernel opens the file, reads the header, and loads the content of the binary on the right address. When it's OK, the binary is started (and a fork occurs.)","title":"Step 3 : binary on device is found"},{"location":"libs/twillib/","text":"Twil libs Manage rom/ram banks unsigned char twil_program_rambank(unsigned char bank, char *file, unsigned char set); unsigned char twil_clear_rambank(unsigned char bank, unsigned char set); unsigned char twil_lib_version(void);","title":"Twil libs"},{"location":"libs/twillib/#twil-libs","text":"Manage rom/ram banks unsigned char twil_program_rambank(unsigned char bank, char *file, unsigned char set); unsigned char twil_clear_rambank(unsigned char bank, unsigned char set); unsigned char twil_lib_version(void);","title":"Twil libs"},{"location":"samples/asm_samples/","text":"Samples in Assembly Malloc Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 := userzp malloc 4000,myptr3,str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Samples in Assembly"},{"location":"samples/asm_samples/#samples-in-assembly","text":"","title":"Samples in Assembly"},{"location":"samples/asm_samples/#malloc","text":"Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 := userzp malloc 4000,myptr3,str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Malloc"},{"location":"samples/c_samples/","text":"Open and read files with cc65 #include <stdio.h> unsigned char chars[255]; main (){ fp=fopen(\"/myfile\",\"r\"); if (fp==NULL) { printf(\"Can't open %s\\n\",argv[1]); return (1); } nb=fread(chars,255,1,fp); fclose(fp); }","title":"Open and read files with cc65"},{"location":"samples/c_samples/#open-and-read-files-with-cc65","text":"#include <stdio.h> unsigned char chars[255]; main (){ fp=fopen(\"/myfile\",\"r\"); if (fp==NULL) { printf(\"Can't open %s\\n\",argv[1]); return (1); } nb=fread(chars,255,1,fp); fclose(fp); }","title":"Open and read files with cc65"},{"location":"samples/c_samples/getcwd/","text":"Get CWD in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD=$48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd(); int main() { printf(\"Cwd : %s\",ogetcwd()); return 0; }","title":"Get CWD in cc65"},{"location":"samples/c_samples/getcwd/#get-cwd-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD=$48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd(); int main() { printf(\"Cwd : %s\",ogetcwd()); return 0; }","title":"Get CWD in cc65"},{"location":"samples/c_samples/mkdir/","text":"Create a folder with cc65 For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir(unsigned char *path); int main() { mkdir (\"myfolder\"); return 0; }","title":"Create a folder with cc65"},{"location":"samples/c_samples/mkdir/#create-a-folder-with-cc65","text":"For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir(unsigned char *path); int main() { mkdir (\"myfolder\"); return 0; }","title":"Create a folder with cc65"},{"location":"samples/c_samples/putcwd/","text":"chdir in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD=$49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd(); int main() { oputcwd(\"/etc\"); return 0; }","title":"chdir in cc65"},{"location":"samples/c_samples/putcwd/#chdir-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD=$49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd(); int main() { oputcwd(\"/etc\"); return 0; }","title":"chdir in cc65"},{"location":"samples/c_samples/writefile/","text":"Write a file #include <stdio.h> static unsigned char buffer[4000]; int main() { FILE* fp; unsigned int nb_write; static unsigned char destfilename[9]=\"myfile.txt\"; fp = fopen(destfilename, \"wb\"); if (!fp) { printf(\"Can't create output file\\n\"); return 1; } nb_write=fwrite(buffer, 1, 4000, fp); fclose(fp); }","title":"Write a file"},{"location":"samples/c_samples/writefile/#write-a-file","text":"#include <stdio.h> static unsigned char buffer[4000]; int main() { FILE* fp; unsigned int nb_write; static unsigned char destfilename[9]=\"myfile.txt\"; fp = fopen(destfilename, \"wb\"); if (!fp) { printf(\"Can't create output file\\n\"); return 1; } nb_write=fwrite(buffer, 1, 4000, fp); fclose(fp); }","title":"Write a file"},{"location":"tasks/cc65/","text":"Task for cc65 clock() fix mkdir bug readdir()","title":"Task for cc65"},{"location":"tasks/cc65/#task-for-cc65","text":"clock() fix mkdir bug readdir()","title":"Task for cc65"},{"location":"tasks/kernel/","text":"Kernel fix kernel panic in free primitive keep bank memory empty flag Find a way to keep kernel version somewhere","title":"Kernel"},{"location":"tasks/kernel/#kernel","text":"fix kernel panic in free primitive keep bank memory empty flag Find a way to keep kernel version somewhere","title":"Kernel"},{"location":"tasks/orixcfg/","text":"Orixcfg add orixcfg -p [idbank] filerom.rom (with header)","title":"Orixcfg"},{"location":"tasks/orixcfg/#orixcfg","text":"add orixcfg -p [idbank] filerom.rom (with header)","title":"Orixcfg"},{"location":"tools/mount/","text":"Mount (not developed yet) FP Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null. When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action : X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE ls case ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel cp/mv case don't know","title":"Mount (not developed yet)"},{"location":"tools/mount/#mount-not-developed-yet","text":"","title":"Mount (not developed yet)"},{"location":"tools/mount/#fp","text":"Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null.","title":"FP"},{"location":"tools/mount/#when-a-freadfwrite-is-done-if-extbank-is-different-to-0-then-kernel-will-launch-external-vector-with-a-and-y-contains-the-string-of-the-path-and-x-contains-the-action","text":"X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE","title":"When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action :"},{"location":"tools/mount/#ls-case","text":"ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel","title":"ls case"},{"location":"tools/mount/#cpmv-case","text":"don't know","title":"cp/mv case"}]}