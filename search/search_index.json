{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos Stratos . Twilighte Board . Orix 8 bits - Kernel Orix 16 bits Basic11 command and rom ch376 Doxygen for kernel .","title":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos"},{"location":"#documentation-for-orix8-bits-and-16-bits-twilighte-board-and-stratos","text":"Stratos . Twilighte Board . Orix 8 bits - Kernel Orix 16 bits Basic11 command and rom ch376 Doxygen for kernel .","title":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos"},{"location":"basic11/","text":"Fonctionnement Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance Si on tape : /#basic11 Cela lance la ROM Si on tape : /#basic11 \"TAPEFILE\" Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom. Si on tape : /#basic11 -l Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici Fonctionnement global Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1 Format du fichier \"maindb\" (basic11.db) Version 1 1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture) Format du fichier .db d'un soft version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Fonctionnement"},{"location":"basic11/#fonctionnement","text":"Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance","title":"Fonctionnement"},{"location":"basic11/#si-on-tape-basic11","text":"Cela lance la ROM","title":"Si on tape : /#basic11"},{"location":"basic11/#si-on-tape-basic11-tapefile","text":"Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom.","title":"Si on tape : /#basic11 \"TAPEFILE\""},{"location":"basic11/#si-on-tape-basic11-l","text":"Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici","title":"Si on tape : /#basic11 -l"},{"location":"basic11/#fonctionnement-global","text":"Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1","title":"Fonctionnement global"},{"location":"basic11/#format-du-fichier-maindb-basic11db","text":"","title":"Format du fichier \"maindb\" (basic11.db)"},{"location":"basic11/#version-1","text":"1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture)","title":"Version 1"},{"location":"basic11/#format-du-fichier-db-dun-soft","text":"version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Format du fichier .db d'un soft"},{"location":"orix8bits/","text":"Orix 8 Bits Install environment development for developers Getting-started Kernel primitives Primitives Mount Management Doxygen for kernel . Samples for kernel calls Get ctrl+c hook .include \"telestrat.inc\" asl KBDCTC bcc @no_ctrl ; here is ctrl management @no_ctrl: rts Test kernel Error when fopen failed ; Open ... BRK_KERNEL XOPEN cpy #$00 bne @read_rom cmp #$00 bne @read_rom ldx #$04 ; Get kernel ERRNO BRK_KERNEL XVARS sta userzp sty userzp+1 ldy #$00 lda (userzp),y ; get ERRNO from kernel cmp #ENOMEM bne @no_enomem_kernel_error PRINT str_enomem @no_enomem_kernel_error: cmp #ENOENT bne @no_enoent_kernel_error PRINT str_not_found Stop output when spacebar is pressed (for example) .include \"telestrat.inc\" @L12: BRK_KERNEL XRD0 bcs @no_char_action cmp #' ' ; Space pressed ? bne @no_char ; no continue lda myOffsetToManageSwitch ; One byte beq @inv_to_1 lda #$00 sta myOffsetToManageSwitch jmp @L12 @inv_to_1: inc myOffsetToManageSwitch jmp @L12 @no_char_action: lda myOffsetToManageSwitch beq @L12 @no_char: ; No keypressed Displays a string lda #<mystr ldy #>mystr BRK_KERNEL XWRSTR0 rts mysstr: .asciiz \"hello\"","title":"Orix 8 Bits"},{"location":"orix8bits/#orix-8-bits","text":"","title":"Orix 8 Bits"},{"location":"orix8bits/#install-environment-development-for-developers","text":"Getting-started","title":"Install environment development for developers"},{"location":"orix8bits/#kernel-primitives","text":"Primitives Mount Management Doxygen for kernel .","title":"Kernel primitives"},{"location":"orix8bits/#samples-for-kernel-calls","text":"","title":"Samples for kernel calls"},{"location":"orix8bits/#get-ctrlc-hook","text":".include \"telestrat.inc\" asl KBDCTC bcc @no_ctrl ; here is ctrl management @no_ctrl: rts","title":"Get ctrl+c hook"},{"location":"orix8bits/#test-kernel-error-when-fopen-failed","text":"; Open ... BRK_KERNEL XOPEN cpy #$00 bne @read_rom cmp #$00 bne @read_rom ldx #$04 ; Get kernel ERRNO BRK_KERNEL XVARS sta userzp sty userzp+1 ldy #$00 lda (userzp),y ; get ERRNO from kernel cmp #ENOMEM bne @no_enomem_kernel_error PRINT str_enomem @no_enomem_kernel_error: cmp #ENOENT bne @no_enoent_kernel_error PRINT str_not_found","title":"Test kernel Error when fopen failed"},{"location":"orix8bits/#stop-output-when-spacebar-is-pressed-for-example","text":".include \"telestrat.inc\" @L12: BRK_KERNEL XRD0 bcs @no_char_action cmp #' ' ; Space pressed ? bne @no_char ; no continue lda myOffsetToManageSwitch ; One byte beq @inv_to_1 lda #$00 sta myOffsetToManageSwitch jmp @L12 @inv_to_1: inc myOffsetToManageSwitch jmp @L12 @no_char_action: lda myOffsetToManageSwitch beq @L12 @no_char: ; No keypressed","title":"Stop output when spacebar is pressed (for example)"},{"location":"orix8bits/#displays-a-string","text":"lda #<mystr ldy #>mystr BRK_KERNEL XWRSTR0 rts mysstr: .asciiz \"hello\"","title":"Displays a string"},{"location":"orix8bits/getting-started/","text":"Getting started Step 1 : Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board=yes plugins/twilighte_board/twilighte.cfg you can put any rom you want. Step 2 : start oricutron Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip Step 3 : Download/build cc65 Build it from cc65 Step 4 : Download SDK (mainly for assembly) Clone https://github.com/assinie/orix-sdk in your project folder Some informations : Banking management firmware version 1 $342 : twilighte board register b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set There is a register on board with says if we show ram or eeprom on the oric. (b5). There is another register ($321) with b0,b1, b2 which can select the id of the bank wanted. And there is another register to select bank set ($343). When you start, you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theres banks can't be switches and are always shown. You have now : bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda #$04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda #$01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli You can build oricutron from git and in oricutron.cfg, you have just to set the right parameter ch376 = yes twilighte_board=yes and in https://github.com/pete-gordon/oricutron/blob/master/plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Getting started"},{"location":"orix8bits/getting-started/#getting-started","text":"","title":"Getting started"},{"location":"orix8bits/getting-started/#step-1-configure-and-start-oricutron-with-twilighte-board","text":"Build from source code oricutron : https://github.com/pete-gordon/oricutron In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board=yes plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Step 1 : Configure and start oricutron with twilighte board"},{"location":"orix8bits/getting-started/#step-2-start-oricutron","text":"Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip","title":"Step 2 : start oricutron"},{"location":"orix8bits/getting-started/#step-3-downloadbuild-cc65","text":"Build it from cc65","title":"Step 3 : Download/build cc65"},{"location":"orix8bits/getting-started/#step-4-download-sdk-mainly-for-assembly","text":"Clone https://github.com/assinie/orix-sdk in your project folder","title":"Step 4 : Download SDK  (mainly for assembly)"},{"location":"orix8bits/getting-started/#some-informations-banking-management","text":"firmware version 1 $342 : twilighte board register b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set There is a register on board with says if we show ram or eeprom on the oric. (b5). There is another register ($321) with b0,b1, b2 which can select the id of the bank wanted. And there is another register to select bank set ($343). When you start, you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theres banks can't be switches and are always shown. You have now : bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda #$04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda #$01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora #%00100000 ; switch to ram set sta $342 lda #$04 ; switch to bank set of ram bank sta $321 cli You can build oricutron from git and in oricutron.cfg, you have just to set the right parameter ch376 = yes twilighte_board=yes and in https://github.com/pete-gordon/oricutron/blob/master/plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Some informations : Banking management"},{"location":"orix8bits/mount/","text":"Mount management : FP Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null. When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action : X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE ls case ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel cp/mv case don't know","title":"Mount management :"},{"location":"orix8bits/mount/#mount-management","text":"","title":"Mount management :"},{"location":"orix8bits/mount/#fp","text":"Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null.","title":"FP"},{"location":"orix8bits/mount/#when-a-freadfwrite-is-done-if-extbank-is-different-to-0-then-kernel-will-launch-external-vector-with-a-and-y-contains-the-string-of-the-path-and-x-contains-the-action","text":"X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE","title":"When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action :"},{"location":"orix8bits/mount/#ls-case","text":"ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel","title":"ls case"},{"location":"orix8bits/mount/#cpmv-case","text":"don't know","title":"cp/mv case"},{"location":"orix8bits/primitives/","text":"Primitives Args from commandline XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct Numbers XBINX : convert a number to decimal Files XOPEN : Open a file","title":"Index"},{"location":"orix8bits/primitives/#primitives","text":"","title":"Primitives"},{"location":"orix8bits/primitives/#args-from-commandline","text":"XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct","title":"Args from commandline"},{"location":"orix8bits/primitives/#numbers","text":"XBINX : convert a number to decimal","title":"Numbers"},{"location":"orix8bits/primitives/#files","text":"XOPEN : Open a file","title":"Files"},{"location":"orix8bits/primitives/xbindx/","text":"XBINX Description convert A & Y number into decimal Input A & Y the 16 bits values TR5 the pointer of the address to put decimal number DEFAFF : space before the number X : xxx Output A & TR5 Example lda #<$bb80 sta TR5 lda #>$bb80 sta TR5+1 lda #$20 sta DEFAFF ldx #$01 ldy #$00 lda #$10 BRK_KERNEL XBINX","title":"XBINX"},{"location":"orix8bits/primitives/xbindx/#xbinx","text":"","title":"XBINX"},{"location":"orix8bits/primitives/xbindx/#description","text":"convert A & Y number into decimal","title":"Description"},{"location":"orix8bits/primitives/xbindx/#input","text":"A & Y the 16 bits values TR5 the pointer of the address to put decimal number DEFAFF : space before the number X : xxx","title":"Input"},{"location":"orix8bits/primitives/xbindx/#output","text":"A & TR5","title":"Output"},{"location":"orix8bits/primitives/xbindx/#example","text":"lda #<$bb80 sta TR5 lda #>$bb80 sta TR5+1 lda #$20 sta DEFAFF ldx #$01 ldy #$00 lda #$10 BRK_KERNEL XBINX","title":"Example"},{"location":"orix8bits/primitives/xgetargv/","text":"XGETARGV Description Get argv. X register contains the number of the arg search Input A & Y the ptr of struct from XMAINARGS X the number of arg to get Output A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed Example XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr+1 ldx #$02 ; get arg 2 lda debug_mainargs_ptr ldy debug_mainargs_ptr+1 BRK_KERNEL XGETARGV","title":"XGETARGV"},{"location":"orix8bits/primitives/xgetargv/#xgetargv","text":"","title":"XGETARGV"},{"location":"orix8bits/primitives/xgetargv/#description","text":"Get argv. X register contains the number of the arg search","title":"Description"},{"location":"orix8bits/primitives/xgetargv/#input","text":"A & Y the ptr of struct from XMAINARGS X the number of arg to get","title":"Input"},{"location":"orix8bits/primitives/xgetargv/#output","text":"A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed","title":"Output"},{"location":"orix8bits/primitives/xgetargv/#example","text":"XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr+1 ldx #$02 ; get arg 2 lda debug_mainargs_ptr ldy debug_mainargs_ptr+1 BRK_KERNEL XGETARGV","title":"Example"},{"location":"orix8bits/primitives/xmainargs/","text":"XMAINARGS ID primitive : $2C Description Return argc and argv Input Nothing Output A & Y contains ptr to XMAINARGS Struct X: number of args Usage XMAINARGS = $2C brk_kernel XMAINARGS stx save_argc sta save_argvlow sty save_argvhigh","title":"XMAINARGS"},{"location":"orix8bits/primitives/xmainargs/#xmainargs","text":"ID primitive : $2C","title":"XMAINARGS"},{"location":"orix8bits/primitives/xmainargs/#description","text":"Return argc and argv","title":"Description"},{"location":"orix8bits/primitives/xmainargs/#input","text":"Nothing","title":"Input"},{"location":"orix8bits/primitives/xmainargs/#output","text":"A & Y contains ptr to XMAINARGS Struct X: number of args","title":"Output"},{"location":"orix8bits/primitives/xmainargs/#usage","text":"XMAINARGS = $2C brk_kernel XMAINARGS stx save_argc sta save_argvlow sty save_argvhigh","title":"Usage"},{"location":"stratos/","text":"Stratos Specs G\u00e9n\u00e9rales 15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier Fonctionnement atmos compatible La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ? Cas non g\u00e9r\u00e9s WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC Controleur usb, sdcard, clavier, souris Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi) Port ethernet ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ... EEprom kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg Kernel Orix 16bits appels via jsr avec un param\u00e8tre de primitive ?","title":"Stratos"},{"location":"stratos/#stratos","text":"","title":"Stratos"},{"location":"stratos/#specs-generales","text":"15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier","title":"Specs G\u00e9n\u00e9rales"},{"location":"stratos/#fonctionnement-atmos-compatible","text":"La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ?","title":"Fonctionnement atmos compatible"},{"location":"stratos/#cas-non-geres","text":"WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC","title":"Cas non g\u00e9r\u00e9s"},{"location":"stratos/#controleur-usb-sdcard-clavier-souris","text":"Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi)","title":"Controleur usb, sdcard, clavier, souris"},{"location":"stratos/#port-ethernet","text":"ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ...","title":"Port ethernet"},{"location":"stratos/#eeprom","text":"kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg","title":"EEprom"},{"location":"stratos/#kernel-orix-16bits","text":"appels via jsr avec un param\u00e8tre de primitive ?","title":"Kernel Orix 16bits"},{"location":"twilighteboard/","text":"Twilighte board FDC, RTC WIFI controller firmware version 1 $342 : twilighte board register b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $343 : Banking register Working board version with this firmware: v0.6 v0.65 firmware version 2 Reserved for twilighte board v0.6 & v0.65 upgrades firmware version 3 $342 b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ... $343 Banking register Notes Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version Twilighte board version 0.6 dirty hack for ca3083 replacement Twilighte board version 0.65 ca3083 removed and are replaced with BC547 Twilighte board version 0.7 Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board"},{"location":"twilighteboard/#twilighte-board","text":"FDC, RTC WIFI controller","title":"Twilighte board"},{"location":"twilighteboard/#firmware-version-1","text":"","title":"firmware version 1"},{"location":"twilighteboard/#342-twilighte-board-register","text":"b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"twilighteboard/#343-banking-register","text":"Working board version with this firmware: v0.6 v0.65","title":"$343 : Banking register"},{"location":"twilighteboard/#firmware-version-2","text":"Reserved for twilighte board v0.6 & v0.65 upgrades","title":"firmware version 2"},{"location":"twilighteboard/#firmware-version-3","text":"","title":"firmware version 3"},{"location":"twilighteboard/#342","text":"b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ...","title":"$342"},{"location":"twilighteboard/#343","text":"Banking register","title":"$343"},{"location":"twilighteboard/#notes","text":"Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version","title":"Notes"},{"location":"twilighteboard/#twilighte-board-version-06","text":"dirty hack for ca3083 replacement","title":"Twilighte board version 0.6"},{"location":"twilighteboard/#twilighte-board-version-065","text":"ca3083 removed and are replaced with BC547","title":"Twilighte board version 0.65"},{"location":"twilighteboard/#twilighte-board-version-07","text":"Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board version 0.7"},{"location":"twilighteboard/fdcWifiEsp/","text":"fdcsd I/O : * $315 : command port * $316 : data port ESP32_CHECK_EXIST ESP32_CHECK_EXIST = $06 Return data inverted bit ESP32_GET_IC_VER ESP32_GET_IC_VER = $01 Return version ESP32_SET_MODE CH376_SET_MODE = $15 Set mode ESP32_SET_MODE_CODE_FDC ESP32_LAUNCH_WIFI_SCAN $02 interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#fdcsd","text":"I/O : * $315 : command port * $316 : data port","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#esp32_check_exist","text":"ESP32_CHECK_EXIST = $06 Return data inverted bit","title":"ESP32_CHECK_EXIST"},{"location":"twilighteboard/fdcWifiEsp/#esp32_get_ic_ver","text":"ESP32_GET_IC_VER = $01 Return version","title":"ESP32_GET_IC_VER"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode","text":"CH376_SET_MODE = $15 Set mode","title":"ESP32_SET_MODE"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode_code_fdc","text":"","title":"ESP32_SET_MODE_CODE_FDC"},{"location":"twilighteboard/fdcWifiEsp/#esp32_launch_wifi_scan-02","text":"interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"ESP32_LAUNCH_WIFI_SCAN $02"}]}