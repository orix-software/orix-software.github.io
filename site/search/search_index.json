{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Definitions Twilighte board The Twilighte board is an extra hardware connected on the the oric (Atmos or Oric-1), it improves default Oric with hardware feature as eeprom (in system update), RAM, joysticks, usb controler. It handles 32 Banks of 16KB of eeprom and 32 Banks of 16KB for RAM. The architecture of hardware registers, joystick management has compatibility with Telestrat in order to have Oric working on Telestrat or Atmos. Feature Availability Sdcard Usbdrive storage Long filename Every usb device control 2 Joysticks Joysticks works at independently 512KB RAM memory 512KB eeprom memory Eeprom in system update Orix Orix is the default (D)OS of the board when it plugged into the oric. Orix is a linux/unix style OS. It's the main OS which can help to start every others systems as oric-1 ROM, atmos ROM etc Orix must have at least 2 banks to boot : Kernel and shell. Kernel is a bank inserted in the 7th slot and it's the first start to boot. Shell is the 5th bank and contains sh binary. When system starts, kernel forks \"sh\" commands at the end of the kernel initialisation. Shell is available and can starts any commands. There are 2 kind of rom : Standalone ROM : it does not need to call kernel primitive, and manage all the main memory (for example : atmos ROM) Orix Roms : in that case, rom does not manage the main memory, and calls kernel to do tasks (for example : Shell roms). In Orix roms, the rom declares commands to an offset in the bank and can be accessed from command line. If any command are typed from prompt, kernel will launch \"XEXEC\" primitive to find in any rom where the command is. Feature Availability Multitasking Long filename management","title":"Home"},{"location":"#definitions","text":"","title":"Definitions"},{"location":"#twilighte-board","text":"The Twilighte board is an extra hardware connected on the the oric (Atmos or Oric-1), it improves default Oric with hardware feature as eeprom (in system update), RAM, joysticks, usb controler. It handles 32 Banks of 16KB of eeprom and 32 Banks of 16KB for RAM. The architecture of hardware registers, joystick management has compatibility with Telestrat in order to have Oric working on Telestrat or Atmos. Feature Availability Sdcard Usbdrive storage Long filename Every usb device control 2 Joysticks Joysticks works at independently 512KB RAM memory 512KB eeprom memory Eeprom in system update","title":"Twilighte board"},{"location":"#orix","text":"Orix is the default (D)OS of the board when it plugged into the oric. Orix is a linux/unix style OS. It's the main OS which can help to start every others systems as oric-1 ROM, atmos ROM etc Orix must have at least 2 banks to boot : Kernel and shell. Kernel is a bank inserted in the 7th slot and it's the first start to boot. Shell is the 5th bank and contains sh binary. When system starts, kernel forks \"sh\" commands at the end of the kernel initialisation. Shell is available and can starts any commands. There are 2 kind of rom : Standalone ROM : it does not need to call kernel primitive, and manage all the main memory (for example : atmos ROM) Orix Roms : in that case, rom does not manage the main memory, and calls kernel to do tasks (for example : Shell roms). In Orix roms, the rom declares commands to an offset in the bank and can be accessed from command line. If any command are typed from prompt, kernel will launch \"XEXEC\" primitive to find in any rom where the command is. Feature Availability Multitasking Long filename management","title":"Orix"},{"location":"commands/all/","text":"bank basic11 ls env","title":"commands"},{"location":"commands/bank/","text":"bank Displays bank or switch a bank SYNOPSYS bank DESCRIPTION This command displays bank when the command is called without parameter. WIth a parameter, you can switch to a the id of the bank passed to the argument : bank : displays all the bank bank 4 : switch to bank 4 SOURCE https://github.com/orix-software/shell/blob/master/src/commands/bank.asm","title":"bank"},{"location":"commands/bank/#bank","text":"","title":"bank"},{"location":"commands/bank/#displays-bank-or-switch-a-bank","text":"","title":"Displays bank or switch a bank"},{"location":"commands/bank/#synopsys","text":"bank","title":"SYNOPSYS"},{"location":"commands/bank/#description","text":"This command displays bank when the command is called without parameter. WIth a parameter, you can switch to a the id of the bank passed to the argument : bank : displays all the bank bank 4 : switch to bank 4","title":"DESCRIPTION"},{"location":"commands/bank/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/bank.asm","title":"SOURCE"},{"location":"commands/basic11/","text":"Command: basic11 Start Atmos rom SYNOPSYS basic11 DESCRIPTION This command starts the atmos rom. This rom did not test RAM and cload/csave or done on sdcard. It means that it calls file from sdcard. Cload works with .tap file. Multitap files works too. Get a tape file, and place it in the root folder of the sdcard. Starts basic11 : /#basic11 or /#basic 11 \"DEFENDER\" CLOAD\"ZORGONS => it will load zorgons.tap Working software all games except the Hobbit (another ROM is available) SOURCE https://github.com/orix-software/shell/blob/master/src/commands/basic11.asm","title":"Command: basic11"},{"location":"commands/basic11/#command-basic11","text":"","title":"Command: basic11"},{"location":"commands/basic11/#start-atmos-rom","text":"","title":"Start Atmos rom"},{"location":"commands/basic11/#synopsys","text":"basic11","title":"SYNOPSYS"},{"location":"commands/basic11/#description","text":"This command starts the atmos rom. This rom did not test RAM and cload/csave or done on sdcard. It means that it calls file from sdcard. Cload works with .tap file. Multitap files works too. Get a tape file, and place it in the root folder of the sdcard. Starts basic11 : /#basic11 or /#basic 11 \"DEFENDER\" CLOAD\"ZORGONS => it will load zorgons.tap","title":"DESCRIPTION"},{"location":"commands/basic11/#working-software","text":"all games except the Hobbit (another ROM is available)","title":"Working software"},{"location":"commands/basic11/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/basic11.asm","title":"SOURCE"},{"location":"commands/env/","text":"Command: env Displays env variables SYNOPSYS env DESCRIPTION Displays env variables. It can't be used in command line or shell script for instance SOURCE https://github.com/orix-software/shell/blob/master/src/commands/env.asm","title":"Command: env"},{"location":"commands/env/#command-env","text":"","title":"Command: env"},{"location":"commands/env/#displays-env-variables","text":"","title":"Displays env variables"},{"location":"commands/env/#synopsys","text":"","title":"SYNOPSYS"},{"location":"commands/env/#env","text":"","title":"env"},{"location":"commands/env/#description","text":"Displays env variables. It can't be used in command line or shell script for instance","title":"DESCRIPTION"},{"location":"commands/env/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/env.asm","title":"SOURCE"},{"location":"commands/ls/","text":"Command: ls Display catalog SYNOPSYS ls DESCRIPTION Directories are in ^FBLUE^G color. It does not manage '-l'. Pattern works in different ways : ls *.tap SOURCE https://github.com/orix-software/shell/blob/master/src/commands/ls.asm","title":"Command: ls"},{"location":"commands/ls/#command-ls","text":"","title":"Command: ls"},{"location":"commands/ls/#display-catalog","text":"","title":"Display catalog"},{"location":"commands/ls/#synopsys","text":"ls","title":"SYNOPSYS"},{"location":"commands/ls/#description","text":"Directories are in ^FBLUE^G color. It does not manage '-l'. Pattern works in different ways : ls *.tap","title":"DESCRIPTION"},{"location":"commands/ls/#source","text":"https://github.com/orix-software/shell/blob/master/src/commands/ls.asm","title":"SOURCE"},{"location":"hardware/i_o/","text":"I/O The I/O ports can be see also when you type /#ioports $321 register for the id of the bank to switch b0, b1, b2 which can select the id of the bank wanted. $314 register This register is in firmware 2, and can mirror $314 calls to change to overlay memory $342 : twilighte board register b0,b1,b2 version number is equal to 1 or 2, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $343 : Twilighte banking register This register can contains values from 0 to 7 included. It defines the \"set\" of 64KB which be present in slot 4,3,2 and 1 of register $321 which contains the bank","title":"I/O"},{"location":"hardware/i_o/#io","text":"The I/O ports can be see also when you type /#ioports","title":"I/O"},{"location":"hardware/i_o/#321-register-for-the-id-of-the-bank-to-switch","text":"b0, b1, b2 which can select the id of the bank wanted.","title":"$321 register for the id of the bank to switch"},{"location":"hardware/i_o/#314-register","text":"This register is in firmware 2, and can mirror $314 calls to change to overlay memory","title":"$314 register"},{"location":"hardware/i_o/#342-twilighte-board-register","text":"b0,b1,b2 version number is equal to 1 or 2, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"hardware/i_o/#343-twilighte-banking-register","text":"This register can contains values from 0 to 7 included. It defines the \"set\" of 64KB which be present in slot 4,3,2 and 1 of register $321 which contains the bank","title":"$343 : Twilighte banking register"},{"location":"hardware/joysticks/","text":"Joysticks Read joysticks states On the board, joysticks works likes Telestrat one's.","title":"Joysticks"},{"location":"hardware/joysticks/#joysticks","text":"","title":"Joysticks"},{"location":"hardware/joysticks/#read-joysticks-states","text":"On the board, joysticks works likes Telestrat one's.","title":"Read joysticks states"},{"location":"hardware/ch376/vars8/","text":"CH376 extra vars Vars 8 #define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous - classe du p\u00e9riph\u00e9rique de stockage USB SubClass - Code , le bit 6 est 0 pour indiquer que la sous - classe est 6 et le bit 6 est 1 pour indiquer que la sous - classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l '\u00e9 tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l '\u00e9 tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB , si le bit 5 est 1 , la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB , si le bit 5 est 1 , il y a un p\u00e9riph\u00e9rique USB dans le port USB , et si le bit 5 est 0 , il n ' y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l '\u00e9 tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB . Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu ' il a \u00e9 t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0 , il ne r\u00e9essayera pas lorsque NAK est re\u00e7u , le bit 7 est 1 et le bit 6 est 0 , et r\u00e9essayera \u00e0 l ' infini lors de la r\u00e9ception de NAK ( vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative ), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l ' expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0 , l ' indicateur du syst\u00e8me de fichiers FAT du disque logique , 00 - FAT12 , 01 - FAT16 , 10 - FAT32 , 11 - ill\u00e9gal * / / * Bit 2 , indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9 t\u00e9 modifi\u00e9es , 0 - non modifi\u00e9 , 1 - modifi\u00e9 * / / * Bit 3 , la longueur du fichier doit \u00ea tre modifi\u00e9e , le fichier actuel est ajout\u00e9 avec les donn\u00e9es , 0 - Aucune modification n ' est pas ajout\u00e9e , 1 - Ajout\u00e9 et doit \u00ea tre modifi\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0 , version de la carte SD , 0 - prend uniquement en charge la premi\u00e8re version SD , 1 - prend en charge la deuxi\u00e8me version SD * / / * Bit 1 , reconnaissance automatique , carte 0 - SD , carte 1 - MMC * / / * Bit 2 , identification automatique , carte SD de capacit\u00e9 standard 0 , carte SD 1 grande capacit\u00e9 ( HC - SD ) * / / * Bit 4 , d\u00e9lai d ' expiration de la commande ACMD41 * / / * Bit 5 , d\u00e9lai d ' expiration de la commande CMD1 * / / * Bit 6 , d\u00e9lai d ' expiration de la commande CMD58 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0 , doit \u00ea tre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4 , le num\u00e9ro d ' unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB , apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB , la valeur par d\u00e9faut est d ' acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0 , le num\u00e9ro d ' unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB , plus 1 est \u00e9 gal au nombre d ' unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"CH376 extra vars"},{"location":"hardware/ch376/vars8/#ch376-extra-vars","text":"","title":"CH376 extra vars"},{"location":"hardware/ch376/vars8/#vars-8","text":"#define VAR_SYS_BASE_INFO 0x20 / * Informations de base du syst\u00e8me actuel * / / * Le bit 6 est utilis\u00e9 pour indiquer la sous - classe du p\u00e9riph\u00e9rique de stockage USB SubClass - Code , le bit 6 est 0 pour indiquer que la sous - classe est 6 et le bit 6 est 1 pour indiquer que la sous - classe est diff\u00e9rente de 6 * / / * Le bit 5 est utilis\u00e9 pour indiquer l '\u00e9 tat de la configuration USB en mode p\u00e9riph\u00e9rique USB et l '\u00e9 tat de la connexion du p\u00e9riph\u00e9rique USB en mode h\u00f4te USB * / / * En mode p\u00e9riph\u00e9rique USB , si le bit 5 est 1 , la configuration USB est termin\u00e9e et les bits 5 et 0 ne sont pas configur\u00e9s * / / * En mode h\u00f4te USB , si le bit 5 est 1 , il y a un p\u00e9riph\u00e9rique USB dans le port USB , et si le bit 5 est 0 , il n ' y a pas de p\u00e9riph\u00e9rique USB dans le port USB * / / * Le bit 4 est utilis\u00e9 pour indiquer l '\u00e9 tat de verrouillage du tampon en mode p\u00e9riph\u00e9rique USB . Le bit 4 est 1 signifie que le tampon USB est verrouill\u00e9 et le bit 6 est 1 signifie qu ' il a \u00e9 t\u00e9 lib\u00e9r\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_RETRY_TIMES 0x25 / * Nombre de tentatives d'op\u00e9ration de transaction USB * / / * Si le bit 7 est 0 , il ne r\u00e9essayera pas lorsque NAK est re\u00e7u , le bit 7 est 1 et le bit 6 est 0 , et r\u00e9essayera \u00e0 l ' infini lors de la r\u00e9ception de NAK ( vous pouvez utiliser la commande CMD_ABORT_NAK pour abandonner la nouvelle tentative ), le bit 7 est 1 et 6 est 1 R\u00e9essayez au plus 3 secondes lors de la r\u00e9ception de NAK * / / * Bit 5 ~ Bit 0 repr\u00e9sente le nombre de tentatives apr\u00e8s l ' expiration du d\u00e9lai * / #define VAR_FILE_BIT_FLAG 0x26 / * Indicateur de bit en mode fichier h\u00f4te * / / * Bit 1 et Bit 0 , l ' indicateur du syst\u00e8me de fichiers FAT du disque logique , 00 - FAT12 , 01 - FAT16 , 10 - FAT32 , 11 - ill\u00e9gal * / / * Bit 2 , indique si les donn\u00e9es de la table FAT dans le tampon courant ont \u00e9 t\u00e9 modifi\u00e9es , 0 - non modifi\u00e9 , 1 - modifi\u00e9 * / / * Bit 3 , la longueur du fichier doit \u00ea tre modifi\u00e9e , le fichier actuel est ajout\u00e9 avec les donn\u00e9es , 0 - Aucune modification n ' est pas ajout\u00e9e , 1 - Ajout\u00e9 et doit \u00ea tre modifi\u00e9 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_DISK_STATUS 0x2B / * \u00c9tat du disque et du fichier en mode fichier h\u00f4te * / #define VAR_SD_BIT_FLAG 0x30 / * Indicateur de bit de la carte SD en mode fichier h\u00f4te * / / * Bit 0 , version de la carte SD , 0 - prend uniquement en charge la premi\u00e8re version SD , 1 - prend en charge la deuxi\u00e8me version SD * / / * Bit 1 , reconnaissance automatique , carte 0 - SD , carte 1 - MMC * / / * Bit 2 , identification automatique , carte SD de capacit\u00e9 standard 0 , carte SD 1 grande capacit\u00e9 ( HC - SD ) * / / * Bit 4 , d\u00e9lai d ' expiration de la commande ACMD41 * / / * Bit 5 , d\u00e9lai d ' expiration de la commande CMD1 * / / * Bit 6 , d\u00e9lai d ' expiration de la commande CMD58 * / / * Autres bits , r\u00e9serv\u00e9s , veuillez ne pas modifier * / #define VAR_UDISK_TOGGLE 0x31 / * L'indicateur de synchronisation du point de terminaison BULK-IN / BULK-OUT du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 6 , indicateur de synchronisation de point de terminaison en bloc * / / * Bit 5 ~ Bit 0 , doit \u00ea tre 0 * / #define VAR_UDISK_LUN 0x34 / * Le num\u00e9ro d'unit\u00e9 logique du p\u00e9riph\u00e9rique de stockage USB * / / * Bit 7 ~ Bit 4 , le num\u00e9ro d ' unit\u00e9 logique actuel du p\u00e9riph\u00e9rique de stockage USB , apr\u00e8s que CH376 initialise le p\u00e9riph\u00e9rique de stockage USB , la valeur par d\u00e9faut est d ' acc\u00e9der \u00e0 0 # unit\u00e9 logique * / / * Bit 3 ~ Bit 0 , le num\u00e9ro d ' unit\u00e9 logique maximum du p\u00e9riph\u00e9rique de stockage USB , plus 1 est \u00e9 gal au nombre d ' unit\u00e9s logiques * / #define VAR_SEC_PER_CLUS 0x38 / * Le nombre de secteurs par cluster du disque logique * / #define VAR_FILE_DIR_INDEX 0x3B / * Le num\u00e9ro d'index des informations de r\u00e9pertoire de fichiers en cours dans le secteur * / #define VAR_CLUS_SEC_OFS 0x3C / * Le d\u00e9calage de secteur du pointeur de fichier actuel dans le cluster, 0xFF pointe vers la fin du fichier, la fin du cluster * / / * Variable 32 bits / 4 octets * / #define VAR_DISK_ROOT 0x44 / * Pour les disques FAT16, c'est le nombre de secteurs occup\u00e9s par le r\u00e9pertoire racine, et pour les disques FAT32, c'est le num\u00e9ro de cluster de d\u00e9part du r\u00e9pertoire racine (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_TOTAL_CLUS 0x48 / * Le nombre total de clusters du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_DSK_START_LBA 0x4C / * Le num\u00e9ro de secteur absolu de d\u00e9part du disque logique LBA (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_DSK_DAT_START 0x50 / * LBA de d\u00e9part de la zone de donn\u00e9es du disque logique (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_LBA_BUFFER 0x54 / * LBA correspondant aux donn\u00e9es du tampon de donn\u00e9es actuel du disque (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_LBA_CURRENT 0x58 / * L'adresse LBA de d\u00e9part du disque actuellement lu et \u00e9crit (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FAT_DIR_LBA 0x5C / * L'adresse LBA du secteur o\u00f9 se trouvent les informations du r\u00e9pertoire de fichiers en cours (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_START_CLUSTER 0x60 / * Le num\u00e9ro de cluster de d\u00e9part du fichier ou du r\u00e9pertoire (dossier) actuel (longueur totale 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_CLUST 0x64 / * Le num\u00e9ro de cluster actuel du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_FILE_SIZE 0x68 / * La longueur du fichier actuel (la longueur totale est de 32 bits, octet de poids faible en premier) * / #define VAR_CURRENT_OFFSET 0x6C / * Le pointeur de fichier actuel, le d\u00e9calage d'octet de la position actuelle de lecture et d'\u00e9criture (longueur totale 32 bits, octet de poids faible en premier) * /","title":"Vars 8"},{"location":"home/","text":"Installation for developpers There is two way to develop : Oricutron and cross dev with test on real computer Step 1 : Download the oricutron archive with all things set : oricutron_twilighte_board_for_projects.zip or Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron or download last windows binaries : https://iss.sandacite.com/iss/oricutron/ In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board = yes plugins/twilighte_board/twilighte.cfg you can put any rom you want. Step 2 : get main rom (kernel and shell) Skip this step, if you downloaded \"oricutron_twilighte_board_for_projects\" arhive Step 3 : start oricutron Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip Step 4 : Download/build cc65 Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder) Step 5 : Download SDK (mainly for assembly) Clone https://github.com/assinie/orix-sdk in your project folder","title":"Installation"},{"location":"home/#installation-for-developpers","text":"There is two way to develop : Oricutron and cross dev with test on real computer","title":"Installation for developpers"},{"location":"home/#step-1-download-the-oricutron-archive-with-all-things-set","text":"oricutron_twilighte_board_for_projects.zip or Configure and start oricutron with twilighte board Build from source code oricutron : https://github.com/pete-gordon/oricutron or download last windows binaries : https://iss.sandacite.com/iss/oricutron/ In oricutron.cfg, you have just to set the right parameter to start oric with the board emulated ch376 = yes twilighte_board = yes plugins/twilighte_board/twilighte.cfg you can put any rom you want.","title":"Step 1 : Download the oricutron archive with all things set :"},{"location":"home/#step-2-get-main-rom-kernel-and-shell","text":"Skip this step, if you downloaded \"oricutron_twilighte_board_for_projects\" arhive","title":"Step 2 : get main rom (kernel and shell)"},{"location":"home/#step-3-start-oricutron","text":"Starts oricutron, if everything is OK, Orix starts, if you have missing rom at boot, modify plugins/twilighte_board/twilighte.cfg in order to replace wrong ROM. there is 2 folders on oricutron: sdcard and usbdrive, in orix type \"/#mount\", if usb is shown, then usbdrive/ folder is the main folder. Under Linux, all filenames must be uppercases (folder and files), it's mainly because emulation rescpect FAT32 specs in the sdcard/usbdrive chip","title":"Step 3 : start oricutron"},{"location":"home/#step-4-downloadbuild-cc65","text":"Build it from cc65. You can build your first program in C with cc65 and telestrat target. It builds an Orix binary. This binary can be put in bin/ folder of the device (for oricutron : usbdrive or sdcard folder)","title":"Step 4 : Download/build cc65"},{"location":"home/#step-5-download-sdk-mainly-for-assembly","text":"Clone https://github.com/assinie/orix-sdk in your project folder","title":"Step 5 : Download SDK  (mainly for assembly)"},{"location":"home/buildman/","text":"Manual pages man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Generate man pages"},{"location":"home/buildman/#manual-pages","text":"man binary is available and you can build man pages from .md files You need to use md2hlp program here : https://github.com/assinie/md2hlp","title":"Manual pages"},{"location":"home/buildrom/","text":"Build an Orix rom Guideline In order to have commands available from shell, some rules must be set. Bank structure must be used, or commands won't be accessed from the kernel or commands (As help -b XX) There is the choice to build a ROM which will be in an eeprom slot or a RAM slot. Ram slot is useful if some values must be set internaly (and it avoid malloc use, but it's not the way a ROM should not done if the process can be launched twice at the same time). Almost all existing roms are in a eeprom slot (kernel, shell, monitor, forth ..). Systemd rom is the only rom loaded into RAM slot, because, systemd can not be started twice, and keep internal informations. C is possible for ROM, but the 16KB of a bank is quickly filled with code. orix-sdk must be intensively used, and if it can't used, kernel primitives must be used. If a universal feature is missing in kernel, it's better to insert into kernel than develop only for the ROM. Each rom contains 1 or X commands. In order to have multitasking in the future, commands must use malloc and free from kernel (and file operations) The limit is 16KB for a ROM for instance. But, it's maybe enough because many operations are done with kernel calls (fopen for example). Kernel is always available when \"set\" banking is RAM or EEPROM, or are changed. Bank 7 (kernel is always available even when there is swapping between banks) Bank Structure If you want to build an orix compatible rom, a special format is used for Orix bank. You can download rom template here : https://github.com/orix-software/empty-rom/ Rom definition $fff0 : 1 byte, rom type (Value 0 : empty bank, value 1 : command bank) Zero page Kernel uses some address in zero page. But $80 to $FF offset are reserved for binary, Orix banks. Address below $80 can be used, but kernel could erase it when IRQ or Kernels calls occurs. Mainly, in some orix rom, userzp is a label for $80 offset. Kernel saves 16 bytes when a binary is forked. It means that a XEXEC calls in a binary will save PPID offset from $80 to $80+16, and kernel will restore theses offsets when the PID has finished. In the future, multitasking will work in the same ways, and there is no guarantee that a binary will have its values restores when offset are greater than $80+16 Launch the ROM Oricutron If it's a rom which must be in a ram slot, the config file must be set it in in bankram section or else insert it in bankrom section. Real Rom can be loaded on eeprom easily, it will erase 4 banks : orixcfg -r -s 0 myrom.rom Rom must be loaded into ram slot, it will erase only one bank : : orixcfg -w -s 0 -b 4 myrom.rom At this step if everything is OK, each commands from the bank can be accessed from shell.","title":"Build an Orix rom"},{"location":"home/buildrom/#build-an-orix-rom","text":"","title":"Build an Orix rom"},{"location":"home/buildrom/#guideline","text":"In order to have commands available from shell, some rules must be set. Bank structure must be used, or commands won't be accessed from the kernel or commands (As help -b XX) There is the choice to build a ROM which will be in an eeprom slot or a RAM slot. Ram slot is useful if some values must be set internaly (and it avoid malloc use, but it's not the way a ROM should not done if the process can be launched twice at the same time). Almost all existing roms are in a eeprom slot (kernel, shell, monitor, forth ..). Systemd rom is the only rom loaded into RAM slot, because, systemd can not be started twice, and keep internal informations. C is possible for ROM, but the 16KB of a bank is quickly filled with code. orix-sdk must be intensively used, and if it can't used, kernel primitives must be used. If a universal feature is missing in kernel, it's better to insert into kernel than develop only for the ROM. Each rom contains 1 or X commands. In order to have multitasking in the future, commands must use malloc and free from kernel (and file operations) The limit is 16KB for a ROM for instance. But, it's maybe enough because many operations are done with kernel calls (fopen for example). Kernel is always available when \"set\" banking is RAM or EEPROM, or are changed. Bank 7 (kernel is always available even when there is swapping between banks)","title":"Guideline"},{"location":"home/buildrom/#bank-structure","text":"If you want to build an orix compatible rom, a special format is used for Orix bank. You can download rom template here : https://github.com/orix-software/empty-rom/","title":"Bank Structure"},{"location":"home/buildrom/#rom-definition","text":"$fff0 : 1 byte, rom type (Value 0 : empty bank, value 1 : command bank)","title":"Rom definition"},{"location":"home/buildrom/#zero-page","text":"Kernel uses some address in zero page. But $80 to $FF offset are reserved for binary, Orix banks. Address below $80 can be used, but kernel could erase it when IRQ or Kernels calls occurs. Mainly, in some orix rom, userzp is a label for $80 offset. Kernel saves 16 bytes when a binary is forked. It means that a XEXEC calls in a binary will save PPID offset from $80 to $80+16, and kernel will restore theses offsets when the PID has finished. In the future, multitasking will work in the same ways, and there is no guarantee that a binary will have its values restores when offset are greater than $80+16","title":"Zero page"},{"location":"home/buildrom/#launch-the-rom","text":"","title":"Launch the ROM"},{"location":"home/buildrom/#oricutron","text":"If it's a rom which must be in a ram slot, the config file must be set it in in bankram section or else insert it in bankrom section.","title":"Oricutron"},{"location":"home/buildrom/#real","text":"Rom can be loaded on eeprom easily, it will erase 4 banks : orixcfg -r -s 0 myrom.rom Rom must be loaded into ram slot, it will erase only one bank : : orixcfg -w -s 0 -b 4 myrom.rom At this step if everything is OK, each commands from the bank can be accessed from shell.","title":"Real"},{"location":"home/buildstandalonerom/","text":"Build a standalone ROM Prerequisites Before starting : Read Oricutron VS Real hardware Guidelines A standalone ROM is a ROM which does not need the kernel and manage the fully main memory. It's not the main choice when a ROM is built, but it's used to handle easily compatibility for \"Legacy roms\" as Atmos Rom, Oric-1 and others customs roms released. It means that all code to manage files, joysticks, text I/O, Hires I/O must be inserted in this rom. This mode must avoided because it won't handle evolution handled in the kernel and the Twilighte board Access to sdcard and usbdrive Orix and kernel handles devices : usbdrive (Usbkey) and sdcard. When a standalone rom is built, it must keep default device, in that case, it requires to ask to the kernel which is the default device before flushing main memory. Launching a standalone ROM If you are on Oricutron, you can put in bank 7, your rom and start Oricutron in twilighte board mode. On real computer, you need to copy your ROM into a folder (ex : /usr/share/myroms/myrom.rom) Modify /etc/systemd/banks.cnf to add a new rom entry Type funct + L and you will be able to start your standalone ROM","title":"Build standalone Rom"},{"location":"home/buildstandalonerom/#build-a-standalone-rom","text":"","title":"Build a standalone ROM"},{"location":"home/buildstandalonerom/#prerequisites","text":"Before starting : Read Oricutron VS Real hardware","title":"Prerequisites"},{"location":"home/buildstandalonerom/#guidelines","text":"A standalone ROM is a ROM which does not need the kernel and manage the fully main memory. It's not the main choice when a ROM is built, but it's used to handle easily compatibility for \"Legacy roms\" as Atmos Rom, Oric-1 and others customs roms released. It means that all code to manage files, joysticks, text I/O, Hires I/O must be inserted in this rom. This mode must avoided because it won't handle evolution handled in the kernel and the Twilighte board","title":"Guidelines"},{"location":"home/buildstandalonerom/#access-to-sdcard-and-usbdrive","text":"Orix and kernel handles devices : usbdrive (Usbkey) and sdcard. When a standalone rom is built, it must keep default device, in that case, it requires to ask to the kernel which is the default device before flushing main memory.","title":"Access to sdcard and usbdrive"},{"location":"home/buildstandalonerom/#launching-a-standalone-rom","text":"If you are on Oricutron, you can put in bank 7, your rom and start Oricutron in twilighte board mode. On real computer, you need to copy your ROM into a folder (ex : /usr/share/myroms/myrom.rom) Modify /etc/systemd/banks.cnf to add a new rom entry Type funct + L and you will be able to start your standalone ROM","title":"Launching a standalone ROM"},{"location":"home/cc65/","text":"Cc65 use cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary.","title":"cc65"},{"location":"home/cc65/#cc65-use","text":"cc65 and ca65 are used mainly for kernel, shell and others binaries. Any assembler can be used, it just needs to add the Orix binary header at the beginning of the binary file. It's easier to use ca65 because orix sdk provide ca65 macro and .cfg to build a binary when it's coded in assembly only. Some libs are also build under ca65, and it's easier to link with ca65 if your code is written with ca65. If you code with cc65 or ca65, you need to use -ttelestrat switch to build Orix binary.","title":"Cc65 use"},{"location":"home/firmware/","text":"Firmwares You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables : Firmware 1 Firmware 2 Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank Firmware 3 It's under development but it will handles others hardware chips.","title":"Firmware informations"},{"location":"home/firmware/#firmwares","text":"You can get firmare version with $342 register and get b0,b1,b2. It will show the firmware version. There is only 2 versions availables :","title":"Firmwares"},{"location":"home/firmware/#firmware-1","text":"","title":"Firmware 1"},{"location":"home/firmware/#firmware-2","text":"Manage microdisc compatibility : it handes $314 register to switch on the right ram overlay bank","title":"Firmware 2"},{"location":"home/firmware/#firmware-3","text":"It's under development but it will handles others hardware chips.","title":"Firmware 3"},{"location":"home/hardware/","text":"Hardware Twilighte Board .","title":"Hardware"},{"location":"home/hardware/#hardware","text":"Twilighte Board .","title":"Hardware"},{"location":"home/header/","text":"Header Orix binary v1 format (not relocated) Orix binary v1 is not a relocated format. The binary must be never under $800. In the future, a relocated binary format could be used You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly .byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt < start_adress , > start_adress ; loading adress .byt < endofmemory , > EndOfMemory ; end of loading adress .byt < start_adress , > start_adress ; starting adress start_adress: *= $1000 lda # $41 sta $bb80 rts EndOfMemory: Orix binary v3 format (relocated by bitfield) .byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description ;7 .byt $00 ; size of the bitfield map low .byt $00 ; size of the bitfield map high ;9 .byt $00 ; reserved ;10 .byt $00 ; reserved ;11 .byt $00 ; reserved ;12 .byt $00 ; reserved ;13 .byt $00 ; reserved ;14 .byt < start_adress , > start_adress ; loading adress ;16 .byt < endofmemory , > EndOfMemory ; end of loading adress ; 18 .byt $00 ; Offset of the bitfield map in the file low .byt $00 ; Offset of the bitfield map in the file high ; end of header start_adress: lda $00 rts EndOfMemory: Description cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell)","title":"Binary header format"},{"location":"home/header/#header","text":"","title":"Header"},{"location":"home/header/#orix-binary-v1-format-not-relocated","text":"Orix binary v1 is not a relocated format. The binary must be never under $800. In the future, a relocated binary format could be used You don't need to know this format except if you use others assembler than ca65 (or cc65 with C). Orix-sdk provide .cfg file to add header to your code in assembly .byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt $00 ; reserved .byt < start_adress , > start_adress ; loading adress .byt < endofmemory , > EndOfMemory ; end of loading adress .byt < start_adress , > start_adress ; starting adress start_adress: *= $1000 lda # $41 sta $bb80 rts EndOfMemory:","title":"Orix binary v1 format (not relocated)"},{"location":"home/header/#orix-binary-v3-format-relocated-by-bitfield","text":".byt $01 , $00 ; non-C64 marker like o65 format .byt \"o\" , \"r\" , \"i\" ; \"ori\" MAGIC number :$6f, $36, $35 like o65 format .byt $01 ; version of this header (can not be relocated) cpu_mode: .byt $00 ; CPU see below for description ;7 .byt $00 ; size of the bitfield map low .byt $00 ; size of the bitfield map high ;9 .byt $00 ; reserved ;10 .byt $00 ; reserved ;11 .byt $00 ; reserved ;12 .byt $00 ; reserved ;13 .byt $00 ; reserved ;14 .byt < start_adress , > start_adress ; loading adress ;16 .byt < endofmemory , > EndOfMemory ; end of loading adress ; 18 .byt $00 ; Offset of the bitfield map in the file low .byt $00 ; Offset of the bitfield map in the file high ; end of header start_adress: lda $00 rts EndOfMemory:","title":"Orix binary v3 format (relocated by bitfield)"},{"location":"home/header/#description","text":"cpu_mode For 6502 rockwell (oric version no illegals opcodes) .byt %00000000 ; 6502 (bit 0 = 0) For 65C02 WDC .byt %00000001 ; 65c02 (bit 0 = 1) For 65C816 WDC .byt %00000010 ; 65C816 (bit 1 = 1) For 6502 with illegal opcodes (rockwell)","title":"Description"},{"location":"home/joysticks/","text":"Joysticks management Joystick supports is done in telestrat target, it means that you just need to call standard joystick drivers in cc65. Twilighte board is emulated but emulation joystick is not done in atmos + twilighte board configuration, it only works with oricutron telestrat mode.","title":"Joysticks management"},{"location":"home/joysticks/#joysticks-management","text":"Joystick supports is done in telestrat target, it means that you just need to call standard joystick drivers in cc65. Twilighte board is emulated but emulation joystick is not done in atmos + twilighte board configuration, it only works with oricutron telestrat mode.","title":"Joysticks management"},{"location":"home/kernel/","text":"Kernel Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orix SDK manages some kernel calls, and it's better to use macro set to call some primitives Kernel doc for developpers","title":"Kernel"},{"location":"home/kernel/#kernel","text":"Kernel is located in bank 7. Each primitives are called with \"brk\" instruction with a value after it. We can pass args to AXY or others memory location and the primitive can be called. Orix SDK manages some kernel calls, and it's better to use macro set to call some primitives","title":"Kernel"},{"location":"home/kernel/#kernel-doc-for-developpers","text":"","title":"Kernel doc for developpers"},{"location":"home/memory/","text":"Memory management Orix Roms Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. But theses primitives only returns pointer from main memory. Standalone ROM Extra memory can be accessed without kernel primitive with simple code The banking management is a bit special, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility It selects bank set ($343). When you start Orix you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown. For others banks (4,3,2,1), you have bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM You should not use this code, because it's not necessary to use theses routines (Kernel provides routines, or facility to call binaries in banks) If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda # $04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora # %00100000 ; switch to ram set sta $342 lda # $04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda # $01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora # %00100000 ; switch to ram set sta $342 lda # $04 ; switch to bank set of ram bank sta $321 cli","title":"Memory management"},{"location":"home/memory/#memory-management","text":"","title":"Memory management"},{"location":"home/memory/#orix-roms","text":"Kernel has XMALLOC and XFREE primitives to allocate memory dynamictly. But theses primitives only returns pointer from main memory.","title":"Orix Roms"},{"location":"home/memory/#standalone-rom","text":"Extra memory can be accessed without kernel primitive with simple code The banking management is a bit special, because it keeps telestrat compatibility (7 banks available + 1 bank for Overlay RAM), that is why twilighte board adds others registers to keep telestrat compatibility It selects bank set ($343). When you start Orix you have only 7 banks available : bank 7 : kernel bank 6 : basic11 (modified to work with sdcard or usb key) bank 5 : shell Theses banks can't be switch and are always shown. For others banks (4,3,2,1), you have bank 4: what you want bank 3: what you want bank 2: what you want bank 1: what you want But theses banks can be switches to others set banking RAM or ROM You should not use this code, because it's not necessary to use theses routines (Kernel provides routines, or facility to call binaries in banks) If you want to switch to bank 4 (hardware) you have to do in main ram, but there is also vectors) : sei lda # $04 sta $321 cli ; $C000 to $FFFF will be on bank 4 on eeprom bank because we did not set any others registers) if you want to switch to RAM bank : sei lda $342 ora # %00100000 ; switch to ram set sta $342 lda # $04 ; switch to bank set of ram bank sta $321 cli if you want to switch to antoher set RAM bank : sei lda # $01 ; set 1 instead of current set at boot (0) sta $343 lda $342 ora # %00100000 ; switch to ram set sta $342 lda # $04 ; switch to bank set of ram bank sta $321 cli","title":"Standalone ROM"},{"location":"home/oricutronvsreal/","text":"Oricutron VS real hardware Differencies and issues usb controller is not fully emulated, it means that a lot of commands does not work on the emulation (mainly low usb command) uppercase and lower case for filenames are not managed in oricutron. It means that a code could work on Oricutron but it won't work on real. Every access to sdcard or usbdrive with FAT fileformat must be done with filename and path in uppercase (eg : toto.txt must be sent to the controler like TOTO.TXT)","title":"Oricutron VS real hardware"},{"location":"home/oricutronvsreal/#oricutron-vs-real-hardware","text":"","title":"Oricutron VS real hardware"},{"location":"home/oricutronvsreal/#differencies-and-issues","text":"usb controller is not fully emulated, it means that a lot of commands does not work on the emulation (mainly low usb command) uppercase and lower case for filenames are not managed in oricutron. It means that a code could work on Oricutron but it won't work on real. Every access to sdcard or usbdrive with FAT fileformat must be done with filename and path in uppercase (eg : toto.txt must be sent to the controler like TOTO.TXT)","title":"Differencies and issues"},{"location":"home/orixsdk/","text":"Orix SDK It provides macro to help assembly coding for Orix : https://github.com/assinie/orix-sdk/ The main way to handle orix-sdk is to add it as gitmodules (for example in a \"dependencies folder\") Load Orix SDK you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"macros/SDK.mac\" Display operation print string in text mode ;---------------------------------------------------------------------- ; ; usage: ; print #byte [,TELEMON|NOSAVE] ; print (pointer) [,TELEMON|NOSAVE] ; print address [,TELEMON|NOSAVE] ; ; Option: ; - TELEMON: when used within TELEMON bank ; - NOSAVE : does not preserve A,X,Y registers ; ; Call XWSTR0 function ; ;---------------------------------------------------------------------- Files operation fopen ;---------------------------------------------------------------------- ; ; usage: ; fopen file, mode [,TELEMON] [,ptr] [,oom_msg_ptr] [,fail_value] ; ; note: ; - file may be: (ptr), address ; - if parameter 'ptr' is present, store resulting AX in ptr & ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AX is $FFFF (ie XOPEN error) ; ; Call XOPEN function ;---------------------------------------------------------------------- ex : fopen ( basic11_ptr2 ), O_RDONLY cpx # $FF bne @read_maindb ; not null then start because we did not found a conf cmp # $FF bne @read_maindb ; not null then start because we did not found a conf PRINT str_basic11_missing BRK_KERNEL XCRLF lda # $FF ldx # $FF rts @read_maindb: bla The filename/path address must not be in the rom. If it's the case, the string must be copied into main memory because Kernel overlap the ROM. fopen macro from SDK will produce an error, if the 'address' is in a ROM range (eg : $c000-$FFFF). If you use a ptr, macro can not detect it, and XOPEN primitive won't be able to open your file FREAD macro ;---------------------------------------------------------------------- ; ; usage: ; fread ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFREAD function ;---------------------------------------------------------------------- Example : fopen ( MAN_SAVE_MALLOC_PTR ), O_RDONLY cpx # $FF bne next cmp # $FF bne next ; Not found rts next: ; Save FP sta MAN_FP stx MAN_FP + 1 fread myptr , 1080 , 1 , MAN_FP fclose ( MAN_FP ) FWRITE macro ;---------------------------------------------------------------------- ; ; usage: ; fwrite ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFWRITE function ;---------------------------------------------------------------------- FCLOSE macro ;---------------------------------------------------------------------- ; ; usage: ; fclose (fp) [,TELEMON] ; ; Call XCLOSE function ;---------------------------------------------------------------------- MKDIR macro ;---------------------------------------------------------------------- ; ; usage: ; mkdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XMKDIR function ;---------------------------------------------------------------------- CHDIR macro ;---------------------------------------------------------------------- ; ; usage: ; chdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XPUTCWD function ;---------------------------------------------------------------------- Memory operations Malloc ;---------------------------------------------------------------------- ; ; usage: ; malloc size [,ptr] [,oom_msg_ptr] [,fail_value] ; ; malloc #$0100 ; malloc (ptr) ; malloc value ; ; Note: ; - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AY is null (ie malloc error) ; ; Call XMALLOC function ; ;---------------------------------------------------------------------- Mfree (free pointer) ;---------------------------------------------------------------------- ; ; usage: ; mfree (ptr) ; ; Call XFREE function ;---------------------------------------------------------------------- Strings operation strncpy ;---------------------------------------------------------------------- ; strncpy src, dest, n ; ; Sortie: ; A: 0 et Z=1 si copie effectu\u00e9e, inchang\u00e9 si non ; X: 0 ; Y: Longueur r\u00e9ellement copi\u00e9e ;---------------------------------------------------------------------- lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;Limit 20 bytes (immediate mode) strncpy(src, dest, n) strncat concat 2 strings. Strings must be terminated by 0 strncat src, dest, n lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;strncpy(src, dest, n) lda files_type_loader_low sta ptr2 lda files_type_loader_high sta ptr2 + 1 strncat RESB , ptr1 , # 13 dest ptr will be changed by strncat. dest pointer must be saved","title":"SDK for Assembly"},{"location":"home/orixsdk/#orix-sdk","text":"It provides macro to help assembly coding for Orix : https://github.com/assinie/orix-sdk/ The main way to handle orix-sdk is to add it as gitmodules (for example in a \"dependencies folder\")","title":"Orix SDK"},{"location":"home/orixsdk/#load-orix-sdk","text":"you just need to load macro file in your code (and telestrat.inc from cc65): .include \"telestrat.inc\" .include \"macros/SDK.mac\"","title":"Load Orix SDK"},{"location":"home/orixsdk/#display-operation","text":"","title":"Display operation"},{"location":"home/orixsdk/#print-string-in-text-mode","text":";---------------------------------------------------------------------- ; ; usage: ; print #byte [,TELEMON|NOSAVE] ; print (pointer) [,TELEMON|NOSAVE] ; print address [,TELEMON|NOSAVE] ; ; Option: ; - TELEMON: when used within TELEMON bank ; - NOSAVE : does not preserve A,X,Y registers ; ; Call XWSTR0 function ; ;----------------------------------------------------------------------","title":"print string in text mode"},{"location":"home/orixsdk/#files-operation","text":"","title":"Files operation"},{"location":"home/orixsdk/#fopen","text":";---------------------------------------------------------------------- ; ; usage: ; fopen file, mode [,TELEMON] [,ptr] [,oom_msg_ptr] [,fail_value] ; ; note: ; - file may be: (ptr), address ; - if parameter 'ptr' is present, store resulting AX in ptr & ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AX is $FFFF (ie XOPEN error) ; ; Call XOPEN function ;---------------------------------------------------------------------- ex : fopen ( basic11_ptr2 ), O_RDONLY cpx # $FF bne @read_maindb ; not null then start because we did not found a conf cmp # $FF bne @read_maindb ; not null then start because we did not found a conf PRINT str_basic11_missing BRK_KERNEL XCRLF lda # $FF ldx # $FF rts @read_maindb: bla The filename/path address must not be in the rom. If it's the case, the string must be copied into main memory because Kernel overlap the ROM. fopen macro from SDK will produce an error, if the 'address' is in a ROM range (eg : $c000-$FFFF). If you use a ptr, macro can not detect it, and XOPEN primitive won't be able to open your file","title":"fopen"},{"location":"home/orixsdk/#fread-macro","text":";---------------------------------------------------------------------- ; ; usage: ; fread ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFREAD function ;---------------------------------------------------------------------- Example : fopen ( MAN_SAVE_MALLOC_PTR ), O_RDONLY cpx # $FF bne next cmp # $FF bne next ; Not found rts next: ; Save FP sta MAN_FP stx MAN_FP + 1 fread myptr , 1080 , 1 , MAN_FP fclose ( MAN_FP )","title":"FREAD macro"},{"location":"home/orixsdk/#fwrite-macro","text":";---------------------------------------------------------------------- ; ; usage: ; fwrite ptr, size, count, fp ; ; note: ; ptr may be : (ptr), address ; size may be: (ptr), address ; fp may be : address, #value, {address,y} ; ; Call XFWRITE function ;----------------------------------------------------------------------","title":"FWRITE macro"},{"location":"home/orixsdk/#fclose-macro","text":";---------------------------------------------------------------------- ; ; usage: ; fclose (fp) [,TELEMON] ; ; Call XCLOSE function ;----------------------------------------------------------------------","title":"FCLOSE macro"},{"location":"home/orixsdk/#mkdir-macro","text":";---------------------------------------------------------------------- ; ; usage: ; mkdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XMKDIR function ;----------------------------------------------------------------------","title":"MKDIR macro"},{"location":"home/orixsdk/#chdir-macro","text":";---------------------------------------------------------------------- ; ; usage: ; chdir ptr [,TELEMON] ; ; note: ; ptr may be: (ptr), address ; ; Call XPUTCWD function ;----------------------------------------------------------------------","title":"CHDIR macro"},{"location":"home/orixsdk/#memory-operations","text":"","title":"Memory operations"},{"location":"home/orixsdk/#malloc","text":";---------------------------------------------------------------------- ; ; usage: ; malloc size [,ptr] [,oom_msg_ptr] [,fail_value] ; ; malloc #$0100 ; malloc (ptr) ; malloc value ; ; Note: ; - if parameter 'ptr' is present, store resulting AY in ptr &ptr+1 ; - if parameter 'oom_msg_ptr' is present, emit string pointed by ; 'oom_msg_ptr' and return if AY is null (ie malloc error) ; ; Call XMALLOC function ; ;----------------------------------------------------------------------","title":"Malloc"},{"location":"home/orixsdk/#mfree-free-pointer","text":";---------------------------------------------------------------------- ; ; usage: ; mfree (ptr) ; ; Call XFREE function ;----------------------------------------------------------------------","title":"Mfree (free pointer)"},{"location":"home/orixsdk/#strings-operation","text":"","title":"Strings operation"},{"location":"home/orixsdk/#strncpy","text":";---------------------------------------------------------------------- ; strncpy src, dest, n ; ; Sortie: ; A: 0 et Z=1 si copie effectu\u00e9e, inchang\u00e9 si non ; X: 0 ; Y: Longueur r\u00e9ellement copi\u00e9e ;---------------------------------------------------------------------- lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;Limit 20 bytes (immediate mode) strncpy(src, dest, n)","title":"strncpy"},{"location":"home/orixsdk/#strncat","text":"concat 2 strings. Strings must be terminated by 0 strncat src, dest, n lda # < file_path sta ptr2 lda # > file_path sta ptr2 + 1 strncpy ptr2 , ptr1 , # 20 ;strncpy(src, dest, n) lda files_type_loader_low sta ptr2 lda files_type_loader_high sta ptr2 + 1 strncat RESB , ptr1 , # 13 dest ptr will be changed by strncat. dest pointer must be saved","title":"strncat"},{"location":"home/pizero_connection/","text":"Pi zero connection You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Cross dev on real hardware"},{"location":"home/pizero_connection/#pi-zero-connection","text":"You can also develop on the oric, if you have it next you and you have a pi zero with usb storage gadget configured Mount under windows a drive which is pi zero with samba binary. Then when build your code, you just need to copy the binary to the right letter. For example : copy mycode /s/bin/ /s/bin is pi zero folder, and you just need to type mycode at command line. You need to execute in crontab a shell script. It flushs linux cache to disk. The problem with gadget is that it keeps action in memory, and in facts, samba does not show you the binary because, it's not written on disk.","title":"Pi zero connection"},{"location":"home/relocbin/","text":"Relocation format If you want to generate a relocatable format for orix, follow this link : https://github.com/assinie/orix-sdk/blob/master/README.md","title":"Relocation format"},{"location":"home/relocbin/#relocation-format","text":"If you want to generate a relocatable format for orix, follow this link : https://github.com/assinie/orix-sdk/blob/master/README.md","title":"Relocation format"},{"location":"how-it-work/","text":"basic11 rom Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance Si on tape : /#basic11 Cela lance la ROM Si on tape : /#basic11 \"TAPEFILE\" Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom. Si on tape : /#basic11 -l Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici Fonctionnement global Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1 Format du fichier \"maindb\" (basic11.db) Version 1 1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture) Format du fichier .db d'un soft version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Basic 11 commands"},{"location":"how-it-work/#basic11-rom","text":"Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance","title":"basic11 rom"},{"location":"how-it-work/#si-on-tape-basic11","text":"Cela lance la ROM","title":"Si on tape : /#basic11"},{"location":"how-it-work/#si-on-tape-basic11-tapefile","text":"Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom.","title":"Si on tape : /#basic11 \"TAPEFILE\""},{"location":"how-it-work/#si-on-tape-basic11-l","text":"Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici","title":"Si on tape : /#basic11 -l"},{"location":"how-it-work/#fonctionnement-global","text":"Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1","title":"Fonctionnement global"},{"location":"how-it-work/#format-du-fichier-maindb-basic11db","text":"","title":"Format du fichier \"maindb\" (basic11.db)"},{"location":"how-it-work/#version-1","text":"1er octet : numero de version du fichier db (actuel : 1) puis la liste des noms de fichiers puis le titre tels que : filenametap8bytesLength ; name_software '\\0' en dernier octet \u00e0 la fin du fichier, nous avons l'octet $ff qui signale la fin du fichier (ceci permettant de simplifier le code de lecture)","title":"Version 1"},{"location":"how-it-work/#format-du-fichier-db-dun-soft","text":"version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Format du fichier .db d'un soft"},{"location":"how-it-work/binary_starts/","text":"Binary start sequence All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls XEXEC kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD Step 1 : check if binary is in a bank XEXEC reads all banks from 4 to 1 and tries to check if the program is in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks). If the commands is not found, it swaps \"Twilighte banking register\" to provide others 65KB of bank, kernel checks banks again. When kernel reached the 32 banks of rom, it swap to ram set, and reads all theses 32 banks of RAM. If the command is not found, kernel send error code, and shell will display error message according to kernel error code. That is why commands located in bank (eeprom and after RAM) are quicker to start. EEPROM banks are quicker to launch because kernel starts with eeprom set. Step 2 : Check if the binary is on the device If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If the binary open fails, it returns \"command not found\" or impossible to mount if device is not present. Step 3 : binary on storage device is found Kernel opens the file, reads the header, and loads the content of the binary on the right address. When it's OK, the binary is started (and a fork occurs)","title":"Boot sequence"},{"location":"how-it-work/binary_starts/#binary-start-sequence","text":"All commands are started with XEXEC kernel primitive. For example, when something is typed into shell, shell calls XEXEC kernel primitive (except for shell internal commands like echo, pwd ...). When a binary is executed, kernel fork a new process with its PID, PPID, CWD","title":"Binary start sequence"},{"location":"how-it-work/binary_starts/#step-1-check-if-binary-is-in-a-bank","text":"XEXEC reads all banks from 4 to 1 and tries to check if the program is in a ROM (that is why ROM needs to have a kind of header) If the commands is in a bank, it switches to the right bank and launch command vector (and it forks). If the commands is not found, it swaps \"Twilighte banking register\" to provide others 65KB of bank, kernel checks banks again. When kernel reached the 32 banks of rom, it swap to ram set, and reads all theses 32 banks of RAM. If the command is not found, kernel send error code, and shell will display error message according to kernel error code. That is why commands located in bank (eeprom and after RAM) are quicker to start. EEPROM banks are quicker to launch because kernel starts with eeprom set.","title":"Step 1 : check if binary is in a bank"},{"location":"how-it-work/binary_starts/#step-2-check-if-the-binary-is-on-the-device","text":"If the binary is not in a bank, kernel will try to open \"/bin/BINARY_FILE\". If the binary open fails, it returns \"command not found\" or impossible to mount if device is not present.","title":"Step 2 : Check if the binary is on the device"},{"location":"how-it-work/binary_starts/#step-3-binary-on-storage-device-is-found","text":"Kernel opens the file, reads the header, and loads the content of the binary on the right address. When it's OK, the binary is started (and a fork occurs)","title":"Step 3 : binary on storage device is found"},{"location":"kernel/primitives/","text":"Summary Args from commandline XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct Numbers XBINDX : convert a number to decimal Memory XMALLOC allocate memory from main memory XFREE Files XOPEN : Open a file XMKDIR : Create a folder XGETCWD : get current path XPUTCWD : change current path Text mode XSCROB : scroll from bottom to top XSCROH : scroll from top to bottom Execute EXEC : Execute binary","title":"Primitives"},{"location":"kernel/primitives/#summary","text":"","title":"Summary"},{"location":"kernel/primitives/#args-from-commandline","text":"XMAINARGS : get command line and build argv/argc XGETARGV : get an argv from xmainargs struct","title":"Args from commandline"},{"location":"kernel/primitives/#numbers","text":"XBINDX : convert a number to decimal","title":"Numbers"},{"location":"kernel/primitives/#memory","text":"XMALLOC allocate memory from main memory XFREE","title":"Memory"},{"location":"kernel/primitives/#files","text":"XOPEN : Open a file XMKDIR : Create a folder XGETCWD : get current path XPUTCWD : change current path","title":"Files"},{"location":"kernel/primitives/#text-mode","text":"XSCROB : scroll from bottom to top XSCROH : scroll from top to bottom","title":"Text mode"},{"location":"kernel/primitives/#execute","text":"EXEC : Execute binary","title":"Execute"},{"location":"kernel/primitives/xbindx/","text":"XBINDX (16 bytes to decimal) Description convert A & Y number into decimal Input A & Y the 16 bits values TR5 the pointer of the address to put decimal number DEFAFF : space before the number X : xxx Output A,TR4, TR5 Example lda # < $bb80 sta TR5 lda # > $bb80 sta TR5 + 1 lda # $20 sta DEFAFF ldx # $01 ldy # $00 lda # $10 BRK_KERNEL XBINDX rts","title":"XBINDX (16 bytes to decimal)"},{"location":"kernel/primitives/xbindx/#xbindx-16-bytes-to-decimal","text":"","title":"XBINDX (16 bytes to decimal)"},{"location":"kernel/primitives/xbindx/#description","text":"convert A & Y number into decimal","title":"Description"},{"location":"kernel/primitives/xbindx/#input","text":"A & Y the 16 bits values TR5 the pointer of the address to put decimal number DEFAFF : space before the number X : xxx","title":"Input"},{"location":"kernel/primitives/xbindx/#output","text":"A,TR4, TR5","title":"Output"},{"location":"kernel/primitives/xbindx/#example","text":"lda # < $bb80 sta TR5 lda # > $bb80 sta TR5 + 1 lda # $20 sta DEFAFF ldx # $01 ldy # $00 lda # $10 BRK_KERNEL XBINDX rts","title":"Example"},{"location":"kernel/primitives/xexec/","text":"XEXEC Description Start a binary (located in a ROM or on the current device) Input A & Y the ptr of the string. Output Returns an error if the binary is not found Modification : RES, RESB (kernel_create_process), TR0, TR1, TR4 (kernel_create_process), TR5 (kernel_create_process) KERNEL_ERRNO (kernel_create_process), KERNEL_XKERNEL_CREATE_PROCESS_TMP (kernel_create_process),kernel_process_struct::kernel_pid_list (kernel_create_process) DECDEB, DECFIN, DECCIB,DECTRV,ACC1M VEXBNK, BUFEDT, BNKOLD, KERNEL_TMP_XEXEC, BNK_TO_SWITCH, KERNEL_KERNEL_XEXEC_BNKOLD Example lda # < str ldy # > str BRK_KERNEL XEXEC rts str: .asciiz \"mybin\" XEXEC does not manage './' calls","title":"XEXEC"},{"location":"kernel/primitives/xexec/#xexec","text":"","title":"XEXEC"},{"location":"kernel/primitives/xexec/#description","text":"Start a binary (located in a ROM or on the current device)","title":"Description"},{"location":"kernel/primitives/xexec/#input","text":"A & Y the ptr of the string.","title":"Input"},{"location":"kernel/primitives/xexec/#output","text":"Returns an error if the binary is not found","title":"Output"},{"location":"kernel/primitives/xexec/#modification","text":"RES, RESB (kernel_create_process), TR0, TR1, TR4 (kernel_create_process), TR5 (kernel_create_process) KERNEL_ERRNO (kernel_create_process), KERNEL_XKERNEL_CREATE_PROCESS_TMP (kernel_create_process),kernel_process_struct::kernel_pid_list (kernel_create_process) DECDEB, DECFIN, DECCIB,DECTRV,ACC1M VEXBNK, BUFEDT, BNKOLD, KERNEL_TMP_XEXEC, BNK_TO_SWITCH, KERNEL_KERNEL_XEXEC_BNKOLD","title":"Modification :"},{"location":"kernel/primitives/xexec/#example","text":"lda # < str ldy # > str BRK_KERNEL XEXEC rts str: .asciiz \"mybin\" XEXEC does not manage './' calls","title":"Example"},{"location":"kernel/primitives/xgetargv/","text":"XGETARGV Description Get argv. X register contains the number of the arg search Kernel handle a struct with XMAINARGS. This struct is handled by Kernel, and no action are required in external code, but here is how struct works : .struct XMAINARGS_STRUCT argv_ptr .res KERNEL_MAX_ARGS_COMMAND_LINE argv_value_ptr .res KERNEL_LENGTH_MAX_CMDLINE + KERNEL_MAX_ARGS_COMMAND_LINE ; add 0 to string .endstruct argv_ptr contains an offset of each param. It means that we can't have a length of args greater than 256. XMAINARGS and XGETARGV does not handle \"\" yet and \"\\ \" Input A & Y the ptr of struct from XMAINARGS X the number of arg to get, first param is 0 not 1 ! Output A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed Example XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr + 1 ldx # $02 ; get arg 2 ; Get the third param lda debug_mainargs_ptr ldy debug_mainargs_ptr + 1 BRK_KERNEL XGETARGV ; A & Y contains ptr","title":"XGETARGV"},{"location":"kernel/primitives/xgetargv/#xgetargv","text":"","title":"XGETARGV"},{"location":"kernel/primitives/xgetargv/#description","text":"Get argv. X register contains the number of the arg search Kernel handle a struct with XMAINARGS. This struct is handled by Kernel, and no action are required in external code, but here is how struct works : .struct XMAINARGS_STRUCT argv_ptr .res KERNEL_MAX_ARGS_COMMAND_LINE argv_value_ptr .res KERNEL_LENGTH_MAX_CMDLINE + KERNEL_MAX_ARGS_COMMAND_LINE ; add 0 to string .endstruct argv_ptr contains an offset of each param. It means that we can't have a length of args greater than 256. XMAINARGS and XGETARGV does not handle \"\" yet and \"\\ \"","title":"Description"},{"location":"kernel/primitives/xgetargv/#input","text":"A & Y the ptr of struct from XMAINARGS X the number of arg to get, first param is 0 not 1 !","title":"Input"},{"location":"kernel/primitives/xgetargv/#output","text":"A & Y contains argv ptr from xmainargs struct. It returns a copy of the command line with args parsed","title":"Output"},{"location":"kernel/primitives/xgetargv/#example","text":"XMAINARGS = $2C XGETARGV = $2E BRK_KERNEL XMAINARGS sta debug_mainargs_ptr sty debug_mainargs_ptr + 1 ldx # $02 ; get arg 2 ; Get the third param lda debug_mainargs_ptr ldy debug_mainargs_ptr + 1 BRK_KERNEL XGETARGV ; A & Y contains ptr","title":"Example"},{"location":"kernel/primitives/xgetcwd/","text":"XGETCWD (getcwd) Description Return current directory of the process Input Output A/Y returns a string Example BRK_KERNEL XGETCWD BRK_KERNEL XWSTR0 rts","title":"XGETCWD (getcwd)"},{"location":"kernel/primitives/xgetcwd/#xgetcwd-getcwd","text":"","title":"XGETCWD (getcwd)"},{"location":"kernel/primitives/xgetcwd/#description","text":"Return current directory of the process","title":"Description"},{"location":"kernel/primitives/xgetcwd/#input","text":"","title":"Input"},{"location":"kernel/primitives/xgetcwd/#output","text":"A/Y returns a string","title":"Output"},{"location":"kernel/primitives/xgetcwd/#example","text":"BRK_KERNEL XGETCWD BRK_KERNEL XWSTR0 rts","title":"Example"},{"location":"kernel/primitives/xmainargs/","text":"XMAINARGS (argmains) ID primitive : $2C Description Return argc and argv Input Nothing Output A & Y contains ptr to XMAINARGS Struct X: number of args Usage XMAINARGS = $2C brk_kernel XMAINARGS stx save_argc sta save_argvlow sty save_argvhigh","title":"XMAINARGS (argmains)"},{"location":"kernel/primitives/xmainargs/#xmainargs-argmains","text":"ID primitive : $2C","title":"XMAINARGS (argmains)"},{"location":"kernel/primitives/xmainargs/#description","text":"Return argc and argv","title":"Description"},{"location":"kernel/primitives/xmainargs/#input","text":"Nothing","title":"Input"},{"location":"kernel/primitives/xmainargs/#output","text":"A & Y contains ptr to XMAINARGS Struct X: number of args","title":"Output"},{"location":"kernel/primitives/xmainargs/#usage","text":"XMAINARGS = $2C brk_kernel XMAINARGS stx save_argc sta save_argvlow sty save_argvhigh","title":"Usage"},{"location":"kernel/primitives/xmalloc/","text":"XMALLOC (malloc) Description Allocate memory. Use orix-sdk with macro to handle XMALLOC Input A and Y : number of bytes Output A&Y = $0000 : OOM or others errors else A&Y : ptr Usage lda # < 4000 ldy # > 4000 BRK_TELEMON XMALLOC ; A & Y contains a ptr rts","title":"XMALLOC (malloc)"},{"location":"kernel/primitives/xmalloc/#xmalloc-malloc","text":"","title":"XMALLOC (malloc)"},{"location":"kernel/primitives/xmalloc/#description","text":"Allocate memory. Use orix-sdk with macro to handle XMALLOC","title":"Description"},{"location":"kernel/primitives/xmalloc/#input","text":"A and Y : number of bytes","title":"Input"},{"location":"kernel/primitives/xmalloc/#output","text":"A&Y = $0000 : OOM or others errors else A&Y : ptr","title":"Output"},{"location":"kernel/primitives/xmalloc/#usage","text":"lda # < 4000 ldy # > 4000 BRK_TELEMON XMALLOC ; A & Y contains a ptr rts","title":"Usage"},{"location":"kernel/primitives/xmkdir/","text":"XMKDIR (mkdir) ID primitive : $4B Description Create a folder. But it does not support absolute path for instance. It can only create path in the current path. Input A and Y : ptr of the string Output Return #ENODEV if the device can't be mount Usage lda # < str ldy # > str BRK_TELEMON XMKDIR rts str: .asciiz \"myfolder\"","title":"XMKDIR (mkdir)"},{"location":"kernel/primitives/xmkdir/#xmkdir-mkdir","text":"ID primitive : $4B","title":"XMKDIR (mkdir)"},{"location":"kernel/primitives/xmkdir/#description","text":"Create a folder. But it does not support absolute path for instance. It can only create path in the current path.","title":"Description"},{"location":"kernel/primitives/xmkdir/#input","text":"A and Y : ptr of the string","title":"Input"},{"location":"kernel/primitives/xmkdir/#output","text":"Return #ENODEV if the device can't be mount","title":"Output"},{"location":"kernel/primitives/xmkdir/#usage","text":"lda # < str ldy # > str BRK_TELEMON XMKDIR rts str: .asciiz \"myfolder\"","title":"Usage"},{"location":"kernel/primitives/xopen/","text":"XOPEN","title":"XOPEN"},{"location":"kernel/primitives/xopen/#xopen","text":"","title":"XOPEN"},{"location":"kernel/primitives/xputcwd/","text":"XPUTCWD (chdir) Description Change current process directory Input A & Y the 16 bits values (string with \\0) Output N/A Example lda # < str ldy # > str BRK_KERNEL XPUTCWD rts str: .asciiz \"/etc\"","title":"XPUTCWD (chdir)"},{"location":"kernel/primitives/xputcwd/#xputcwd-chdir","text":"","title":"XPUTCWD (chdir)"},{"location":"kernel/primitives/xputcwd/#description","text":"Change current process directory","title":"Description"},{"location":"kernel/primitives/xputcwd/#input","text":"A & Y the 16 bits values (string with \\0)","title":"Input"},{"location":"kernel/primitives/xputcwd/#output","text":"N/A","title":"Output"},{"location":"kernel/primitives/xputcwd/#example","text":"lda # < str ldy # > str BRK_KERNEL XPUTCWD rts str: .asciiz \"/etc\"","title":"Example"},{"location":"kernel/primitives/xscrob/","text":"XSCROB (Scroll down) Scroll all lines from the top to the bottom ldx # $01 ldy # 25 BRK_KERNEL XSCROB","title":"XSCROB (Scroll down)"},{"location":"kernel/primitives/xscrob/#xscrob-scroll-down","text":"Scroll all lines from the top to the bottom ldx # $01 ldy # 25 BRK_KERNEL XSCROB","title":"XSCROB (Scroll down)"},{"location":"kernel/primitives/xscroh/","text":"XSCROH (Scrollup text mode) scroll all lines from bottom to the top ldx # $01 ldy # 26 BRK_KERNEL XSCROH","title":"XSCROH (Scrollup text mode)"},{"location":"kernel/primitives/xscroh/#xscroh-scrollup-text-mode","text":"scroll all lines from bottom to the top ldx # $01 ldy # 26 BRK_KERNEL XSCROH","title":"XSCROH (Scrollup text mode)"},{"location":"libs/twillib/","text":"Twil libs Manage rom/ram banks unsigned char twil_program_rambank ( unsigned char bank , char * file , unsigned char set ); unsigned char twil_clear_rambank ( unsigned char bank , unsigned char set ); unsigned char twil_lib_version ( void );","title":"Twilighte librairy"},{"location":"libs/twillib/#twil-libs","text":"Manage rom/ram banks unsigned char twil_program_rambank ( unsigned char bank , char * file , unsigned char set ); unsigned char twil_clear_rambank ( unsigned char bank , unsigned char set ); unsigned char twil_lib_version ( void );","title":"Twil libs"},{"location":"samples/asm_samples/","text":"Samples in Assembly Malloc Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 : = userzp malloc 4000 , myptr3 , str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Samples in Assembly"},{"location":"samples/asm_samples/#samples-in-assembly","text":"","title":"Samples in Assembly"},{"location":"samples/asm_samples/#malloc","text":"Allocate 4000 bytes and displays a message if the 4000 bytes can't be allocated, else store ptr to myptr3 malloc is done with Orix-sdk .include \"telestrat.inc\" .include \"macros/SDK.mac\" myptr3 : = userzp malloc 4000 , myptr3 , str_enomem ; Index ptr rts str_enoemem: .asciiz \"Out of memory\"","title":"Malloc"},{"location":"samples/c_samples/","text":"Open and read files with cc65 #include <stdio.h> unsigned char chars [ 255 ]; main (){ fp = fopen ( \"/myfile\" , \"r\" ); if ( fp == NULL ) { printf ( \"Can't open %s \\n \" , argv [ 1 ]); return ( 1 ); } nb = fread ( chars , 255 , 1 , fp ); fclose ( fp ); }","title":"Open and read files with cc65"},{"location":"samples/c_samples/#open-and-read-files-with-cc65","text":"#include <stdio.h> unsigned char chars [ 255 ]; main (){ fp = fopen ( \"/myfile\" , \"r\" ); if ( fp == NULL ) { printf ( \"Can't open %s \\n \" , argv [ 1 ]); return ( 1 ); } nb = fread ( chars , 255 , 1 , fp ); fclose ( fp ); }","title":"Open and read files with cc65"},{"location":"samples/c_samples/getcwd/","text":"Get CWD in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD = $48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd (); int main () { printf ( \"Cwd : %s\" , ogetcwd ()); return 0 ; }","title":"Get CWD in cc65"},{"location":"samples/c_samples/getcwd/#get-cwd-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _ogetcwd.s. It must contains : .include \"telestrat.inc\" XGETCWD = $48 .export _ogetcwd .importzp tmp1 .proc _ogetcwd BRK_TELEMON XGETCWD sty tmp1 ldx tmp1 rts .endproc And now, you C code, you can do (don't forget to add _ogetcwd.s to your command line to build _ogetcwd.s when you launch cl65): extern unsigned char ogetcwd (); int main () { printf ( \"Cwd : %s\" , ogetcwd ()); return 0 ; }","title":"Get CWD in cc65"},{"location":"samples/c_samples/mkdir/","text":"Create a folder with cc65 For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir ( unsigned char * path ); int main () { mkdir ( \"myfolder\" ); return 0 ; }","title":"Create a folder with cc65"},{"location":"samples/c_samples/mkdir/#create-a-folder-with-cc65","text":"For instance mkdir in cc65 telestrat target is bugged, here is a work around. Create a file _omkdir.s. It must contains : mkdir kernel primitive does not support absolute path, and it can only create folder in CWD. .include \"telestrat.inc\" .export _omkdir .importzp tmp1 .proc _omkdir stx tmp1 ldy tmp1 BRK_TELEMON XMKDIR rts .endproc And now, you C code, you can do (don't forget to add _omkdir.s to your command line to build _omkdir.s when you launch cl65): extern void omkdir ( unsigned char * path ); int main () { mkdir ( \"myfolder\" ); return 0 ; }","title":"Create a folder with cc65"},{"location":"samples/c_samples/putcwd/","text":"chdir in cc65 For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD = $49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd (); int main () { oputcwd ( \"/etc\" ); return 0 ; }","title":"chdir in cc65"},{"location":"samples/c_samples/putcwd/#chdir-in-cc65","text":"For instance chdir, is not manage in cc65, then here is a workaround. Create a file _oputcwd.s. It must contains : .include \"telestrat.inc\" XPUTCWD = $49 .export _oputcwd .importzp tmp1 .proc _oputcwd stx tmp1 ldy tmp1 BRK_TELEMON XPUTCWD rts .endproc And now, you C code, you can do (don't forget to add _oputcwd.s to your command line to build _oputcwd.s when you launch cl65): extern unsigned char oputcwd (); int main () { oputcwd ( \"/etc\" ); return 0 ; }","title":"chdir in cc65"},{"location":"samples/c_samples/writefile/","text":"Write a file #include <stdio.h> static unsigned char buffer [ 4000 ]; int main () { FILE * fp ; unsigned int nb_write ; static unsigned char destfilename [ 9 ] = \"myfile.txt\" ; fp = fopen ( destfilename , \"wb\" ); if ( ! fp ) { printf ( \"Can't create output file \\n \" ); return 1 ; } nb_write = fwrite ( buffer , 1 , 4000 , fp ); fclose ( fp ); }","title":"Write a file"},{"location":"samples/c_samples/writefile/#write-a-file","text":"#include <stdio.h> static unsigned char buffer [ 4000 ]; int main () { FILE * fp ; unsigned int nb_write ; static unsigned char destfilename [ 9 ] = \"myfile.txt\" ; fp = fopen ( destfilename , \"wb\" ); if ( ! fp ) { printf ( \"Can't create output file \\n \" ); return 1 ; } nb_write = fwrite ( buffer , 1 , 4000 , fp ); fclose ( fp ); }","title":"Write a file"},{"location":"tasks/cc65/","text":"Task for cc65 clock() fix mkdir bug readdir()","title":"Task for cc65"},{"location":"tasks/cc65/#task-for-cc65","text":"clock() fix mkdir bug readdir()","title":"Task for cc65"},{"location":"tasks/kernel/","text":"Kernel fix kernel panic in free primitive keep bank memory empty flag Find a way to keep kernel version somewhere","title":"Kernel"},{"location":"tasks/kernel/#kernel","text":"fix kernel panic in free primitive keep bank memory empty flag Find a way to keep kernel version somewhere","title":"Kernel"},{"location":"tasks/orixcfg/","text":"Orixcfg add orixcfg -p [idbank] filerom.rom (with header)","title":"Orixcfg"},{"location":"tasks/orixcfg/#orixcfg","text":"add orixcfg -p [idbank] filerom.rom (with header)","title":"Orixcfg"},{"location":"tools/mount/","text":"Mount (not developed yet) FP Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null. When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action : X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE ls case ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel cp/mv case don't know","title":"Mount (not developed yet)"},{"location":"tools/mount/#mount-not-developed-yet","text":"","title":"Mount (not developed yet)"},{"location":"tools/mount/#fp","text":"Each FP has a struct with with string, flag and others 3 bytes : extbank (1 byte) vectorbank (2 bytes) When a fopen is done, if the file is not found on current device (ch376), before it returns null, it tries to find EXTFP string in bank If it's found, EXTFP is executed (not forked) and it returns a A Y vector to manage this FP (if it manage this path). If it does not manage this path, it return null.","title":"FP"},{"location":"tools/mount/#when-a-freadfwrite-is-done-if-extbank-is-different-to-0-then-kernel-will-launch-external-vector-with-a-and-y-contains-the-string-of-the-path-and-x-contains-the-action","text":"X=1 : FREAD X=2 : FWRITE X=3 : XCLOSE","title":"When a FREAD/FWRITE is done, if extbank is different to 0, then, Kernel will launch external vector with A and Y contains the string of the path, and X contains the action :"},{"location":"tools/mount/#ls-case","text":"ls should do a FOPEN call. It should return a fp. When we need to displays the external path, we need to know which command we need to launch to kernel","title":"ls case"},{"location":"tools/mount/#cpmv-case","text":"don't know","title":"cp/mv case"}]}