{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos Stratos . Twilighte Board . Orix 8 bits - Kernel Orix 16 bits Basic11 command and rom ch376 Doxygen for kernel .","title":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos"},{"location":"#documentation-for-orix8-bits-and-16-bits-twilighte-board-and-stratos","text":"Stratos . Twilighte Board . Orix 8 bits - Kernel Orix 16 bits Basic11 command and rom ch376 Doxygen for kernel .","title":"Documentation for Orix(8 bits and 16 bits), twilighte board, and Stratos"},{"location":"basic11/","text":"Fonctionnement Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance Si on tape : /#basic11 Cela lance la ROM Si on tape : /#basic11 \"TAPEFILE\" Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom. Si on tape : /#basic11 -l Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici Fonctionnement global Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1 Format du fichier .db version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Fonctionnement"},{"location":"basic11/#fonctionnement","text":"Dans tous les cas, les valeurs de RND en $FA ont \u00e9t\u00e9 copi\u00e9es en avance","title":"Fonctionnement"},{"location":"basic11/#si-on-tape-basic11","text":"Cela lance la ROM","title":"Si on tape : /#basic11"},{"location":"basic11/#si-on-tape-basic11-tapefile","text":"Cela va chercher la pr\u00e9sence d'un fichier db dans /var/cache/basic11/[FIRSTLETTEROFTAPEFILE]/TAPEFILE.db Si TAPEFILE.db est pr\u00e9sent, il va lire les 1er octets du fichiers pour poker en $F1 les I/O des joysticks, sinon il va d\u00e9marrer la banque 6 qui est la ROM par d\u00e9faut qui contient le path courant : /home/basic11/ Le code va regarder l'id de la ROM (stock\u00e9e en $F2 suite au load des confs au point pr\u00e9c\u00e9dent Cela va d\u00e9tecter aussi si le device par d\u00e9faut est la sdcard ou la cl\u00e9 usb Le code va concat\u00e9ner /usr/share/basic11/basic avec le device courant (us ou sd) puis l'id de la rom converti en ascii La rom va \u00eatre charg\u00e9e en ram principale puis basic11 va copier un driver en ram principale. Si la rom demand\u00e9e n'est pas trouv\u00e9e, le programme s'arr\u00eate avec un message d'erreur. Ce driver passe en RAM 0 (banque 0) copie la ROM charg\u00e9e en ram principale, puis va patcher le path par d\u00e9faut pour acc\u00e9der au .tap demand\u00e9. Ainsi, la ROM serait pr\u00e9sente en RAM 0, avec le path par d\u00e9faut tel que : /usr/share/basic11/3/ pour 3dfongus Ainsi, la ROM a en argument 3Dfongus, et la rom charge donc \u00e0 partir de l\u00e0. Le code g\u00e8re un maximum de 9 roms en mode usb, et 9 en rom sd. Un soft d\u00e9fini avec une ROM 10 ne fonctionnera pas, c'est \u00e0 dire que la rom ne sera pas charg\u00e9e, et un message d'erreur dira qu'il ne trouve pas la rom.","title":"Si on tape : /#basic11 \"TAPEFILE\""},{"location":"basic11/#si-on-tape-basic11-l","text":"Cela va ouvrir le fichier /var/cache/basic11/basic11.db Et cela va lire la cl\u00e9 du .tap et le nom du soft tronqu\u00e9 \u00e0 29 chars. L'espace et le ctrl+c fonctionne ici","title":"Si on tape : /#basic11 -l"},{"location":"basic11/#fonctionnement-global","text":"Si la rom est lanc\u00e9e sans .tap ou avec un .tap, syst\u00e9matiquement, les valeurs de RND seront \u00e9crites en dur en RAM de $FA \u00e0 $FF. Cela interfera \u00e0 terme avec la ROM basic oric-1","title":"Fonctionnement global"},{"location":"basic11/#format-du-fichier-db","text":"version_bin : 1 byte (binary) rombasic11 : 1 byte, id of the rom fire2_joy : keyboard fire2 matrix fire3_joy : keyboard fire2 matrix down_joy : keyboard fire2 matrix right_joy : keyboard fire2 matrix left_joy : keyboard fire2 matrix fire1_joy : keyboard fire2 matrix up_joy : keyboard fire2 matrix","title":"Format du fichier .db"},{"location":"orix8bits/","text":"Kernel primitives Doxygen for kernel . Samples for kernel calls Get ctrl+c hook .include \"telestrat.inc\" asl KBDCTC bcc @no_ctrl ; here is ctrl management @no_ctrl: rts Test kernel Error when fopen failed ; Open ... BRK_KERNEL XOPEN cpy #$00 bne @read_rom cmp #$00 bne @read_rom ldx #$04 ; Get kernel ERRNO BRK_KERNEL XVARS sta userzp sty userzp+1 ldy #$00 lda (userzp),y ; get ERRNO from kernel cmp #ENOMEM bne @no_enomem_kernel_error PRINT str_enomem @no_enomem_kernel_error: cmp #ENOENT bne @no_enoent_kernel_error PRINT str_not_found Stop output when spacebar is pressed (for example) .include \"telestrat.inc\" @L12: BRK_KERNEL XRD0 bcs @no_char_action cmp #' ' ; Space pressed ? bne @no_char ; no continue lda myOffsetToManageSwitch ; One byte beq @inv_to_1 lda #$00 sta myOffsetToManageSwitch jmp @L12 @inv_to_1: inc myOffsetToManageSwitch jmp @L12 @no_char_action: lda myOffsetToManageSwitch beq @L12 @no_char: ; No keypressed Displays a string lda #<mystr ldy #>mystr BRK_KERNEL XWRSTR0 rts mysstr: .asciiz \"hello\"","title":"Index"},{"location":"orix8bits/#_1","text":"","title":""},{"location":"orix8bits/#kernel-primitives","text":"Doxygen for kernel .","title":"Kernel primitives"},{"location":"orix8bits/#samples-for-kernel-calls","text":"","title":"Samples for kernel calls"},{"location":"orix8bits/#get-ctrlc-hook","text":".include \"telestrat.inc\" asl KBDCTC bcc @no_ctrl ; here is ctrl management @no_ctrl: rts","title":"Get ctrl+c hook"},{"location":"orix8bits/#test-kernel-error-when-fopen-failed","text":"; Open ... BRK_KERNEL XOPEN cpy #$00 bne @read_rom cmp #$00 bne @read_rom ldx #$04 ; Get kernel ERRNO BRK_KERNEL XVARS sta userzp sty userzp+1 ldy #$00 lda (userzp),y ; get ERRNO from kernel cmp #ENOMEM bne @no_enomem_kernel_error PRINT str_enomem @no_enomem_kernel_error: cmp #ENOENT bne @no_enoent_kernel_error PRINT str_not_found","title":"Test kernel Error when fopen failed"},{"location":"orix8bits/#stop-output-when-spacebar-is-pressed-for-example","text":".include \"telestrat.inc\" @L12: BRK_KERNEL XRD0 bcs @no_char_action cmp #' ' ; Space pressed ? bne @no_char ; no continue lda myOffsetToManageSwitch ; One byte beq @inv_to_1 lda #$00 sta myOffsetToManageSwitch jmp @L12 @inv_to_1: inc myOffsetToManageSwitch jmp @L12 @no_char_action: lda myOffsetToManageSwitch beq @L12 @no_char: ; No keypressed","title":"Stop output when spacebar is pressed (for example)"},{"location":"orix8bits/#displays-a-string","text":"lda #<mystr ldy #>mystr BRK_KERNEL XWRSTR0 rts mysstr: .asciiz \"hello\"","title":"Displays a string"},{"location":"stratos/","text":"Stratos Specs G\u00e9n\u00e9rales 15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier Fonctionnement atmos compatible La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ? Cas non g\u00e9r\u00e9s WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC Controleur usb, sdcard, clavier, souris Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi) Port ethernet ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ... EEprom kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg Kernel Orix 16bits appels via jsr avec un param\u00e8tre de primitive ?","title":"Stratos"},{"location":"stratos/#stratos","text":"","title":"Stratos"},{"location":"stratos/#specs-generales","text":"15 Mo de SRAM 1 mo d'eeprom Voir s'il faut faire une SRAM s\u00e9par\u00e9e pour la vid\u00e9o \u00e0 terme (mais passer en QFP 144 car pas assez de pinout pour s\u00e9parer les bus) ULA 2 am\u00e9lior\u00e9e 65c816 \u00e0 14Mhz port USB, port sdcard (stockage principal) Os : Orix langage : forth, basic atmos etc ... Peut \u00eatre plac\u00e9 dans le boitier atmos. Il reste n\u00e9anmoins la question des ports joysticks qu'il faut arriver \u00e0 faire sortir du boitier","title":"Specs G\u00e9n\u00e9rales"},{"location":"stratos/#fonctionnement-atmos-compatible","text":"La rom atmos est pr\u00eate pour lire des .tap directement sedoric version sdcard est en cours d'\u00e9criture ftdos en cours d'\u00e9criture Detection du mode en fonction de la broche E du cpu ? Si \u00e9mulation = mode atmos ? Lancement de basic11 : chargement en RAM de la rom associ\u00e9e dans les 16 Mo par malloc, puis virtualisation des adresses dans le cpld avec un registre ?","title":"Fonctionnement atmos compatible"},{"location":"stratos/#cas-non-geres","text":"WIFI : pour l'instant port ethernet avec stack tcp/ip hardware (voir port ethernet), voir s'il faut un ESP32 R\u00e9el FDC","title":"Cas non g\u00e9r\u00e9s"},{"location":"stratos/#controleur-usb-sdcard-clavier-souris","text":"Ch376 : fat 32, port USB, HID, drivers \u00e9crits (\u00e9mulation aussi)","title":"Controleur usb, sdcard, clavier, souris"},{"location":"stratos/#port-ethernet","text":"ch395 : stack tcp/ip, socket g\u00e9r\u00e9s : 8, icmp ...","title":"Port ethernet"},{"location":"stratos/#eeprom","text":"kernel et tout ce qui se met en rom tel que shell, forth etc. Programmation : orixcfg","title":"EEprom"},{"location":"stratos/#kernel-orix-16bits","text":"appels via jsr avec un param\u00e8tre de primitive ?","title":"Kernel Orix 16bits"},{"location":"twilighteboard/","text":"Twilighte board FDC, RTC WIFI controller firmware version 1 $342 : twilighte board register b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set $343 : Banking register Working board version with this firmware: v0.6 v0.65 firmware version 2 Reserved for twilighte board v0.6 & v0.65 upgrades firmware version 3 $342 b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ... $343 Banking register Notes Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version Twilighte board version 0.6 dirty hack for ca3083 replacement Twilighte board version 0.65 ca3083 removed and are replaced with BC547 Twilighte board version 0.7 Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board"},{"location":"twilighteboard/#twilighte-board","text":"FDC, RTC WIFI controller","title":"Twilighte board"},{"location":"twilighteboard/#firmware-version-1","text":"","title":"firmware version 1"},{"location":"twilighteboard/#342-twilighte-board-register","text":"b0,b1,b2 version number is equal to 1, but can be overwritten (There is not read only protection b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set","title":"$342 : twilighte board register"},{"location":"twilighteboard/#343-banking-register","text":"Working board version with this firmware: v0.6 v0.65","title":"$343 : Banking register"},{"location":"twilighteboard/#firmware-version-2","text":"Reserved for twilighte board v0.6 & v0.65 upgrades","title":"firmware version 2"},{"location":"twilighteboard/#firmware-version-3","text":"","title":"firmware version 3"},{"location":"twilighteboard/#342","text":"b0,b1,b2 version number is equal to 1, but can be overwritten b5 : if it's equal to 0 if we are on eeprom set, 1 if it's ram set b6 : allow ftdos I/O b7 : allow microdisc I/O : $314 $310, $311 ...","title":"$342"},{"location":"twilighteboard/#343","text":"Banking register","title":"$343"},{"location":"twilighteboard/#notes","text":"Port A of via 65C22, b0,b1,b2 are managed by cpld Working board version","title":"Notes"},{"location":"twilighteboard/#twilighte-board-version-06","text":"dirty hack for ca3083 replacement","title":"Twilighte board version 0.6"},{"location":"twilighteboard/#twilighte-board-version-065","text":"ca3083 removed and are replaced with BC547","title":"Twilighte board version 0.65"},{"location":"twilighteboard/#twilighte-board-version-07","text":"Level shifters for esp32 esp32 can be on the card (WROOM 32) but maybe it's not useful","title":"Twilighte board version 0.7"},{"location":"twilighteboard/fdcWifiEsp/","text":"fdcsd I/O : * $315 : command port * $316 : data port ESP32_CHECK_EXIST ESP32_CHECK_EXIST = $06 Return data inverted bit ESP32_GET_IC_VER ESP32_GET_IC_VER = $01 Return version ESP32_SET_MODE CH376_SET_MODE = $15 Set mode ESP32_SET_MODE_CODE_FDC ESP32_LAUNCH_WIFI_SCAN $02 interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#fdcsd","text":"I/O : * $315 : command port * $316 : data port","title":"fdcsd"},{"location":"twilighteboard/fdcWifiEsp/#esp32_check_exist","text":"ESP32_CHECK_EXIST = $06 Return data inverted bit","title":"ESP32_CHECK_EXIST"},{"location":"twilighteboard/fdcWifiEsp/#esp32_get_ic_ver","text":"ESP32_GET_IC_VER = $01 Return version","title":"ESP32_GET_IC_VER"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode","text":"CH376_SET_MODE = $15 Set mode","title":"ESP32_SET_MODE"},{"location":"twilighteboard/fdcWifiEsp/#esp32_set_mode_code_fdc","text":"","title":"ESP32_SET_MODE_CODE_FDC"},{"location":"twilighteboard/fdcWifiEsp/#esp32_launch_wifi_scan-02","text":"interrupt return a struct : 2 bytes for the length of all ssid, and all sid ESP32_DETECTED = $AA CH376_CMD_NONE = $00 CH376_GET_ENTER_SLEEP = $03 CH276_SET_USB_SPEED = $04 CH376_RESET_ALL = $05 CH376_GET_FILE_SIZE = $0C ; Get the current file length CH376_SET_USB_MODE = $15 CH376_GET_STATUS = $22 CH376_RD_USB_DATA0 = $27 CH376_WR_USB_DATA = $2C CH376_CMD_WR_REQ_DATA = $2D CH376_SET_FILE_NAME = $2F CH376_DISK_CONNECT = $30 ; check the disk connection status CH376_DISK_MOUNT = $31 CH376_FILE_OPEN = $32 CH376_FILE_ENUM_GO = $33 CH376_CMD_FILE_CREATE = $34 CH376_FILE_ERASE = $35 CH376_FILE_CLOSE = $36 CH376_BYTE_LOCATE = $39 CH376_BYTE_READ = $3A CH376_BYTE_RD_GO = $3B CH376_BYTE_WRITE = $3C CH376_BYTE_WR_GO = $3D CH376_DISK_CAPACITY = $3E CH376_DISK_QUERY = $3F CH376_DIR_CREATE = $40 CH376_SET_ADRESS = $45 CH376_GET_DESCR = $46 CH376_DISK_RD_GO = $55 ; CODE FOR CH376_SET_USB_MODE CH376_SET_USB_MODE_CODE_SDCARD = $03 ; The code of 06H means switch to valid USB-HOST, produce SOF package automatically. CH376_SET_USB_MODE_CODE_USB_HOST_SOF_PACKAGE_AUTOMATICALLY = $06 CH376_USB_INT_SUCCESS = $14 CH376_USB_INT_CONNECT = $15 CH376_USB_INT_DISCONNECT = $16 CH376_USB_INT_BUF_OVER = $17 CH376_USB_INT_USB_READY = $18 CH376_USB_INT_DISK_READ = $1d CH376_USB_INT_DISK_WRITE = $1e CH376_USB_INT_DISK_ERR = $1f CH376_ERR_OPEN_DIR = $41 CH376_ERR_MISS_FILE = $42 CH376_ERR_FOUND_NAME = $43 CH376_ERR_DISK_DISCON = $82 CH376_ERR_LARGE_SECTOR = $84 CH376_ERR_TYPE_ERROR = $92 CH376_ERR_BPB_ERROR = $A1 CH376_ERR_DISK_FULL = $B1 CH376_ERR_FDT_OVER = $B2 CH376_ERR_FILE_CLOSE = $B4","title":"ESP32_LAUNCH_WIFI_SCAN $02"}]}